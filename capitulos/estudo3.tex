\xchapter{Ciclo de vida de software acadêmico de análise estática}{}
\label{estudo3}

%* posicionar os projetos em algum estagio do ciclo de staged model
%* verificar a ultima mensagem (issue ou lista) e usar isso como indicio de projetos na fase "phase out"
%  (se um projeto tem issue a muito tempo (1 ano, 2 anos) isso significa que o projeto esta em phase out
%* se os projetos nao estao disponiveis eles estao em closedown, ou seja, vou jogar todos que estao
%  sem disponibilidade para esta fase!
%* coletar o numero de classes para faer grafico ao longo do tempo para 

%(ber artigo original de staged e o adaptaado ao foss para costurar nas conclusoes)
%(exemplo: manter projetos disponivel o mais tempo possivel eh importante etc...)

Este capítulo apresenta um estudo sobre o estágio de evolução do ciclo de vida
de software acadêmico de análise estática em termos de número de lançamentos e
tamanho dos projetos em número de módulos apresentados no código fonte.

Este estudo caracterizou projetos de software acadêmico de análise estática em
relação ao estágio de evolução do ciclo de vida com base no modelo {\it
``Staged Model for Software Evolution''} através da coleta de informaçoes sobre
lançamentos e versões dos projetos bem como da coleta através do código fonte
do número de módulos (arquivos ou classes) destes projetos em cada versão
disponibilizada em código fonte.

A seção \ref{estudo3:introducao} contextualiza o estudo,
a seção \ref{estudo3:fundamentacao} apresenta os conceitos teóricos necessários para compreensão do trabalho,
a seção \ref{estudo3:escopo} descreve o objetivo e apresenta as questões de pesquisa,
a seção \ref{estudo3:planejamento} apresenta um planejamento do estudo,
as seções \ref{estudo3:preparacao} e \ref{estudo3:coleta} apresentam detalhes sobre a preparação e execução da coleta de dados,
as seções \ref{estudo3:analise} e \ref{estudo3:interpretacao} apresentam a análise e interpretação dos dados e
a seção \ref{estudo3:conclusoes} traça as conclusões finais deste estudo.

\section{Motivação} \label{estudo3:introducao}

Neste estudo iremos caracterizar projetos de software acadêmico de análise
estática quanto ao seu estágio no ciclo de vida de software de acordo o modelo
{\it ``Staged Model for Software Evolution''}
\cite{rajlich2000staged}, neste modelo o software inicia seu ciclo de
vida na fase {\it ``Initial development''}, passando pelas fases {\it
``Evolution''}, {\it ``Servicing''}, {\it ``Phase-out''}, e encerrando seu ciclo
na fase {\it ``Close-down''}, quando as empresas dedentoras do
software o retiram do mercado.

Em modelos de produção distintos e não-tradicionais, como é o modelo de
software acadêmico ou software livre, por exemplo, este ciclo de vida pode
variar. No modelo {\it ``Staged Model for Software Evolution''} adaptado a
projetos software livre \cite{capiluppi2007adapting}, por exemplo, o ciclo de
vida não se encerra na fase de {\it ``Close-down''}, uma vez que estes projetos
não são retirados do mercado por empresas, podendo haver um caminho de retorno
entre as diversas fases, incluindo o retorno para a fase inicial de {\it
``Initial development''}, por exemplo.

Os projetos de software acadêmico caracterizados neste estudo são considerados
como projetos de software livre sob a perspectiva do modelo proposto por
\citeonline{capiluppi2007adapting}, uma vez que não há entre eles projetos
comerciais de propriedade exclusiva de empresas, enquadram-se muito melhor
neste modelo do que no modelo tradicional de software comercial não-livre
originalmente proposto por \citeonline{rajlich2000staged}.

A caracterização dos projetos de software acadêmico de análise estática quando
ao ciclo de vida será feito sob a perspectiva de cientistas desenvolvedores e
usuários finais de software interessados em compreender em que estágio de
desenovolvimento e evolução estão os projetos do ecossistema de software
acadêmico de análise estática uma vez que saber em que fase um software está é
útil ao se tomar decisão de adotar um certo software como uso ou mesmo como
objeto de contribuição.

%O ideal seria eu posicionar cada projeto num dos estágios do modelo (staged model) e aí sim
%poderia comparar projetos distintos, comparar dois projetos em fase de "manutenção" pode
%dar alguma respostas interessante.

\section{Fundamentação} \label{estudo3:fundamentacao}

(staged model, métrica para contar módulos, lançamentos/releases)

\section{Escopo} \label{estudo3:escopo} % {{{

% Por que o estudo será realizado?
% explore how the amount of structural complexity and available documentation may influence
% the different levels of participation in an academic software ecosystem.

\subsection{Definição do Objetivo}

\begin{description}
\item{\bf Objeto de estudo.}
O objeto de estudo são projetos de software acadêmico de análise estática.

\item{\bf Propósito.}
O propósito deste estudo é caracterizar 

\item{\bf Perspectiva.}
A perspectiva considerada é a de cientistas desenvolvedores e usuários de software acadêmico.

\item{\bf Foco de qualidade.}
O principal aspecto de qualidade estudado é o número de mudanças no código fonte durante o ciclo de vida.
%evolvability and code churn.

\item{\bf Contexto.}
O estudo foi conduzido com um subconjunto dos projetos de software acadêmico de análise estática
publicados nas conferências ASE e SCAM, e avaliados como sustentáveis.
\end{description}


\subsection{Sumário da Definição}

Analisar os \textit{projetos de software acadêmico}
com o propósito de \textit{caracterizar}  % purpose  % era medir e avaliar - coloquei 'caracterizar'
com respeito a \textit{número de mudanças no código fonte}  % quality focus
na perspectiva de \textit{cientistas desenvolvedores de software}% perspective
no contexto de \textit{projetos de software de análise estática publicado nas conferências ASE e SCAM}.

\subsection{Questões de Pesquisa}

Neste estudo as seguintes questões de pesquisa, a respeito dos projetos de
software acadêmico de análise estática, serão investigadas:

\newcommand{\EstudoTresQuestaoUm}{
  Em qual estágio de evolução estão os projetos de software acadêmico de análise
  estática dentro do seu ciclo de vida?
}

\begin{description}
  \item Q1: \EstudoTresQuestaoUm

  \item qqq
\end{description}


\subsection{Métricas}

Para responder às questões de pesquisas, as seguintes métricas serão usadas:

\begin{enumerate}
  \item Número de lançamentos/releases/versões dos projetos de software acadêmico de análise estática.
  \item Número de arquivos e módulos dos projetos de software acadêmico de análise estática ao longo das versões.
%  \item Número de autores com publicações mencionando os projetos de software acadêmico de análise estática.
%  \item Número contribuidores no repositório de código fonte dos projetos de software acadêmico de análise estática.
%Ao final, coletamos também algumas métricas do software em relação ao seu
%ecossistema de software e em relação a sua qualidade interna: número
%total de lançamentos, data e número de versão de cada lançamento, número de
%commits e a complexidade estrutural do código fonte.
\end{enumerate}

% }}}

\section{Planejamento do Estudo} \label{estudo3:planejamento}

O estudo foi organizado em duas grandes fases, primeiro caracterizamos os
projetos sem disponibilidade de download, ou seja, os projetos indisponíveis e
sem presença oficial online como projetos com ciclo de vida encerrados a partir
do modelo {\it ``Staged Model for Software Evolution''}, estes projetos serão
caracterizados como estando na fase {\it ``Close-down''}.

Em seguida entre os demais projetos, selecionamos apenas os projetos com
disponibilidade de código fonte para uma análise evolutiva coletando o número
de lançamentos (versões ou releases) realizado para cada projeto, para cada
lançamento será obtido o código fonte e será extraído métricas representando o
número de módulos para avaliação histórica. Os projetos sem disponibilidade de
download não serão caracterizados quanto ao seu ciclo de vida uma vez que os
indícios para realizar este estudo está centrado na disponibilidade de código
fonte.

As informações sobre lançamentos foram coletadas manualmente em arquivos de
changelog, no site do projeto, ou em tags no próprio repositório de código
fonter. O número de commits foi coletado com o uso do git via linha de comando,
o cálculo e coleta da métrica de complexidade estrutural do código fonte foi
coletada com software de análise estática Analizo.

Analizo é software livre, distribuído sob a licença GNU General Public License
versão 3. Seu código-fonte, bem como pacotes binários, manuais e tutoriais
podem ser obtidos em \url{http://www.analizo.org}. Todas as ferramentas são
auto-documentadas e podem ser consultadas como páginas de manual UNIX. 
Analizo é escrito em Perl, sua última versão 1.19.1 lançada em 01 de Setembro de 2016
foi a versão utilizada neste estudo.

\section{Preparação} \label{estudo3:preparacao}

Analisar apenas os projetos com código fonte suportado pelo Analizo (C, C++ e Java),
Derailer é Ruby, Flowgen é Python, PHP AiR é Rascal, protopurity é Javascript,
Pseudogen é Python, TEBA é Perl, Wrangler é Erlang,
o e-munity e mygcc são basicamente o código do GCC, n faz sentido coletar métricas para ele.

Analisar historicamente (evolucao) dos projetos com maior número de releases (com codigo dessas releases)
e que já tenha coletado as metricas (ja coletei varias versoes de alguns projetos), a analise
individual

Para os outros projetos, com código fonte disponível, copiamos localmente o código fonte
e executamos o analizo metrics para coletar a métrica de complexidade estrutural, tamanho em
linhas de código e número de classes.

Para cada ferramenta de análise estática selecionada, coletamos  suas métricas de código-fonte
com suporte da ferramenta {\it analizo metrics}. 
Esta coleta foi automatizada pelo script {\it
analyze-all-projects}\footnote{http://github.com/joenio/dissertacao-ufba-2016/blob/master/dataset/analyze-all-projects}
escrito durante este estudo e  disponível no
repositório\footnote{http://github.com/joenio/dissertacao-ufba-2016} desta
pesquisa.

os \SoftwareCount \ projetos de software acadêmico de análise estática
em relação a 

\subsection{Execução}

\section{Coleta de Dados} \label{estudo3:coleta}

Os dados coletados incluem a caracterização das ferramentas de análise
estática, bem como, os valores das métricas de código-fonte de complexidade
estrutural para cada ferramenta.

Todos os dados foram agregados numa planilha.

\section{Análise dos Dados} \label{estudo3:analise}

(pendente)

A Figura \ref{releases-vs-mentions} apresenta em conjunto o número de releases total
de cada projeto em relação ao número total de menções encontradas nas bases ACM e IEEE,
os projetos sem informação de releases foi excluído do gráfico.

\begin{figure}[h]
  \center
  \includegraphics[scale=0.6]{imagens/releases-vs-mentions.png}
  \caption{Gráfico com número total de releases e número total de menções de cada projeto.}
  \label{releases-vs-mentions}
\end{figure}


\section{Interpretação dos Resultados} \label{estudo3:interpretacao}

\subsection{Q1 - \EstudoDoisQuestaoUm}

(pendente)

\section{Ameaças à validade}

(pendente)

\section{Conclusões} \label{estudo3:conclusoes}

(pendente)



%% O percentil 75 tem muitos valores zero, os percentis 90 e 95 sao pracitamente iguais 
%% na comparacao, os maiores sao geralmente tb maior no outro, exceto uns 2 exemplos:
%% smatch-0.3/EJB e pmd-src-5.3.7/wap-2.1.

%Os valores encontrados serão avaliados sempre tendo em vista os intervalos
%sugeridos na Tabela \ref{valores-frequentes}, esta tabela traz os valores encontrados
%no estudo que estamos replicando em parte \cite{Meirelles2013}.

%\begin{table}[H]
%  \caption{Valores frequentes\cite{Meirelles2013}}
%  \centering
%  \begin{tabular}{| c | l | l | l | l | l |}
%    \hline
%    Métrica           & Linguagem & Muito frequente & Frequente & Pouco frequente & Não frequente \\
%    \hline
%\multirow{3}{*}{CBO}   & C         & 0 -- 5,0   & 6,0 -- 9,0   & 9,0 -- 12,0  & $>$ 12,0  \\
%                       & C++       & 0 -- 3,0   & 4,0 -- 5,0   & 6,0 -- 7,0   & $>$ 7,0   \\
%                       & Java      & 0 -- 3,0   & 4,0 -- 6,0   & 7,0 -- 9,0   & $>$ 9,0   \\
%    \hline
%\multirow{3}{*}{LCOM4} & C         & 0 -- 5,0   & 6,0 -- 12,0  & 12,0 -- 20,0 & $>$ 20,0  \\
%                       & C++       & 0 -- 5,0   & 6,0 -- 10,0  & 10,0 -- 14,0 & $>$ 14,0  \\
%                       & Java      & 0 -- 3,0   & 4,0 -- 7,0   & 8,0 -- 12,0  & $>$ 12,0  \\
%    \hline
%\multirow{3}{*}{SC}    & C         & 0 -- 18,0  & 19,0 -- 77,0 & 78,0 -- 168,0 & $>$ 168,0 \\
%                       & C++       & 0 -- 12,0  & 13,0 -- 28,0 & 29,0 -- 51,0  & $>$ 51,0  \\
%                       & Java      & 0 -- 6,0   & 7,0 -- 21,0  & 22,0 -- 45,0  & $>$ 45,0  \\
%    \hline
%  \end{tabular}
%  \label{valores-frequentes}
%\end{table}

%\section{Design}

%No entando é conhecido que alguns fatores inflenciam o valor de algumas métricas,
%para evitar tais influências iremos isolar estes fatores realizando comparações
%entre ferramentas com os mesmos fatores, por exemplo, comparação entre linguagens diferentes,
%domínio de aplicação diferentes, tamanho em número de classes.

%Para garantir o princípio de ``randomization'' irei comparar com o maior número
%de características das ferramentas possíveis.
%Para garantir o princípio de ``balancing'' selecionei o mesmo número de
%releases das ferramentas que serão analisadas longitudemente.

%A investigação será realizada a partir de uma busca e seleção de ferramentas de
%análise estática, em seguida para cada ferramenta selecionada iremos obter
%o código-fonte da ferramenta, com código-fonte em mão iremos calcular métricas
%de complexidade estrutural e custo de mudança, em paralelo as características
%dessas ferramentas serão documentadas, neste ponto a análise e interpretação
%dos dados se iniciará, o objetivo será compreender quais características
%implicam na manutenabilidade.

% * fugir de valores de referencia
% * mostrar graficos com evolucao de SC de cada grupo/ferramenta
% * discutir essa evolucao em cada grupo/ferramenta, mostrando que aqui esta evoluindo pra melhor, aqui pra pior, etc
% * essas ferramentas fezem da fato o que o autor informa que faz? é válida? é possível validar isso de que forma?
%   verificar quais estudos tem validacao cientifica, ou seja, fazem estudo de caso? experimento? etc...?

% code churn: the rate of growth of the size of the software.
