\documentclass[qual, classic, a4paper]{ufbathesis}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage[alf]{abntex2cite}
\usepackage{graphicx}
%\usepackage{longtable}
\usepackage{multicol}
\DeclareGraphicsExtensions{.pdf}
\usepackage{caption}

\defenseyear{2016}
\date{08 de Julho de 2016}
\adviser[f]{Profa. Dra. Christina von Flach G. Chavez}
\coadviser{Prof. Dr. Paulo Roberto Miranda Meirelles}

\title{
  Caracterização da complexidade estrutural em ferramentas de análise estática
  de código-fonte
}

\author{Joenio Marques da Costa\\
  {\small joenio@joenio.me}
}

\begin{document}

\frontpage
\frontmatter
\presentationpage

\acknowledgements

(pendente)

\resumo

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\abstract

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\tableofcontents
\listoffigures
\listoftables

\mainmatter

%------------------------------------------%
\xchapter{Introdução}{}

%{\it Eu, como um desenvolvedor de ferramenta de análise estática de
%código-fonte, estou interessado em compreender a fundo este domínio de
%aplicação, suas técnicas e limitações, bem como compreender o estado da arte
%das ferramentas existentes na indústria e na academia, através da
%caracterização de seus atributos de qualidade interna, a fim de ter
%conhecimento suficiente para tomada de decisão sobre a evolução e manutenção
%da minha própria ferramenta de análise estática, a ser realizada durante este
%trabalho, com objetivo de melhorar seus atributos de qualidade interna.}

A tecnologia de análise estática tem se desenvolvido rapidamente, mas a
comparação e avaliação de técnicas e ferramentas não tem acompanhado tal
velocidade \cite{Li2010}, e, apesar de existirem estudos avaliando ferramentas
de análise estática de código-fonte, não foram encontrados
estudos avaliando tais ferramentas do ponto de vista de sua
qualidade interna.

Por exemplo, \citeonline{Rutar2004} compara cinco ferramentas de localização de bugs para Java e
discute as técnicas utilizadas por cada uma e seu impacto nos resultados.
\citeonline{Kratkiewicz2005} avalia cinco ferramentas de análise estática para
determinar seus pontos fortes e fracos em detecção de falhas de buffer
overflow em código C. \citeonline{Okun2007} avalia os efeitos de ferramentas de
segurança com objetivo de identificar se estas ferramentas melhoram de fato a
segurança de programas. \citeonline{Emanuelsson2008} avalia três ferramentas de
análise estática da indústria com o objetivo de mapear funcionalidades
significas destas ferramentas, normalmente não fornecidas por compiladores
normais. \citeonline{Wedyan2009} avaliou três ferramentas sobre a efetividade de
detectar falhas e predizer refatorações. \citeonline{Mantere2009} compara três
ferramentas da análise estática de código-fonte em relação à performance e dá
subsídios para apoiar tomada de decisão sobre seleção de ferramentas de
análise estática. \citeonline{Al2010} avalia quatro ferramentas de análise estática
em relação à capacidade de detectar bugs em programas concorrentes em Java e
response se ferramenta comerciais são melhores do que ferramentas {\it open
source}. \citeonline{Li2010} compara sete diferentes ferramentas de análise estática
com foco em detecção de vulnerabilidades, comparando suas caracteristicas
através de um experimento. \citeonline{Johns2011} avaliou a qualidade de ferramentas
de análise estática de segurança a partir de uma série de critérios.
\citeonline{Alemerien2013} avalia duas ferramentas de análise estática para cálculo
de métricas com objetivo de entender as diferenças nos resultados de cada uma.
\citeonline{Ataide2014} analisa os resultados gerados por três ferramentas de
análise estática que podem ser efecientemente usadas por programadores para
remover vulnerabilidades comuns em programas.

Desta forma estudar tais ferramentas a fim de compreender seus atributos de
qualidade interna e entender quais características arquiteturais explicam tais
atributos é de fundamental importância do ponto de vista de desenvolvedor
interessado em manter e evoluir ferramentas deste domínio de aplicação sem
afetar negativamente seus atributos de qualidade interna.

\section{Objetivos}

O objetivo principal deste trabalho é compreender as ferramentas de software
para análise estática de código-fonte, do ponto de vista de sua
manutenabilidade, a partir da análise de sua complexidade estrutural,
discutindo quais características arquiteturais explicam seus atributos de
qualidade interna.


Objetivos específicos:

\begin{itemize}
  \item Realizar uma revisão da literatura para conceituar análise estática de
    código-fonte.
  \item Selecionar e obter código-fonte de ferramentas de análise estática 
  desenvolvidas na academia, para coletar suas métricas de código-fonte. 
  A seleção terá como base o resultado de uma revisão estruturada feita 
  a partir de artigos publicados em conferências relacionadas. 
  \item Selecionar e obter o código-fonte de ferramentas de análise estática
    desenvolvidas pela indústria, para coletar suas métricas de
    código-fonte.
  \item Propor intervalos de referência para a observação parametrizada da
    qualidade interna das ferramentas de análise estática, a partir de suas
    métricas de código-fonte.
  \item Calcular a distância Euclidiana entre valores de referência e os valores
    das ferramentas estudadas.
  \item Aplicar a abordagem em um estudo para avaliação de uma ferramenta de análise de código-fonte.
\end{itemize}

\section{Hipóteses}

Para guiar os estudos, conforme os objetivos acima, definimos as seguintes
hipóteses:

\begin{enumerate}
  \item[{\bf H1:}] {\em É possível calcular valores de referência de métricas
    de código-fonte para ferramentas de análise estática a partir de um
    conjunto de softwares da academia e da indústria}
  \item[{\bf H2:}] {\em Ferramentas de análise estática tendem a ter uma
    maior complexidade estrutural do que ferramentas de outros domínios de
    aplicação}
  \item[{\bf H3:}] {\em Dentre as ferramentas de análise estática de
    código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
    complexidade estrutural}
\end{enumerate}

A Seção \ref{hipoteses} traz detalhes de como cada hipótese será validada.

Questões de pesquisa:
\begin{itemize}
\item O que?
\item Como?

\end{itemize}

\section{Contribuições esperadas}

Ao final deste trabalho, as seguintes
contribuições científicas ({\bf CC}) e tecnológicas ({\bf CT}) 
são esperadas:

\begin{enumerate}
  \item [{\bf CC1:}] Um conjunto de intervalos de referência da frequência dos
    valores de métricas de código-fonte para o domínio de ferramentas de
    análise estática.
  \item [{\bf CC2:}] Explicação da alta complexidade estrutural em ferramentas de
    análise de código-fonte.
  \item [{\bf CT1:}] Evolução de uma ferramenta de análise de código-fonte.
\end{enumerate}

%Lembrar que:
%Neste trabalho, são utilizadas métricas de produto, especificamente,
%métricas de código-fonte, que cobrem aspectos
%de tamanho, complexidade e qualidade, que podem ser medidos a partir 
%do código-fonte de um software, ao longo de sua evolução no tempo.

\section{Estrutura do texto} 

O capítulo \ref{fundamentacao} apresenta conceitos sobre análise estática e
métricas de código-fonte necessários para compreensão do trabalho. O capítulo
\ref{metodologia} apresenta trabalhos relacionados, as hipóteses do estudo e
apresenta o planejamento sobre a coleta e análise dos dados a serem realizados
durante este trabalho, por fim o cronograma. O capítulo \ref{conclusoes} traz
discussão e interpretação dos dados coletados e apresenta os próximos passos
do estudo.

%-----------------------------------------------------%
\xchapter{Fundamentação Teórica}
{Este capítulo apresenta conceitos necessários para a compreensão do trabalho.}
\label{fundamentacao}

A análise estática de código é o primeiro passo para coletar informações
necessárias para diversas atividades de verificação, medição e melhoria da
qualidade de produtos de software \cite{Cruz2009} \cite{Kirkov2010}.

A análise estática de código é realizada com base apenas no código-fonte de um
programa ou sistema de software, para descobrir problemas e propriedades de
sua qualidade estrutural \cite{Chess2007}.

Ferramentas de análise estática estão disponíveis há decadas, em especial,
para programadores. A ferramenta Lint \cite{Johnson1978}, considerada a
primeira ferramenta de análise estática \cite{Gosain2015}, foi criada para
examinar programas escritos em linguagem C e aplicar regras de tipagem mais
estritas do que as regras dos próprios compiladores da linguagem.

% \cite{Li2010} cita FlexeLint como a primeira ferramenta de análise estática

Neste trabalho o nosso interesse reside em compreender características de
qualidade interna de ferramentas de análise estática de código-fonte do ponto
de vista do desenvolvedor interessado em manter e evoluir tais ferramentas
melhorando seus atributos de qualidade interna.

A seção \ref{sec:analise} apresenta a definição de análise estática de
código-fonte, suas principais aplicações (\ref{usos}), anatomia das
ferramentas análise de código-fonte (\ref{anatomia}), os formatos de
representação interna e técnicas mais comuns da análise (\ref{formatos} e
\ref{tecnicas}).

A seção \ref{metricas} traz definição de métricas de software, uma lista de
métricas utilizadas neste estudo (\ref{metricas-de-codigo}) e um detalhamento
sobre métricas utilizadas para calcular complexidade estrutural
(\ref{complexidade}) (pendente capitulo sobre estatistica).

\section{Análise estática de código-fonte} \label{sec:analise}

Análise estática de código-fonte é um ramo da engenharia de software voltado a
obter informações acerca de um programa a partir do seu código-fonte sem
necessidade de execução, e sem requerer qualquer outro artefato do programa
além do próprio código.

Possui muitas das suas abordagens em comum com os estudos da área de análise
de programa ({\it program analysis}), especialmente na área de compiladores,
sendo parte dos primeiros passos do processo de compilação. Um tema presente
em todas as abordagens da análise de programa e consequentemente da análise de
código-fonte e da análise estática de código-fonte é que elas podem fornecer
apenas resultados aproximados \cite{Landi1992}.

A análise estática de código-fonte é considerada uma atividade meio com
objetivo de suportar uma variedade de tarefas comuns da engenharia de
software; muitas dessas tarefas são substancialmente úteis em atividades de
manutenção. \citeonline{Binkley2007} define uma extensa lista dessas
atividades, segue abaixo um sub-conjunto delas.

\begin{multicols}{2}
  \begin{itemize}
    \item Análise de performance
    \item Compreensão de programas
    \item Desenvolvimento baseado em modelos
    \item Detecção de clones
    \item Evolução de software
    \item Garantia de qualidade
    \item Localizaçao de falhas
    \item Manutenção de software
    \item Recuperação arquitetural
    \item Testes
  \end{itemize}
\end{multicols}

Seja em qual atividade for, a análise estática possui uma importância
significativa, pois ao ser capaz de extrair informações diretamente do
código-fonte de um programa, pode auxiliar a responder com precisão a seguinte
pergunta: ``O que é que este programa significa?''

\subsection{Usos da análise estática de código-fonte} \label{usos}

A análise de programas trata, de modo geral, da descoberta de problemas e
fatos sobre programas.  Tal análise por ser realizada sem necessidade de
executar o programa (análise estática) ou com informações provenientes de sua
execução (análise dinâmica).

A idéia de que programas de computador podem ser utilizados para analisar
código-fonte de outros programas tem uma história de mais de 40 anos.  O
programa PFORT \cite{Ryder1974} foi projetado para localizar potenciais
problemas na portabilidade de código Fortran; em função da diversidade de
dialetos de Fortran, uma compilação sem erros não indicava que o programa
estava correto segundo os padrões da linguagem \cite{Wichmann1995}.

Desde então, ferramentas de análise estática de código-fonte têm surgido para
os mais diversos fins -- muitas delas a partir das pesquisas e
desenvolvimentos da área de compiladores.  O {\it parser} utilizado nessas
ferramentas têm funcionalidades análogas aos analisadores usados em
compiladores \cite{Anderson2008}.

O uso de ferramentas de análise estática de código-fonte têm 
se tornado mais e mais comum no ciclo de desenvolvimento de software.
O campo de aplicação destas ferramentas é bastante variado, 
cobrindo diferentes objetivos. Dentre as atividades em que a análise
estática de código-fonte é usada \cite{Chess2007}, destacam-se:

\begin{description}

  \item \textit{Verificação de tipos}. 
    A forma mais amplamente utilizada de análise estática, e uma das quais os
    programadores estão mais familiarizados, é a checagem de tipo.
    Programadores dão pouca atenção a isto, visto que as regras são definidas
    pela linguagem de programação e executadas pelo próprio compilador, de
    forma que não se torna necessário entender como a análise acontece.  No
    entando, esta atividade de verificação é análise estática e elimina toda
    uma categoria de erros de programaçao. Por exemplo, previne que
    programadores acidentalmente atribuam valores de forma incorreta a
    variáveis.  Ainda, ao capturar erros em tempo de compilação, esta checagem
    de tipo previne erros em tempo de execução.

  \item \textit{Verificação de estilo}. 
    Os verificadores de estilo são um tipo de análise estática que aplicam regras
    de forma mais superficial do que os verificadores de tipo. São regras
    relacionadas a espaços em branco, nomes, funções depreciadas, comentários,
    estrutura do programa, entre outros.  A maioria dos verificadores de
    estilo costumam ser bem flexíveis quanto ao conjunto de regras que aplicam
    uma vez que os programadores costumam ser bastante apegados aos seus
    próprios estilos de programação. Os erros reportados por verificadores de
    estilo são aqueles que afetam a leitura e a manutenabilidade do
    código-fonte, não indicando potenciais erros em tempo de execução como
    fariam os verificadores de tipo.

  \item \textit{Compreensão de programas}. 
    Ferramentas de compreensão de programa ajudam programadores a terem uma visão
    clara frente a grandes programas de computador, ou seja, programas com
    alto volume de código-fonte. Ambientes de desenvolvimento integrados (IDE)
    geralmente incluem funcionalidade de compreensão, por exemplo, ``encontrar
    todos os usos de um certo método'' ou ``encontrar a declaração de uma
    variável global''. Análises mais avançadas chegam a incluir, por exemplo,
    refatoração automática. Estas ferramentas de compreensão também são úteis
    para programadores interessados em entender código-fonte escrito por
    outros programadores.

  \item \textit{Verificação programas}. 
    Ferramentas de verificação de programa aceitam como entrada uma especificação
    e um conjunto de código-fonte e tenta provar que o código está deacordo
    com a especificação. Quando a especificação é uma descrição completa de
    todo o programa, a ferramenta de verificação poderá realizar uma checagem
    de equivalência para garantir que o código-fonte e a especificação
    combinam de forma exata. Programadores raramente tem acesso a uma
    especificação detalhada suficientemente para ser usada numa checagem de
    equivalência, o trabalho de criar esta especificação pode ser maior do que
    o trabalho de escrever o próprio código-fonte do programa, desta forma
    este tipo de verificação formal raramente acontece. Sendo mais comum a
    verificação em relação a uma especificação parcial que detalha apenas
    parte do comportamento do programa.  Isto costuma ser chamado de
    verificação de propriedade, grande parte das ferramentas de verificação de
    propriedade funcionam aplicando inferências lógicas ou verificação de
    modelos.

  \item \textit{Localização de bugs}. 
    O propósito de uma ferramenta de localização de bugs não está em questões de
    formatação, como é a verificação de estilo, nem em realizar uma exaustiva
    e completa comparação contra uma especificação, como uma ferramenta de
    verificacao de programa. Ao invés disso, um localizador de bugs está
    preocupado em apontar locais onde o programa, possivelmente, irá se
    comportar de forma inesperada. A maioria das ferramentas de localização de
    bugs são fáceis de usar porque costumam vir com um conjunto de regras (bug
    idioms) para descrição de padrões de código que indicam bugs. Algumas
    destas ferramentas costumam usar os mesmos algoritmos utilizados por
    ferramentas de verificação de propriedade.

  \item \textit{Avaliação de segurança}. 
    Ferramentas de análise estática para segurança usam as mesmas técnicas
    encontradas nas outras ferramentas, mas por ter um propósito diferente,
    identificar problemas de segurança, aplicam estas técnicas de forma diferente.
    As primeiras ferramentas de segurança (ITS4, RATS, Flawfinder) eram pouco mais
    do que um ``grep'' melhorado; na maior parte, elas escaneavam o codigo
    procurando por funções como por exemplo ``strcpy()'' que são facilmente usadas
    de forma inadequada e devem ser inspecionadas manualmente no processo de
    revisão de código-fonte. A evolução deste tipo de ferramenta de segurança
    levou a técnicas híbridas de verificação de propriedade e de localização de
    bugs, de forma que muitas propriedades de segurança podem ser suscintamente
    expressas como propriedades de programas.

\end{description}

\subsection{Anatomia da análise de código-fonte} \label{anatomia}

Ferramentas de análise estática de código-fonte estão organizadas em partes ou
componentes, responsáveis por implementar três funções básicas \cite{Cruz2009}
\cite{Binkley2007}: a) extração de dados, b) geração de representação interna,
e c) análise. A ferramenta de análise de código-fonte
CodeSonar\footnote{https://www.grammatech.com/products/codesonar} segue tal
organização, conforme mostra a Figura \ref{static-analysis-representation}.

\begin{figure}[h]
  \center
  \includegraphics[scale=0.4]{imagens/static-analysis-representation.png}
  \caption{CodeSonar: Representação da Análise Estática \cite{GrammaTech2016}}
  \label{static-analysis-representation}
\end{figure}

\begin{description}

  \item \textit{Extração de dados}.
    O processo de recuperar dados para futuro processamento ou armazenamento é
    chamado de extração de dados. 

    O primeiro componente da análise de código-fonte é a extração de dados,
    responsável por ler o código-fonte do programa e gerar uma ou mais
    representações internas. Em essência, este componente converte a sintaxe
    de um programa em uma outra sintaxe abstrata e mais adequada para análise
    posterior. Este componente é usualmente chamado de analisador sintático
    (ou {\it parser}) e apesar de teoricamente não ser uma tarefa difícil,
    apresenta enormes desafios diante da complexidade das linguagens de
    programação modernas.

  \item \textit{Representação interna}.
    Exportar os dados extraídos para uma representação intermediária é uma
    estratégia comum para facilitar análise e transformação de dados e
    possivelmente adição de metadados.

    Os dados obtidos na extração precisam ser representados em um formato mais
    abstrato. Esta é a responsabilidade do segundo componente da análise de
    código-fonte: armazenar os dados coletados usando uma representação
    interna em formato mais adequado para análise automática, abstraindo
    aspectos particulares do programa e da linguagem de programação.

    Alguns tipos de representação interna têm sua origem na área de
    compiladores; algumas delas são produzidas diretamente pelo {\it parser}
    enquanto outras requerem uma análise específica.  Os formatos mais comuns
    são baseados em grafos. 

    Alguns formatos comumente utilizados são:
    \begin{multicols}{2}
      \begin{itemize}
        \item Árvore sintática abstrata
        \item Grafo de fluxo de controle
        \item Árvore sintática abstrata decorada
        \item Grafo de dependência de módulos
        \item Atribuição estática única
        \item Grafo de dependência de valores
      \end{itemize}
    \end{multicols}

    Estas representações podem ser utilizadas tanto na análise estática quanto
    na análise dinâmica. O uso de um ou outro formato depende do tipo de
    análise e seu propósito. Pode-se combinar diferentes tipos no sentido de
    enriquecer e estruturar a informação extraída.

  \item \textit{Análise}.
    Este componente é responsável por realizar inferências a partir dos dados
    representados internamente. O processo requer que as informações
    armazenadas estejam interconectadas e também interrelacionadas com
    conhecimento anterior. Esta análise pode gerar conhecimento quantitativo
    ou qualitativo, como, por exemplo, métricas de software ou mineração de
    dados, respectivamente. Técnicas de visualização podem ser usadas para
    apoiar este processo.

    Diversas técnicas foram desenvolvidas ao longo do tempo para realizar
    análise, algumas serão brevemente descritas na seção \ref{tecnicas}.

%A análise pode ser categorizada segundo seis dimensões básicas: 
%\begin{itemize}
%\item estática versus dinâmica, 
%\item sound versus unsound, 
%\item segura vesus insegura, 
%\item sensível ao fluxo (``which values a variable may have at each program point?'')
%versus insensível ao fluxo (which variables can be accessed by a code?''),
%\item sensível ao contexto (``different solutions are computed for different chains of callers'') versus 
%insensível ao contexto (``a single solution is computed for each function, no matter who calls the function''),\item complexidade. %precision vs effort
%\end{itemize} 
%Estas características da análise vão afetar o resultado gerado quanto a
%confiabiliade, completude, garantia de precisão, eficiência, performance,
%complexidade computacional, precisão da informaçao, entre outras.

\end{description}

\subsection{Formatos de representação interna} \label{formatos}

Essencialmente, um formato de representação interna é uma abstração precisa
das propriedades de um programa representado em um domínio menor. Os
compiladores normalmente constroem esta representação a fim de possuir um
modelo do programa sendo compilado, é comum que compiladores utilizem diversos
formatos durante o curso da compilação.

Em ferramentas de análise estática estes formatos são utilizados durante a
fase de análise para cumprir diversos objetivos, por exemplo, para calcular
métricas de código-fonte. A métrica de complexidade ciclomática de McCabe
\cite{McCabe1976} é definida com base no grafo de fluxo de controle (CFG) do
programa com o seguinte cálculo:

\begin{equation}
  CC = e - n + 2p
\end{equation}

Onde:
{\bf e} é o número de arestas;
{\bf n} é o número de nós; e
{\bf p} é o número de componentes fortemente conectados no grafo CFG.

%Observação (Chris):
%Algumas dessas RIs são necessárias para calcular alguns tipos de métricas.
%Às vezes há alguns workarounds em ferramentas, em
%geral, dependentes de linguagem.
%
%Mas algumas ferramentas implementam a métrica de outra forma.
%\begin{verbatim}
%NDepend:
%
%CC = 1 + {number of the following expressions found in a method} :
%if|while|for|foreach|case|default|continue|goto|&&| etc.
%
%\end{verbatim}

Assim, percebe-se que cada formato de representação interna \cite{Nielson2015}
\cite{Stanier2013} \cite{Cruz2009} \cite{Ramalho1996} pode ter fins e
objetivos bastante distintos, entre os formatos mais comuns podemos destacar:

\begin{description}

  \item \textit{Árvore sintática abstrata}.
    A árvore sintática abstrata (AST - Abstract Syntax Tree) reprenta um
    programa tratando os elementos do código-fonte como operadores e
    operandos organizados em nós numa árvore, este formato de representação é
    muito popular em tradutores {\it source-to-source}.

  \item \textit{Grafo de fluxo de controle}.
    O grafo de fluxo de controle (CFG - Control Flow Graph ou Call Graph) é um grafo direcionado
    representando a estrutura de controle de um programa e sua sequência de
    instruções, as arestas mostram os possíveis caminhos de execução. Este
    formato é amplamente utilizado em métodos formais para otimização de
    código-fonte.

  \item \textit{Grafo de fluxo de dados}.
    O grafo de fluxo de dados (DFG - Data Flow Graph) é também um grafo
    direcionado onde as arestas representam o fluxo de dados entre as
    operações do programa, este formato pode ser visto como um companheiro do
    grafo de fluxo de controle (CFG) e pode ser gerado ao longo de uma mesma
    análise.

  \item \textit{Árvore sintática abstrata decorada}.
    Árvore sintática abstrata decorada (DAST - Decorated Abstract Syntax Tree) é
    uma árvore sintática abstrata (AST) melhorada através de um processo de
    definiçao de atributos para os símbolos do programa de forma declarativa
    com uso de uma Gramática de
    Atributos\footnote{http://pt.wikipedia.org/wiki/Gramática\_de\_atributos}.

  \item \textit{Grafo de dependência de módulos}.
    O grafo de dependência de módulos (MDG - Module Dependence Graph) é um grafo
    onde os módulos são representados como nós e as arestas representam as
    relacões entre eles, indicando dependência entre os mesmos.

  \item \textit{Atribuição estática única}.
    Atribuição estática única (SSA - Static Single Assignment) pode ser vista
    como uma variação ou uma propriedade de outros formatos de representação
    interna, é um método que faz cada variável ser atribuída apenas uma única
    vez, facilitando a descoberta de informaçoes sobre os dados representados.

  \item \textit{Grafo de dependência de valores}.
    O grafo de dependência de valores (VDG - Value Dependence Graph) é uma
    variação que melhora (ao menos para algumas análises) os resultados
    obtidos a partir da atribuição estática única (SSA). Ele representa tanto
    o fluxo de controle quanto o fluxo de dados e assim simplifica a análise.

\end{description}

\subsection{Técnicas de análise} \label{tecnicas}

Inúmeras técnicas e métodos distintos podem ser utilizados pelas ferramentas
de análise estática, seja com o objetivo de verificação de tipos, localização
de bugs, compreensão de programas, avaliação de segurança, ou outra finalidade
qualquer. Segundo \citeonline{German2003}, \citeonline{Li2010},
\citeonline{Hofer2010} as técnicas e métodos mais comumente encontrados nas
ferramentas atuais são:

% análise de fluxo de dados, erros de runtime (divisão por zero, overflows, etc.), 
% análise de impacto, medições, identificação de \textit{code smells},  e reengenharia de software.

\begin{description}

  \item \textit{Análise léxica}.
    A análise léxica é responsável por quebrar o programa em pequenos fragmentos
    (ou {\it tokens}) e verificar se estes fragmentos são palavras válidas
    para uma dada linguagem. A análise léxica não leva em consideração a
    sintaxe do programa, sua semântica ou a interação entre módulos.

  \item \textit{Combinação de padrões de texto}.
    A combinação de padrões de texto ({\it Text-based Pattern Matching}) é a
    maneira mais simples e rápida de procurar vulnerabilidades num código
    fonte.

  \item \textit{Inferência de tipos}.
    A inferência de tipos ({\it Type inference}) refere-se a identificar o tipo
    de variáveis e funções através e avaliar se o acesso a elas está em
    conformidade com as regras da linguagem. Linguagens de programação com
    sistema de tipagem incluem mecanismos este tipo de análise.

  \item \textit{Análise de fluxo de dados}.
    A análise de fluxo de dados ({\it Data flow analysis}) resume-se a coletar
    informação semântica do código-fonte do programa, e com métodos algébricos
    deduzir a definição e uso das variáveis em tempo de compilação. O objetivo
    é mostrar que nenhum caminho de execução no programa acessa uma variável
    sem definição prévia e atribuição de valor.

  \item \textit{Verificação de regra}.
    A verificação de regra ({\it Rule checking}) consiste em checar a segurança
    do programa usando um conjunto de regras pré-estabelecidas.

  \item \textit{Análise de restrição}.
    A análise de restrição ({\it Constraint analysis}) é consiste em gerar
    e resolver restrições no processo de análise de um programa.

  \item \textit{Comparação caminho}.
    Comparação caminho ({\it Patch comparison}) inclui comparação de caminho de
    código-fonte e de código-binário e é usada principalmente para encontrar
    brechas de vulnerabilidade ``conhecidas''.

  \item \textit{Execução simbólica}.
    A execução simbólica ({\it Symbolic execution}) é usada para representar as
    entradas de um programa através do uso de valores simbólicos ao invés de
    dados reais, produz expressões algébricas sobre a entrada dos símbolos no
    processo de implementação e pode detectar possibilidade de erros.

  \item \textit{Interpretação abstrata}.
    Interpretação abstrata ({\it Abstract interpretation}) é uma descrição
    formal da análise do programa. Pelo fato de apenas controlar atributos de
    programa de preocupaçao dos usuários, a interpretação da análise semântica
    é similar ao seu significado semantico real.

  \item \textit{Prova de teoremas}.
    Prova de teoremas ({\it Theorem proving}) é baseada na análise semântica do
    programa, converte o programa em fórmulas lógicas e então tenta provar que
    o programa é um teorema válido usando regras e axiomas.

  \item \textit{Verificação de modelo}.
    O processo de verificaçao de modelos ({\it Model checking}) primeiro contrói
    um modelo formal do programa tal como uma máquina de estados ou um grafo
    direcionado, então examina e compara o modelo para verificar se o sistema
    cumpre as características pré-definidas. Esta técnica requer a definição e
    descrição das propriedades que devem ser verificados por um pedaço de
    software.

  \item \textit{Verificacao formal}.
    Verificação formal ({\it Formal Checking} ou {\it Compliance Analysis}) é o
    processo de provar de forma automatizada que o código do programa está
    correto em relação a uma especificação formal dos seus requisitos.

  \item \textit{Análise de fluxo da informação}.
    Análise de fluxo da informação ({\it Information Flow Analysis}) identifica
    como a execução de uma unidade de código cria dependência entre entradas e
    saídas.

  \item \textit{Verificação de sintaxe}.
    Verificação de sintaxe ({\it Syntax Checks}) tem o objetivo de encontrar
    regras de violação tais como a utilização de uma variável do tipo incorreto
    ou sem declaração.

  \item \textit{Verificação de intervalo}.
    A análise de verificação de intervalo ({\it Range Checking}) tem o objetivo
    de verificar que os valores dos dados permanecem dentro de intervalos
    especificados, bem como manter a precisão especificada.

\end{description}

%--------------------------------------%
\section{Métricas de software} \label{metricas}

No glossário de terminologia para engenharia de software do IEEE
\cite{ieee1990ieee}, a qualidade de software é definida como (1) o grau em que
um sistema, componente ou processo atende a requisitos especificados e (2) o
grau em que um sistema, componente ou processo atende às necessidades ou
expectativas de um usuário. 

Segundo o padrão para metodologia de qualidade de métricas de software do IEEE
\cite{software1998ieee}, uma métrica de qualidade de software é ``uma função
cujas entradas são dados de software e cuja saída é um valor numérico, que
pode ser interpretado como o grau em que um software'' ( .. sistema,
componente ou processo ... ) ``possui um determinado atributo que afeta sua
qualidade''.

%Metrics make a statement about some quality attributes, are quantitative, 
%but will have to be interpreted by a human.

Métricas de software podem ser classificadas em
métricas de processo, métricas de projeto e métricas de produto.

Métricas de processo medem atributos relacionados ao ciclo de desenvolvimento
e manutenção de software.  Métricas de projeto indicam se a execução do
processo está progredindo conforme planejado (por exemplo, relação entre o
tamanho do software entregue e o esfoço total dispendido em seu
desenvolvimento).

Métricas de produto medem atributos de produtos e artefatos (documentos,
diagramas, código-fonte e arquivos binários) desenvolvidos. Neste trabalho,
apenas métricas de produto serão utilizadas.

Métricas de produto podem ser classificadas em internas (medem propriedades
visíveis apenas aos desenvolvedores) ou externas (medem propriedades visíveis
aos usuários) \cite{Mohamed1994}.

Neste trabalho, são utilizadas métricas de produto e, especificamente,
métricas de código-fonte, que cobrem aspectos de tamanho, complexidade e
qualidade que podem ser medidos a partir do código-fonte de um software.

%, ao longo de sua evolução no tempo.

\subsection{Métricas de código-fonte} \label{metricas-de-codigo}

As propriedades visíveis aos desenvolvedores podem ser medidas através de
métricas de código-fonte. A observação e o monitoramento de seus valores podem
indicar aspectos relevantes à manutenibilidade de um programa. Dentre as
inúmeras métricas de código-fonte iremos destacar aquelas utilizadas no estudo
de \citeonline{Meirelles2013} onde associou-se características de qualidade de
produto de software a características de qualidade de código-fonte através da
observação de suas métricas.

\begin{itemize}
  \item {\bf ACC} {\it Aferent Connections per Class (Conexões aferentes de
    uma classe)}: Mede a conectividade de uma classe \cite{Brito1994}.
  \item {\bf ACCM} {\it Average Cyclomatic Complexity per Method (Média de
    complexidade ciclomática por método)}: mede a complexidade do programa
    \cite{McCabe1976}.
  \item {\bf AMLOC} {\it Average Method LOC (Média do número de linhas de
    código por método)}: indica se o código está bem distribuído entre os
    métodos, quanto maior mais ``pesados'' são os métodos. [REF]
  \item {\bf ANPM} {\it Average Number of Parameters per Method (Média do
    Número de Parâmetros por Método)}: calcula a média de parâmetros dos
    métodos da classe \cite{Jagdish1997}.
  \item {\bf CBO} {\it Coupling Between Objects (Acoplamento entre objetos)}:
    mede o acoplamento entre objetos do software \cite{Chidamber1994}.
  \item {\bf DIT} {\it Depth of Inheritance Tree (Profundidade da árvore de
    herança)}: mede o número de ancestrais de uma classe \cite{Shih1997}.
  \item {\bf LCOM4} {\it Lack of Cohesion in Methods (Ausência de coesão em
    métodos)}: mede o grau de falta de coesão em métodos \cite{Hitz1995}.
  \item {\bf LOC} {\it Lines of Code (Número de linhas de código)}: mede o
    número de linhas excluindo linhas em branco e comentários. [REF]
  \item {\bf NOA} {\it Number of Attributes (Número de atributos)}: calcula o
    número de atributos de uma classe \cite{Kolewe1993}.
  \item {\bf NOC} {\it Number Of Children (Número de filhos)}: número total de
    filhos de uma classe \cite{Rosenberg1997}.
  \item {\bf NOM} {\it Number of Methods (Número de métodos)}: mede o tamanho
    das classes em termos das suas operações implementadas. [REF]
  \item {\bf NPA} {\it Number of Public Attributes (Número de atributos
    públicos)}: mede o encapsulamento. [REF]
  \item {\bf NPM} {\it Number of Public Methods (Número de métodos públicos)}:
    representa o tamanho da ``interface'' da classe. [REF]
  \item {\bf RFC} {\it Response For a Class (Resposta para uma classe)}:
    número de métodos dentre todos os métodos que podem ser invocados em
    resposta a uma mensagem enviada por um objeto de uma classe
    \cite{Sharble1993}.
  \item {\bf SC} {\it Structural Complexity (Complexidade estrutural)}: mede a
    complexidade do software \cite{Darcy2005}.
\end{itemize}

\subsection{Complexidade estrutural} \label{complexidade}

A complexidade estrutural (SC - Structural Complexity) de um programa
é uma medida calculada através da combinação das
métricas de acoplamento (CBO) e coesão (LCOM4).
Esta medida é, possivelmente, um indicativo de problemas 
na manutenibilidade de sistemas de software, em
especial sobre o esforço necessário para atividades de manutenção
\cite{Terceiro2012}. Ela está relacionada a como os módulos de um programa
estão organizados bem como à estrutura interna de cada módulo.

Esta métrica pode dar indícios importantes sobre características arquiteturais
de um programa de software, e pode explicar seus atributos de qualidade
interna.

\section{Pensar em título - fundamentos de matemática e estatística}

\subsection{Distância Euclidiana}
\subsection{etc}

%------------------------------------------------------%
\xchapter{Metodologia}{} \label{metodologia}

%Antes de falar dos trabalhos relacionados, deve-se ter uma introdução no
%capítulo de metodologia resgatando o problema tratado pelo trabalho e que tem
%estudos da área etc etc...

Seção~\ref{trabalhos-relacionados}

Seção~\ref{hipoteses}

Seção~\ref{planejamento}

Seção~\ref{coleta}

Seção~\ref{analise}

\section{Trabalhos relacionados} \label{trabalhos-relacionados}

\citeonline{Meirelles2013} apresenta argumentos para se observar a qualidade
do software através das métricas de código-fonte, associa qualidade do
software à qualidade do código. Afirma que uma maneira objetiva de se observar
as características de um código-fonte é analisando os valores de suas
métricas. Alerta para o pouco uso de métricas por parte dos desenvolvedores no
ciclo de desenvolvimento e indica como um dos motivos desta sub-utilização por
parte dos desenvolvedores é a falta de conhecimento de como coletar
automaticamente os valores das métricas, interpretar os seus resultados e os
associar à qualidade do código-fonte. Assim identifica valores para essas
métricas de forma a servirem de referência para projetos futuros. Analisa
estatística da correlação entre métricas além de definir um subconjunto
reduzido de métricas que podem ser monitoradas ao longo do tempo e ainda
oferecer uma boa visão do projeto.

\citeonline{Ronaldo2015} realiza um estudo para o monitoramento de métricas de
código fonte na API do sistema operacional Android, avalia sua evolução,
estuda as semelhanças da API com outros aplicativos do sistema Android.
Apresenta uma proposta de cálculo de similaridade entre aplicativos e a API
Android. Encontra valores de referências para métricas do sistema Android e
propõe um método de cálculo da distância entre aplicativos e os valores de
referência.

\citeonline{Almeida2010} realizam um estudo mapeando boas práticas de
programação em valores de métricas de código-fonte, estas boas práticas são
baseadas nos trabalhos de \cite{Martin2012} e \cite{Beck2007} sobre {\it Clean
Code}, onde sugerem práticas de desenvolvimento úteis para que um código
tenham expressividade, simplicidade e flexibilidade. Neste trabalho os autores
identificam melhorias de implementação através do uso de valores de métricas e
oferecem aos desenvolvedores uma maneira de pensarem em melhorias para os seus
códigos.

\section{Hipóteses} \label{hipoteses}

A hipótese {\bf H1} ({\em É possível calcular valores de referência de
métricas de código-fonte para ferramentas de análise estática a partir de um
conjunto de softwares da academia e da indústria}) será validada a partir da
análise das métricas calculadas para cada uma das ferramentas estudadas.  Esta
análise levará em consideração a caracterização das ferramentas
(Seção~\ref{caracterizacao-das-ferramentas}), em especial, um subconjunto das
ferramentas com melhores valores de métricas.

A hipótese {\bf H2} ({\em Ferramentas de análise estática tendem a ter uma
maior complexidade estrutural do que ferramentas de outros domínios de
aplicação}) será validada a partir da comparação com os trabalhos relacionados
(Seção \ref{trabalhos-relacionados}) que realizaram estudos similares, com
cálculo e distribuição de métricas, e utilizando conjunto ferramentas distinto
do estudado aqui.

A hipótese {\bf H3} ({\em Dentre as ferramentas de análise estática de
código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
complexidade estrutural}) será validada a partir do cálculo da distância das
métricas de cada ferramenta com os valores de referências encontrados neste
estudo (Seção \ref{distancia}).

\section{Planejamento do estudo} \label{planejamento}

%\subsection{Seleção de métricas}
%
%Estas métricas serão coletadas para cada classe/módulo presente nas
%ferramentas de análise estática selecionadas e servirão de base para
%avaliar a qualidade das mesmas.
%
%(pendente) ``retomar complexidade estrutural e linkar com trabalho de
%terceiro, iremos olhar com mais detalhes algumas ferramentas e para este
%subconjunto vamos analisar a organização arquitetural dos módulos, isto
%será base para o guia de refatoração que faremos.''

\subsection{Seleção de ferramentas de análise estática} \label{levantamento}

A seleção de ferramentas de análise estática será realizada 
por meio de uma busca por ferramentas desenvolvidas no contexto da
academia e da indústria, com base em critérios pré-definidos.
Será feito um planejamento detalhado para
realizar a seleção de ferramentas em cada um destes contextos.

No contexto acadêmico, a busca por ferramentas será feita
em artigos publicados em conferências que tenham histórico de
publicação sobre ferramentas de análise estática de código-fonte. 
Estes artigos serão analisados e aqueles com publicação de ferramenta
serão selecionados.

Na indústria, a busca por ferramentas será feita a partir da base mantida pelo
projeto SAMATE\footnote{http://samate.nist.gov} - {\em Software Assurance
Metrics and Tool Evaluation}, um projeto do NIST\footnote{http://nist.gov}
dedicado ao desenvolvimento de métodos que permitam avaliar e medir a
eficiência de ferramentas e técnicas sobre garantia de qualidade em software.
O site do projeto, disponível em \citeonline{SamateAnalysers}, mantém uma lista
de ferramentas de análise estática.

As ferramentas selecionadas serão avaliadas, com  extração de
seus atributos de qualidade interna a partir do cálculo de suas métricas de
código-fonte.

\subsection{Revisão estruturada} \label{revisao-estruturada}

A revisão estruturada é um processo disciplinado para seleção de
artigos a partir de critérios bem definidos, 
de forma que seja possível a reprodução do estudo 
por parte de pesquisadores interessados.

A revisão está organizada em atividades de  
(1) busca de artigos (definição das fontes de busca, 
definição de critérios de busca, definição de script de busca, realização da busca nas fontes)
e (2) caracterização / seleção de artigos. 

No primeiro passo da revisão estruturada,
as fontes de busca serão definidas, considerando
conferências que abordam o tema de interesse do estudo. 

A busca textual será realizada automaticamente, utilizando um 
script\footnote{http://github.com/joenio/dissertacao-ufba-2016/blob/master/revisao-estruturada/filter}
escrito especialmente para este estudo.
A busca seleciona artigos que contêm os seguintes termos:

\begin{verbatim}
  "tool" OU "framework"; E
  "download" OU "available"; E
  "http" OU "ftp"; E
  "static analysis" OU "parser".
\end{verbatim}

Uma cópia local de todos os artigos encontrados, em formato PDF,
será feita.

No segundo passo, a seleção de artigos será feita com
base nos artigos encontrados pela busca.
Na seleção, pretende-se identificar se cada artigo resulta, de fato,
em publicação de ferramenta de análise estática.
Uma vez que se confirme que o artigo publica uma ferramenta,
este artigo será incluído para leitura. 
Ferramentas que sejam mais abrangentes do que apenas análise estática mas que
contenham esta função em seu conjunto também serão selecionadas.

Uma vez identificados os artigos que publicaram ferramentas de
análise estática, procuramos no próprio artigo referências de onde encontrar o
software. Neste contexto,  algumas ações serão tomadas a partir da situação
encontrada.

\begin{itemize}

  \item Autores que afirmam que a ferramenta está disponível mas o
    artigo não contém referências de onde encontrar o software. Os autores serão
    contactados por email, solicitando informações de onde obter o
    código-fonte.

  \item Artigos indicam onde obter o código-fonte da ferramenta, mas o acesso ao local
    indicado não está disponível, ou está disponível mas o software não se
    encontra lá. Os autores também serão contactados, solicitando informações
    atualizadas de onde obter uma cópia do código-fonte da ferramenta.

  \item Artigos indicam onde obter o código-fonte da ferramenta e a referência
    está correta. Será feito o download da última versão disponível do software.

\end{itemize}

Uma vez que os autores contactados por email respondam com informações sobre
local para obter o software, iremos adicionar a ferramenta ao conjunto de ferramentas 
a serem analisadas.

Por fim, a ferramenta livre {\it sloccount}\footnote{http://www.dwheeler.com/sloccount} 
será  utilizada para identificar a linguagem de programação usada na implementação de cada
ferramenta selecionada. 
A identificação da linguagem de programação usada é necessária,
pois apenas as ferramentas implementadas nas linguagens de programação suportadas 
pela ferramenta Analizo serão consideradas.
%
Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte, calcula uma grande quantidade de
métricas, como CBO, LCOM4, RFC, LOC, e suporta análise das linguagens de
programação C, C++ e Java.
É uma ferramenta mantida constantemente, com desenvolvedores ativos, e
atualizações frequentes, sua última versão 1.19.0 foi lançada em 18 de
Fevereiro de 2016 e será esta a versão utilizada neste estudo.

\section{Coleta de dados} \label{coleta}

Serão realizadas duas etapas para identificar e mapear as ferramentas de
análise estática com código-fonte disponível: uma atividade de seleção de
ferramentas da academia, descrita na Seção \ref{ferramentas-da-academia}, e
outra atividade para seleção de ferramentas da indústria, descrita na Seção
\ref{ferramentas-da-industria}.

As ferramentas selecionadas para o estudo serão analisadas com Analizo 
para extração dos valores de métricas de código-fonte.
Esta análise utilizará o comando {\it metrics}
da suite de Analizo, que calcula métricas globais de projeto 
e métricas por módulos.
Este estudo levará em consideração a distribuição das métricas por módulos.

\subsection{Ferramentas da academia} \label{ferramentas-da-academia}

A seleção de ferramentas da academia será relizada por meio
de uma revisão estruturada (seção~\ref{revisao-estruturada}).
As fontes de busca para busca de artigos
são a conferência SCAM - Source Code Analysis and Manipulation Working
Conference\footnote{http://www.ieee-scam.org} e mais uma dentre as seguintes
conferências:

\begin{itemize}
  \item ASE - Automated Software
    Engineering\footnote{http://ase-conferences.org}
  \item CSMR\footnote{A conferência CSMR tornou-se SANER - Software Analysis,
    Evolution, and Reengineering a partir da edição 2015.} - Conference on
    Software Maintenance and
    Reengineering\footnote{http://ansymore.uantwerpen.be/csmr-wcre}
  \item ICSME - International Conference on Software Maintenance and
    Evolution\footnote{http://www.icsme.org}
\end{itemize}

São todas conferências com histórico de mais de 20 anos, ambas com trilhas
para publicação de ferramentas sobre temas com relacionamento estreito com o
tema estudado aqui, o que representa um grande probabilidade de encontrar-mos
ferramentas de análise estática de código-fonte. A decisão de incluir apenas
mais uma conferência além da conferência SCAM se justifica por questões de
cronograma, o tempo previsto para finalizar este trabalho não permite incluir
mais uma fonte de pesquisa para ferramentas da academia.

Após download do código-fonte de cada ferramenta selecionada, em sua versão
mais recente, a ferramenta Analizo será utilizada para a coleta das métricas. 

\subsection{Ferramentas da indústria} \label{ferramentas-da-industria}

A seleção de ferramentas da indústria será feita de forma não estruturada a
partir de uma busca livre e manual no site do projeto SAMATE. As ferramentas
com código-fonte disponível, implementadas nas linguagens de programação
suportadas pelo Analizo serão selecionadas.

Após download do código-fonte de cada ferramenta selecionada, em sua versão
mais recente, a ferramenta Analizo será utilizada para a coleta das métricas. 

\section{Análise de dados} \label{analise}

Os dados coletados incluem métricas de código-fonte para cada módulo/classe de
cada ferramenta selecionada. As métricas coletadas foram as métricas descritas na
Seção \ref{metricas-de-codigo}.

A linguagem R \cite{Ihaka1996} será usada para manipulação de dados, tabelas
e plotagem de gráficos.

\subsection{Distribuição dos valores das métricas}

Foram calculados os percentis de cada métrica para cada ferramenta analisada,
a partir dos valores de métricas extraídos pelo Analizo para cada
módulo/classe das ferramentas analisadas.
Cada percentil é a centésima parte dos dados ordenados de forma crescente.
Os percentis calculados foram: 1, 5, 10, 25, 50, 75, 90, 95 e 99. Dentre estes
iremos discutir os resultados em função dos percentis 75, 90 e 95,
correspondendo a valores muito frequentes, frequentes e pouco frequentes,
respectivamente.

\subsection{Cálculo de distância e modelo de aproximação} \label{distancia}

As métricas coletadas serão também utilizadas para identificar se existem
valores de referência para métricas de ferramentas de análise estática, caso
existam, estes valores de métricas serão utilizados para calcular quão
distante cada ferramenta analisada se encontra dos valores de referência, isto
será feito com base no trabalho realizado \citeonline{Ronaldo2015} onde o
mesmo estudo foi feito para o sistema Android e seus aplicativos.

\subsection{Caracterização das ferramentas} \label{caracterizacao-das-ferramentas}

%Apenas poucas tem sido comparadas umas contra outras

\citeonline{Novak2010} através de um estudo para construção de uma taxonomia
para ferramentas de análise estática propõe uma classificação para tais
ferramentas, dentre esta classificaçao iremos adotar neste trabalho as
seguintes categorias:

\begin{description}

  \item {\it Entrada - quais tipos de arquivos podem ser carregados na
    ferramenta:}
    \begin{itemize}
      \item Código-fonte - arquivos de código texto podem ser carregados
      \item Byte code - arquivos com Java Byte Code ou Microsoft
      \item Linguagem intermediária (MSIL) pode ser carregada
    \end{itemize}


  \item {\it Linguagens suportadas - quais linguagens de programação a ferramenta
    suporta:}
    \begin{itemize}
      \item .NET - todas as linguagens compiladas em bibliotecas ou programas no framework .NET
      \item VB .NET - suporta VB.NET
      \item C\# - suporta C\#
      \item Java - suporta linguagem de programação Java
      \item C, C++ - suporta linguagem de programação C ou C++
    \end{itemize}

  \item {\it Tecnologia - quais tecnologias são usadas para procurar erros no
    código:}
    \begin{itemize}
      \item Dataflow - busca por erros com dataflow
      \item Sintaxe - busca por errors de sintaxe e correctness
      \item Prova de teoremas - procurar erros em provar diferentes teoremas
      \item Verificação de modelos - procurar erros com verificação de modelo
    \end{itemize}

  \item {\it Regras - conjunto de regras, quais são suportadas por diferentes
    código estático:}
    \begin{itemize}
      \item Estilo - inspecina a aparecencia do código fonte
      \item Naming - checa se as varáveis são nomeadas corretamente (ortografia, padroes de nomenclatura, ...)
      \item Geral - regras gerais de analise estática de código
      \item Comcorrencia - erros com execução de código de concorrente
      \item Exceções - erros lançando ou não exceções
      \item Performance - erros de performance das aplicações
      \item Interoperabilidade - erros de comportamento comum
      \item Segurança - erros que podem impactar na segurança da aplicação
      \item SQL - procurar por "SQL injections" e outros erros de SQL
      \item Buffer overflow - erros de segurança, que explorar buffer overflow
      \item Manutenabilidade - regras para melhor manutenabilidade da aplicação
    \end{itemize}

  \item {\it Configurabilidade - abilidade de configurar a ferramenta:}
    \begin{itemize}
      \item Documento texto - comfiguração é feita via documento texto
      \item XML - configuração pe feita por documento XML
      \item GUI - configuraçãi é feita via interface gráfica
      \item Ruleset - ferramenta pode ligar/desligar conjunto de regras
    \end{itemize}

  \item {\it Extensibilidade - se a ferramenta pode ser extendida com regras
    próprias:}
    \begin{itemize}
      \item Possível - é possível extender
      \item Não possível - não é possível extender
    \end{itemize}

  \item {\it Disponibilidade - de que forma a ferramenta está disponível:}
    \begin{itemize}
      \item Open Source – tool is free and source code is available
      \item Free – tool is free, but source code is not available
      \item Commercial – tool is available for payment
    \end{itemize}

  \item {\it Experiência do usuário - de que forma a  ferramenta pode ser
    usada como é oferecida:}
    \begin{itemize}
      \item Environment integration – how is tool integrated with working environment
      \item Automatic locating errors in code – when tool finds an error, it can put as at the location of the error
      \item Extensive help on faults – if tool gives you help on resolving errors
      \item User interface – availability of user interface
      \item Command Line – it can be run from command line prompt
      \item GUI – tool can be run from GUI interface
    \end{itemize}

  \item {\it Saída - representação dos resultados da ferramenta:}
    \begin{itemize}
      \item Text file – tool can present results in text file
      \item List – tool can present results in custom user interface control in GUI
      \item XML file – tool can present results in XML data
      \item HTML file – tool can present results in HTML data
    \end{itemize}

\end{description}

\section{Avaliação da ferramenta Analizo}

Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte.
Analizo calcula uma grande quantidade de métricas, como CBO, LCOM4, RFC, LOC, 
e suporta análise das linguagens de programação C, C++ e Java.

A ferramenta Analizo está em constante evolução, 
com desenvolvedores ativos e  atualizações frequentes.
A versão 1.19.0 do Analizo -- lançada em 18 de
fevereiro de 2016 -- será utilizada neste trabalho.

\section{Cronograma} \label{cronograma}

COLOCAR.

%------------------------------------------%
\xchapter{Conclusões}{} \label{conclusoes}

\section{Resultados preliminares}

Os resultados preliminares são apresentados no Apêndice.

SINTESE AQUI ?  TRENDS? 

(pendente) ``discutir as contribuições dando resposta ao que foi colocado na
introdução, fizemos isto, conseguimos estes resultados, e iremos fazer aquilo
nos proximos passos.''

\section{Próximos passos}

(pendente)

%------------------------------------------%

\backmatter
\bibliography{bibliografia}
\appendix

\xchapter{Resultados preliminares}{} \label{resultados}

\section{Ferramentas acadêmicas selecionadas} 

Ferramentas selecionadas a partir da revisão estruturada detalhada na seção
\ref{revisao-estruturada}.

\subsection{AccessAnalysis}

AccessAnalysis é um plugin do Eclipse de análise estática 
para cálculo das métricas IGAT e IGAM
publicadas no artigo ``AccessAnalysis — A Tool for Measuring the
Appropriateness of Access Modifiers in Java Systems'' do SCAM 2012,
disponível em \url{http://accessanalysis.sourceforge.net}. 
O código-fonte da versão 1.2 foi utilizado neste estudo:

\begin{itemize}
  \item AccessAnalysis-1.2-src.zip
\end{itemize}

Escrito em Java.

\subsection{Bakar Alir}

Bakar Alir é uma ferramenta de {\it program slices} com suporte a visualização
desenvolvido como um plugin Eclipse construído sob a arquitetura do Sireum
publicada no artigo ``Bakar Alir - Supporting Developers in Construction of
Information Flow Contracts in SPARK'' do SCAM 2012, disponível em
\url{http://www.sireum.org/downloads/Alir}\footnote{link desatualizado mas com
referência para o projeto no GitHub em http://github.com/sireum/bakar}.

\begin{itemize}
  \item bakar-dev-20160415-002013.tar.gz
\end{itemize}

Escrito em Java.

\subsection{error-prone}

error-prone é uma ferramenta de localização de bugs construída em cima do
compilador {\it javac} publicada no artigo ``Building Useful Program Analysis
Tools Using an Extensible Java Compiler'' do SCAM 2012 disponível em
\url{http://code.google.com/p/error-prone}.

\begin{itemize}
  \item error-prone-2.0.9.tar.gz
\end{itemize}

Escrito em Java.

\subsection{Indus}

Indus é uma biblioteca de {\it program
slicing}\footnote{http://en.wikipedia.org/wiki/Program\_slicing} publicada no
artigo ``An Overview of the Indus Framework for Analysis and Slicing of
Concurrent Java Software'' do SCAM 2006, disponível em
\url{http://indus.projects.cis.ksu.edu}. 
O projeto está organizado em três módulos.
Os seguintes arquivos, contendo o código-fonte dos três módulos,
foram copiados localmente para análise:

\begin{itemize}
  \item indus.indus-src-20091220.zip
  \item indus.javaslicer-src-20091220.zip
  \item indus.staticanalyses-src-20070305.zip
\end{itemize}

Escrito em Java.

\subsection{InputTracer}

InputTracer é uma ferramenta de análise dinâmica de binários x86 em Linux
publicado no artigo ``InputTracer: A Data-flow Analysis Tool for Manual
Program Comprehension of x86 Binaries'' do SCAM 2012 disponível em:
\url{http://www.ida.liu.se/divisions/adit/security/InputTracer}.

\begin{itemize}
  \item valgrind-inputtracer.tar.gz
\end{itemize}

Escrito em C.

\subsection{JastAdd}

JastAdd é um sistema para análise de código-fonte através da descrição de
atributos via gramática de atributos (AG) publicado no artigo ``Extending
Attribute Grammars with Collection Attributes – Evaluation and Applications''
do SCAM 2007 disponível em \url{http://jastadd.cs.lth.se/web}.

\begin{itemize}
  \item jastadd2-src.zip
\end{itemize}

Escrito em Java.

\subsection{Sonar Qube Plug-in}

Sonar Qube Plug-in é um plugin para o SourceMeter que extende a análise de
código Java com o uso do SonarQube publicado no artigo ``SourceMeter SonarQube
plug-in'' do SCAM 2014 disponível em:
\url{http://github.com/FrontEndART/SonarQube-plug-in}.

\begin{itemize}
  \item SonarQube-plug-in-master.zip
\end{itemize}

% Não cita a licença da ferramenta, diz que é free e pode ser baixado em
% http://www.sourcemeter.com
% Licença: não livre

Escrito em Java.

\subsection{srcML}

srcML é um formato texto para representação de código-fonte e um conjunto de
ferramentas de transformação {\it source-to-source} publicada no artigo
``Lightweight Transformation and Fact Extraction with the srcML Toolkit'' do
SCAM 2011 disponível em
\url{http://www.sdml.info/projects/srcml/trunk}\footnote{este endereço retornou "not
found" em contato com os autores por email indicaram que o projeto foi movido
para http://www.srcML.org}

\begin{itemize}
  \item srcML-src.tar.gz
\end{itemize}

Escrito em C++.

\subsection{TACLE}

TACLE é um plugin do Eclipse para análise de tipo ({\it Type Analysis}) e construção
de visualizaçao de grafos de chamada ({\it Call Graph}) publicado no artigo
``Estimating the Run-Time Progress of a Call Graph Construction Algorithm'' do
SCAM 2006 disponível em \url{http://presto.cse.ohio-state.edu/tacle}\footnote{este
link está indisponível, por email os autores indicaram o endereço
http://web.cse.ohio-state.edu/~rountev/presto/tacle/TACLE\_Download/tacle.html}.

\begin{itemize}
  \item tacle\_1\_2\_1\_src.zip
\end{itemize}

Escrito em Java.

\subsection{WALA}

WALA é uma ferramenta de análise estática para {\it bytecode} Java publicado
no artigo ``Effective Static Analysis to Find Concurrency Bugs In Java'' do
SCAM 2010 disponível em
\url{http://wala.sourceforge.net/wiki/index.php/Main_Page}.

\begin{itemize}
  \item WALA-R\_1.3.8.tar.gz
\end{itemize}

Escrito em Java

\section{Ferramentas da indústria selecionadas} 

\subsection{BOON}

Disponível em \url{http://people.eecs.berkeley.edu/~daw/boon}.

Escrito em C.

\subsection{Clang Static Analyzer}

Disponível em \url{http://clang-analyzer.llvm.org}.

Escrito em C++.

\subsection{Closure Compiler}

Disponível em \url{https://developers.google.com/closure/compiler}.

Escrito em Java.

\subsection{Cppcheck}

Disponível em \url{http://sourceforge.net/projects/cppcheck}.

Escrito em C++.

\subsection{CQual}

Disponível em \url{http://www.cs.umd.edu/~jfoster/cqual}.

Escrito em C.

\subsection{FindBugs}

Disponível em \url{http://findbugs.sourceforge.net}.

Escrito em Java.

\subsection{FindSecurityBugs}

Disponível em \url{http://find-sec-bugs.github.io}.

Escrito em Java.

\subsection{Jlint}

Disponível em \url{http://sourceforge.net/projects/jlint}.

Escrito em C++.

\subsection{Pixy}

Disponível em \url{http://github.com/oliverklee/pixy}.

Escrito em Java.

\subsection{PMD}

Disponível em \url{http://pmd.github.io}.

Escrito em Java.

\subsection{RATS}

Disponível em
\url{http://code.google.com/archive/p/rough-auditing-tool-for-security}.

Escrito em C.

\subsection{Smatch}

Disponível em \url{http://smatch.sourceforge.net}.

Escrito em C.

\subsection{Splint}

Disponível em \url{http://www.splint.org}.

Escrito em C.

\subsection{UNO}

Disponível em \url{http://spinroot.com/uno}.

Escrito em C.

\subsection{WAP}

Disponível em \url{http://awap.sourceforge.net}.

Escrito em Java.

\section{Análise exploratória da revisão estruturada}

%(pendente) ``documentar aqui os artigos incluídos na revisão estruturada,
%identificar aqueles que publicam ferramenta, dentre os que publicam quais
%tinham o software de fato disponível, as referencias indicadas no artigo para
%obtenção do software estavam corretas? foi necessário contactar o autor?''

A Tabela \ref{artigos-do-scam} apresenta um resumo do número de artigos em
cada edição do SCAM e quantos artigos trazem publicação de ferramenta de análise
estática com código fonte disponível.

\begin{table}[h!]
\caption{Total de artigos analisados por edições do SCAM}
\centering
\begin{tabular}{| l | c | c | c |}
\hline
Edição    & Total de artigos & Script filter & Artigos com ferramenta \\
\hline
SCAM 2001 & 23               & 6             & -                      \\
SCAM 2002 & 18               & 6             & -                      \\
SCAM 2003 & 21               & 7             & -                      \\
SCAM 2004 & 17               & 3             & -                      \\
SCAM 2005 & 19               & 7             & -                      \\
SCAM 2006 & 22               & 9             & 2                      \\
SCAM 2007 & 23               & 7             & 1                      \\
SCAM 2008 & 29               & 14            & -                      \\
SCAM 2009 & 20               & 10            & -                      \\
SCAM 2010 & 21               & 15            & 1                      \\
SCAM 2011 & 21               & 9             & 1                      \\
SCAM 2012 & 22               & 12            & 4                      \\
SCAM 2013 & 24               & 12            & -                      \\
SCAM 2014 & 35               & 16            & 1                      \\
SCAM 2015 & 30               & 18            & 0                      \\
\hline
Total     & 315              & 133           & 10                     \\
\hline
\end{tabular}
\label{artigos-do-scam}
\end{table}

A Tabela \ref{total-de-ferramentas} apresenta um resumo com todas as
ferramentas, tanto da academia quanto da indústria, após a avaliação final
sobre disponibilidade do código-fonte e possibilidade de ser analizada. Das 54
ferramentas do NIST apenas 19 tinham código fonte disponível, destas apenas 15
eram suportadas pelo Analizo. Dos 315 artigos avaliados na revisão estruturada
apenas 10 tinham ferramentas disponíveis capaz de serem analizadas pelo
Analizo.

\begin{table}[h!]
  \caption{Lista com total de ferramentas a serem analisadas}
  \centering
  \begin{tabular}{| c | l | l | c | l | l |}
    \hline
    n & Ferramentas da indústria & Linguagem  & n  & Ferramentas da academia & Linguagem  \\
    \hline
    1  & BOON                     & ansic     & 16 & AccessAnalysis          & java       \\
    2  & Clang Static Analyzer    & cpp       & 17 & Bakar Alir              & java       \\
    3  & Closure Compiler         & java      & 18 & error-prone             & java       \\
    4  & Cppcheck                 & cpp       & 19 & Indus                   & java       \\
    5  & CQual                    & ansic     & 20 & InputTracer             & ansic      \\
    6  & FindBugs                 & java      & 21 & JastAdd                 & java       \\
    7  & FindSecurityBugs         & java      & 22 & Sonar Qube Plug-in      & java       \\
    8  & Jlint                    & cpp       & 23 & srcML                   & cpp        \\
    9  & Pixy                     & java      & 24 & TACLE                   & java       \\
    10 & PMD                      & java      & 25 & WALA                    & java       \\
    11 & RATS                     & ansic     &    &                         &            \\
    12 & Smatch                   & ansic     &    &                         &            \\
    13 & Splint                   & ansic     &    &                         &            \\
    14 & UNO                      & ansic     &    &                         &            \\
    15 & WAP                      & java      &    &                         &            \\
    \hline
  \end{tabular}
  \label{total-de-ferramentas}
\end{table}

Assim, temos um total de 25 ferramentas, 15 da indústria e 10 da academia.

\section{Análise exploratória dos valores das métricas}

%(pendente) ``métricas das ferramentas, cálculo dos percentis, score de
%aproximação, valores de referências, discussão sobre cada métrica, discussão
%sobre as ferramentas com melhor qualidade, discutir detalhes da arquitetura
%das melhores ferramentas''.

Vamos analisar os dados e tentar explicar seu comportamento com relação às
características das ferramentas, compará-los a outros estudos.

\subsection{Conexões aferentes de uma classe (ACC)}

ACC é um valor parcial de uma das métricas MOOD (Metrics for Object Oriented
Design) \cite{Brito1994} e mede o nível de acoplamento de uma classe.

Os intervalos sugeridos são: até 2 (bom); entre 2 e 20 (regular); de 20 em
diante (ruim).

As Tabelas \ref{metrica-acc} e \ref{metrica-acc-industria} apresentam os
valores da métrica ACC para as ferramentas da academia e da indústria,
respectivamente.

%% begin.rcode metrica-acc, fig.align='center', results="asis"
% table = percentis_by_project("acc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACC para as ferramentas da academia", "metrica-acc")
%% end.rcode

%% begin.rcode metrica-acc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("acc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACC para as ferramentas da indústria", "metrica-acc-industria")
%% end.rcode

\subsection{Média de complexidade ciclomática por método (ACCM)}

ACCM contabiliza o número de caminhos independentes que métodos de uma classe
pode seguir em sua execução.

As Tabelas \ref{metrica-accm} e \ref{metrica-accm-industria} apresentam os
valores da métrica ACCM para as ferramentas da academia e da indústria,
respectivamente.

%% begin.rcode metrica-accm, fig.align='center', results="asis"
% table = percentis_by_project("accm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACCM para as ferramentas da academia", "metrica-accm")
%% end.rcode

%% begin.rcode metrica-accm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("accm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACCM para as ferramentas da indústria", "metrica-accm-industria")
%% end.rcode

\subsection{Média do número de linhas de código por método (AMLOC)}

AMLOC é a média do número de linhas dos métodos de um módulo.

Os intervalos sugeridos são: até 10 (bom); entre 10 e 13 (regular); de 13 em
diante (ruim).

As Tabelas \ref{metrica-amloc} e \ref{metrica-amloc-industria} apresentam a
métrica AMLOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-amloc, fig.align='center', results="asis"
% table = percentis_by_project("amloc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da academia", "metrica-amloc")
%% end.rcode

%% begin.rcode metrica-amloc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("amloc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da indústria", "metrica-amloc-industria")
%% end.rcode

\subsection{Média do número de parâmetros por método (ANPM)}

ANPM é a média de parâmetros dos métodos de uma classe.

As Tabelas \ref{metrica-anpm} e \ref{metrica-anpm-industria} apresentam a
métrica ANPM para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-anpm, fig.align='center', results="asis"
% table = percentis_by_project("anpm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ANPM para as ferramentas da academia", "metrica-anpm")
%% end.rcode

%% begin.rcode metrica-anpm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("anpm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ANPM para as ferramentas da indústria", "metrica-anpm-industria")
%% end.rcode

\subsection{Acoplamento entre objetos (CBO)}

CBO é a recíproca da métrica ACC e mede quantas classes são utilizadas por uma
certa classe.

As Tabelas \ref{metrica-cbo} e \ref{metrica-cbo-industria} apresentam a
métrica CBO para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-cbo, fig.align='center', results="asis"
% table = percentis_by_project("cbo")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica CBO para as ferramentas da academia", "metrica-cbo")
%% end.rcode

%% begin.rcode metrica-cbo-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("cbo")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica CBO para as ferramentas da indústria", "metrica-cbo-industria")
%% end.rcode

\subsection{Profundidade da árvore de herança (DIT)}

DIT mede a profundidade que uma classe se encontra na árvore de herança.

Os intervalos sugeridos são: até 2 (bom); entre 2 e 4 (regular); de 4 em
diante (ruim).

As Tabelas \ref{metrica-dit} e \ref{metrica-dit-industria} apresentam a
métrica DIT para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-dit, fig.align='center', results="asis"
% table = percentis_by_project("dit")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica DIT para as ferramentas da academia", "metrica-dit")
%% end.rcode

%% begin.rcode metrica-dit-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("dit")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica DIT para as ferramentas da indústria", "metrica-dit-industria")
%% end.rcode

\subsection{Ausência de coesão em métodos (LCOM4)}

LCOM4 calcula quantos conjuntos de métodos relacionados existem dentro de uma
classe, isto é, métodos que compartilham utilização de algum atributo ou que
se referenciam.

Os intervalos sugeridos para código C++ e Java são: até 2 (bom); entre 2 e 5
(regular); de 5 em diante (ruim).

As Tabelas \ref{metrica-lcom4} e \ref{metrica-lcom4-industria} apresentam a
métrica LCOM4 para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-lcom4, fig.align='center', results="asis"
% table = percentis_by_project("lcom4")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LCOM4 para as ferramentas da academia", "metrica-lcom4")
%% end.rcode

%% begin.rcode metrica-lcom4-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("lcom4")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LCOM4 para as ferramentas da indústria", "metrica-lcom4-industria")
%% end.rcode

\subsection{Número de linhas de código (LOC)}

LOC é a medida mais comum para o tamanho de um software, conta o número linhas
executáveis excluindo linhas em branco e comentários.

Os intervalos sugeridos para o LOC de uma classe (Java e C++) são: até 70
(bom); entre 70 e 130 (regular); de 130 em diante (ruim).

As Tabelas \ref{metrica-loc} e \ref{metrica-loc-industria} apresentam a
métrica LOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-loc, fig.align='center', results="asis"
% table = percentis_by_project("loc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LOC para as ferramentas da academia", "metrica-loc")
%% end.rcode

%% begin.rcode metrica-loc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("loc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LOC para as ferramentas da indústria", "metrica-loc-industria")
%% end.rcode

\subsection{Número de atributos (NOA)}

NOA contabiliza o número de atributos de uma classe.

As Tabelas \ref{metrica-noa} e \ref{metrica-noa-industria} apresentam a
métrica NOA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-noa, fig.align='center', results="asis"
% table = percentis_by_project("noa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOA para as ferramentas da academia", "metrica-noa")
%% end.rcode

%% begin.rcode metrica-noa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOA para as ferramentas da indústria", "metrica-noa-industria")
%% end.rcode

\subsection{Número de filhos (NOC)}

NOC é o número total de flhos de uma classe.

As Tabelas \ref{metrica-noc} e \ref{metrica-noc-industria} apresentam a
métrica NOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-noc, fig.align='center', results="asis"
% table = percentis_by_project("noc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOC para as ferramentas da academia", "metrica-noc")
%% end.rcode

%% begin.rcode metrica-noc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOC para as ferramentas da indústria", "metrica-noc-industria")
%% end.rcode

\subsection{Número de métodos (NOM)}

NOM indica o tamanho das classes em termos das suas operações implementadas.

As Tabelas \ref{metrica-nom} e \ref{metrica-nom-industria} apresentam a
métrica NOM para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-nom, fig.align='center', results="asis"
% table = percentis_by_project("nom")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOM para as ferramentas da academia", "metrica-nom")
%% end.rcode

%% begin.rcode metrica-nom-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("nom")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOM para as ferramentas da indústria", "metrica-nom-industria")
%% end.rcode

\subsection{Número de atributos públicos (NPA)}

NPA mede o encapsulamento entre classes.

Os intervalos sugeridos para Java e C++ são: até 1 (bom); entre 1 e 9
(regular); de 9 em diante (ruim).

As Tabelas \ref{metrica-npa} e \ref{metrica-npa-industria} apresentam a
métrica NPA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-npa, fig.align='center', results="asis"
% table = percentis_by_project("npa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPA para as ferramentas da academia", "metrica-npa")
%% end.rcode

%% begin.rcode metrica-npa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPA para as ferramentas da indústria", "metrica-npa-industria")
%% end.rcode

\subsection{Número de métodos públicos (NPM)}

NPM indica o tamanho da ``interface'' da classe.

Os intervalos sugeridos para Java e C++ são: até 10 (bom); entre 10 e 40
(regular); de 40 em diante (ruim).

As Tabelas \ref{metrica-npm} e \ref{metrica-npm-industria} apresentam a
métrica NPA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-npm, fig.align='center', results="asis"
% table = percentis_by_project("npm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPM para as ferramentas da academia", "metrica-npm")
%% end.rcode

%% begin.rcode metrica-npm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPM para as ferramentas da indústria", "metrica-npm-industria")
%% end.rcode

\subsection{Resposta para uma classe (RFC)}

RFC conta o número de métodos que podem ser executados a partir de uma
mensagem enviada a um objeto dessa classe.

As Tabelas \ref{metrica-rfc} e \ref{metrica-rfc-industria} apresentam a
métrica RFC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-rfc, fig.align='center', results="asis"
% table = percentis_by_project("rfc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica RFC para as ferramentas da academia", "metrica-rfc")
%% end.rcode

%% begin.rcode metrica-rfc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("rfc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica RFC para as ferramentas da indústria", "metrica-rfc-industria")
%% end.rcode

\subsection{Complexidade estrutural (SC)}

SC é medida através da combinação das métricas de acoplamento (CBO) e coesão
(LCOM4).

As Tabelas \ref{metrica-sc} e \ref{metrica-sc-industria} apresentam a
métrica SC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-sc, fig.align='center', results="asis"
% table = percentis_by_project("sc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica SC para as ferramentas da academia", "metrica-sc")
%% end.rcode

%% begin.rcode metrica-sc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("sc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica SC para as ferramentas da indústria", "metrica-sc-industria")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas academicas}

%% begin.rcode grafico-accessanalysis, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta accessanalysis"
% plot_lines_for_project("dataset/PAPERS/accessanalysis/AccessAnalysis-1.2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-bakar-ali, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta bakar-ali"
% plot_lines_for_project("dataset/PAPERS/bakar-ali/bakar-dev-20160415-002013.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-error-prone, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta error-prone"
% plot_lines_for_project("dataset/PAPERS/error-prone/error-prone-2.0.9.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-indus, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta indus"
% plot_lines_for_project("dataset/PAPERS/indus/indus.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-inputtracer, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta inputtracer"
% plot_lines_for_project("dataset/PAPERS/inputtracer/valgrind-inputtracer.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jastadd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jastadd"
% plot_lines_for_project("dataset/PAPERS/jastadd/jastadd2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-source-meter, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta source-meter"
% plot_lines_for_project("dataset/PAPERS/source-meter/SonarQube-plug-in-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-srcml, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta srcml"
% plot_lines_for_project("dataset/PAPERS/srcml/srcML-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-tacle, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta tacle"
% plot_lines_for_project("dataset/PAPERS/tacle/tacle_1_2_1_src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wala, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wala"
% plot_lines_for_project("dataset/PAPERS/wala/WALA-R_1.3.8.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas da indústria}

%% begin.rcode grafico-boon-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta boon"
% plot_lines_for_project("dataset/NIST/boon/boon-1.0.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-clang-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta clang"
% plot_lines_for_project("dataset/NIST/clang/clang-tools-extra-3.7.1.src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-closure-compiler, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta closure-compiler"
% plot_lines_for_project("dataset/NIST/closure-compiler/compiler-latest.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cppcheck, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cppcheck"
% plot_lines_for_project("dataset/NIST/cppcheck/cppcheck-1.72.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cqual, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cqual"
% plot_lines_for_project("dataset/NIST/cqual/cqual-0.981.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-findbugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findbugs"
% plot_lines_for_project("dataset/NIST/findbugs/findbugs-3.0.1.analizo.metrics.dat")
%% end.rcode


%% begin.rcode grafico-findsecuritybugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findsecuritybugs"
% plot_lines_for_project("dataset/NIST/findsecuritybugs/findsecbugs-plugin-1.4.5-sources.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jlint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jlint"
% plot_lines_for_project("dataset/NIST/jlint/jlint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pixy, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pixy"
% plot_lines_for_project("dataset/NIST/pixy/pixy-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pmd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pmd"
% plot_lines_for_project("dataset/NIST/pmd/pmd-src-5.4.1.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-rats, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta rats"
% plot_lines_for_project("dataset/NIST/rats/rats-2.4.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-smatch, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta smatch"
% plot_lines_for_project("dataset/NIST/smatch/smatch.git.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-splint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta splint"
% plot_lines_for_project("dataset/NIST/splint/splint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-uno, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta uno"
% plot_lines_for_project("dataset/NIST/uno/uno.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wap, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wap"
% plot_lines_for_project("dataset/NIST/wap/wap-2.1.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas academicas}

%% begin.rcode grafico-lcom4, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas da indústria}

%% begin.rcode grafico-lcom4-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\section{Evolução inicial da ferramenta Analizo}\label{evolucao-analizo}

(pendente) ``apenas se der tempo''.

%\section{Resultados}
%
%%7- Nos resultados, teremos duas coisas: Referência dos valores frequentes e Aplicação do cálculo do score de similaridade
%
%(pendente) ``a caracterização das ferramentas dará indícios para documentar
%sugestões de refatoração para ferramentas de análise estática, estas sugestões
%serão aplicadas na refatoração do Analizo.''


\end{document}

% vim: filetype=tex
