\documentclass[qual, classic, a4paper]{ufbathesis}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage[alf]{abntex2cite}
\usepackage{graphicx}
%\usepackage{longtable}
\usepackage{multicol}
\DeclareGraphicsExtensions{.pdf}

\date{08 de Julho de 2016}
\adviser[f]{Profa. Dra. Christina von Flach G. Chavez}
\coadviser{Prof. Dr. Paulo Roberto Miranda Meirelles}

\title{
  Caracterização da complexidade estrutural em ferramentas de análise estática
  de código-fonte
}

\author{Joenio Marques da Costa\\
  {\small joenio@joenio.me}
}

\begin{document}
\frontpage
\frontmatter
\presentationpage

\acknowledgements

(pendente)

\resumo

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\abstract

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\tableofcontents
\listoffigures
\listoftables
\mainmatter

\chapter{Introdução}

%\section{Motivação}
%paulo: 1- Num primeiro momento, não precisa de uma subseção "motivação" na
%introdução, pois, acho que atrapalha a escrita. 

(pendente)

\section{Objetivos}

O objetivo principal deste trabalho é compreender as ferramentas de software
para análise estática de código-fonte, do ponto de vista de sua
manutenabilidade, a partir da análise de sua complexidade estrutural,
discutindo quais características arquiteturais explicam seus atributos de
qualidade interna.

Objetivos específicos:

\begin{itemize}
  \item Realizar uma revisão da literatura para caraterizar a arquitetura das
    ferramentas de análise estática de código-fonte.
  \item Realizar uma revisão estruturada, com base em artigos publicados em
    conferências relacionadas, para selecionar e obter código-fonte de
    ferramentas de análise estática (explicadas na Seção
    \ref{revisao-estruturada}), para coletar suas métricas de código-fonte.
  \item Selecionar e obter o código-fonte de ferramentas de análise estática
    desenvolvidas pelo indústria (explicadas na Seção
    \ref{ferramentas-da-industria}), para coletar suas métricas de
    código-fonte.
  \item Propor intervalos de referência  para a observação parametrizada da
    qualidade interna das ferramentas de análise estática, a partir de suas
    métricas de código-fonte.
  \item Cálculo da distância Bayesiana entre valores de referência e os valores
    das ferramentas estudadas.
  \item Evoluir uma ferramenta de análise de código-fonte para coleta de
    métricas de código-fonte (detalhado na Seção \ref{evolucao-analizo}).
  \item Um conjunto de estratégias para a manutenção e evolução de ferramentas
    de análise estática de código-fonte.
\end{itemize}

\section{Contribuições esperadas}

\begin{enumerate}
  \item [CC1:] Um conjunto de intervalos de referência da frequência dos
    valores de métricas de código-fonte para o domínio de ferramentas de
    análise estática
  \item [CC2:] Explicação da alta complexidade estrutural em ferramentas de
    análise de código-fonte
  \item [CT1:] Evolução de uma ferramenta de análise de código-fonte
\end{enumerate}

\chapter{Análise estática de código-fonte}

Análise estática de código-fonte é um ramo da engenharia de software voltado a
obter informações acerca de um programa a partir do seu código-fonte sem
necessidade de execução, e sem requerer qualquer outro artefato do programa
além do próprio código. É considerada uma atividade meio com objetivo de
suportar uma variedade de tarefas comuns da engenharia de software, muitas
dessas tarefas são substancialmente úteis em atividades de manutenção,
\citeonline{Binkley2007} define uma extensa lista dessas atividades, segue
abaixo um sub-conjunto delas.

\begin{multicols}{2}
  \begin{itemize}
    \item recuperação arquiterural
    \item detecção de clone
    \item compreensão
    \item pesquisa em engenharia de software empírica
    \item localizaçao de falhas
    \item desenvolvimento baseado em modelos
    \item análise de performance
    \item evolução de software
    \item garantia de qualidade
    \item engenharia reversa
    \item manutenção de software
    \item versionamento de software
    \item testes
    \item ferramentas e ambientes
    \item desenvolvimento de aplicações web
  \end{itemize}
\end{multicols}

Seja em qual atividade for, a análise estática possui uma importância
significativa, pois ao ser capaz de extrair informações diretamente do
código-fonte de um programa pode auxiliar a responder com precisão a seguinte
pergunta: ``O que é que este programa significa?''

\section{Anatomia da análise de código-fonte}

\citeonline{Cruz2009}, \citeonline{Binkley2007} realizaram um estudo onde
definiram a estrutura comum da análise de código-fonte em três componentes: a)
extração de dados, b) representação interna, e c) análise da representação
interna. Esta mesma estrutura é também apresentada na documentação da
ferramenta de análise de código-fonte
CodeSonar\footnote{http://www.grammatech.com/products/source-code-analysis},
reproduzida aqui na Figura \ref{static-analysis-representation}.

\begin{figure}[h]
  \center
  \includegraphics[scale=0.4]{imagens/static-analysis-representation.png}
  \caption{CodeSonar: Static Analysis Representation}
  \label{static-analysis-representation}
\end{figure}

As seções à seguir detalham cada um destes componentes.

\subsection{Extração de dados}

O processo de recuperar dados para futuro processamento ou armazenamento é
chamado de extração de dados, exportar estes dados em uma representação
intermadiária é uma estratégia comum para facilitar análise e transformação de
dados e possivelmente adição de metadados. 

O primeiro componente da análise de código-fonte é a extração de dados,
responsável por processar o código-fonte e transformar em uma ou mais
representações internas. Em essência este componente converte a sintaxe de um
programa em uma outra sintaxe abstrata e mais adequada para análise posterior.

Este componente é usualmente chamado de analisador sintático (ou {\it parser}) e a tarefa realizada por
ele é considerada como um mal necessário da análise de código-fonte.
Apesar de teoricamente não ser uma tarefa difícil, a complexidade das
linguagens de programação modernas podem restringir significativamente a
análise de código-fonte.

\subsection{Representação interna}

Os dados obtidos na extração precisam ser representados em um
formato mais abstrato, esta é a responsabilidade do segundo componente da
análise de código-fonte: armazenar os dados coletados usando uma representação
interna num formato mais adequado para análise automática, o principal papel
deste componente é abstrair aspectos particulares do programa.

Muitas das representações internas existentes tem seu surgimento na área de
compiladores e algumas delas são produzidas diretamente pelo {\it parser}
enquanto outras requerem uma análise específica. Os formatos mais comuns são
baseados em grafos, dentre os quais o mais amplamente utilizado é Control Flow
Graph (CFG), ou Call Graph. Outros formatos conhecidos são:

\begin{multicols}{2}
  \begin{itemize}
    \item Identifiers Table
    \item Abstract Syntax Tree (AST)
    \item Decorated Abstract Syntax Tree (AST)
    \item Control Flow Graph (CFG)
    \item Value Dependence Graph (VDG)
    \item Call Graph
    \item Module Dependence Graph (MDG)
    \item Trace Flow Graph (TFG)
    \item Static Single Assignment (SSA)
  \end{itemize}
\end{multicols}
  
Estas representações podem ser utilizadas tanto na análise estática quanto na
análise dinâmica, o uso de um ou outro formato depende do tipo de análise e
seu propósito. Numa aplicação real é comum combinar diferentes tipos no
sentido de enriquecer e estruturar a informação extraída.

\subsection{Análise da representação interna}

Este terceiro componente da análise de código
é responsável por realizar inferências a partir das informações
representadas internamente, este processo requer
que as informações armazenadas estejam interconectadas e também
interrelacionadas com conhecimento anterior. Esta análise pode gerar
conhecimento quantitativo ou qualitativo, como por exemplo métricas de
software ou mineração de dados, respectivamente. Técnicas
de visualização são cruciais para a efetividade deste processo.

É neste componente que acontece a análise propriamente dita, e ele pode ser
classificado em seis dimensões básicas: estática versus dinâmica, sound versus
unsound, segura vesus insegura, sensível ao fluxo versus insensível ao fluxo,
sensível ao contexto versus insensível ao contexto, e, em relação à sua
complexidade.

Estas características da análise vão afetar o resultado gerado quanto à
confiabiliade, completude, garantia de precisão, eficiência, performance,
complexidade computacional, precisão da informaçao, entre outras.

\section{Métricas de código-fonte}

Uma métrica, segundo a definição da ISO/IEC 25010 \cite{iso2011iec25010}, é a
composição de procedimentos para a definição de escalas e métodos para
medidas, em engenharia de software estas métricas podem ser classificadas em
três categorias: métricas de produto, métricas de processo e métricas de
projeto.

Métricas de produto são aquelas que descrevem as características de artefatos
do desenvolvimento, como documentos, diagramas, código-fonte e arquivos
binários. Métricas de processo medem atributos relacionados ao ciclo de
desenvolvimento do software. Métricas de projeto são aquelas que descrevem as
características dos recursos disponíveis ao desenvolvimento.

As métricas de produto podem ser
classificadas entre internas ou externas, ou seja, aquelas que medem
propriedades visíveis apenas aos desenvolvedores ou que medem propriedades
visíveis aos usuários, respectivamente.

As propriedades visíveis aos desenvolvedores podem ser medidas através de
métricas de código-fonte e a sua observação pode indicar aspectos relevantes à
manutenibilidade de um programa. Dentre as inúmeras métricas de código-fonte
iremos destacar aquelas utilizadas no estudo de \citeonline{Meirelles2013}
onde associou-se características de qualidade de produto de software à
características de qualidade de código-fonte através da observação de
suas métricas.

\begin{itemize}
  \item {\bf ACC} {\it Aferent Connections per Class (Conexões aferentes de
    uma classe)}: Mede a conectividade de uma classe.
  \item {\bf ACCM} {\it Average Cyclomatic Complexity per Method (Média de
    complexidade ciclomática por método)}: mede a complexidade do programa
    \cite{McCabe1976}.
  \item {\bf AMLOC} {\it Average Method LOC (Média do número de linhas de
    código por método)}: indica se o código está bem distribuído entre os
    métodos, quanto maior mais ``pesados'' são os métodos (??)
  \item {\bf ANPM} {\it Average Number of Parameters per Method (Média do
    Número de Parâmetros por Método)}: calcula a média de parâmetros dos
    métodos da classe (Bansiya e Davi, 1997).
  \item {\bf CBO} {\it Coupling Between Objects (Acoplamento entre objetos)}:
    mede o acoplamento entre objetos do software \cite{Chidamber1994}.
  \item {\bf DIT} {\it Depth of Inheritance Tree (Profundidade da árvore de
    herança)}: mede o número de ancestrais de uma classe \cite{Shih1997}.
  \item {\bf LCOM4} {\it Lack of Cohesion in Methods (Ausência de coesão em
    métodos)}: mede o grau de falta de coesão em métodos \cite{Hitz1995}.
  \item {\bf LOC} {\it Lines of Code (Número de linhas de código)}: mede o
    número de linhas excluindo linhas em branco e comentários.
  \item {\bf NOA} {\it Number of Attributes (Número de atributos)}: calcula o
    número de atributos de uma classe
  \item {\bf NOC} {\it Number Of Children (Número de filhos)}: número total de
    filhos de uma classe \cite{Rosenberg1997}.
  \item {\bf NOM} {\it Number of Methods (Número de métodos)}: mede o tamanho
    das classes em termos das suas operações implementadas.
  \item {\bf NPA} {\it Number of Public Attributes (Número de atributos
    públicos)}: mede o encapsulamento.
  \item {\bf NPM} {\it Number of Public Methods (Número de métodos públicos)}:
    representa o tamanho da ``interface'' da classe.
  \item {\bf RFC} {\it Response For a Class (Resposta para uma classe)}:
    número de métodos dentre todos os métodos que podem ser invocados em
    resposta a uma mensagem enviada por um objeto de uma classe
    \cite{Sharble1993}.
  \item {\bf SC} {\it Structural Complexity (Complexidade estrutural)}: mede a
    complexidade do software \cite{Darcy2005}.
\end{itemize}

\subsection{Complexidade estrutural}

Complexidade estrutural (SC) é uma medida calculada através da combinação das
métricas de acoplamento (CBO) e coesão (LCOM4), esta medida é, possivelmente,
um indicativo de problemas na manutenibilidade de sistemas de software, em
especial sobre o esforço necessário para atividades de manutenção
\cite{Terceiro2012}. Ela está relacionada à como os módulos de um programa
estão organizados entre sí bem como à estrutura interna de cada módulo.

Esta métrica pode dar indícios importantes sobre características arquiteturais
de um programa de software, e podem explicar seus atributos de qualidade
interna.

\section{Analizo}

Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte, calcula uma grande quantidade de
métricas, como CBO, LCOM4, RFC, LOC, e suporta análise das linguagens de
programação C, C++ e Java.

É uma ferramenta mantida constantemente, com desenvolvedores ativos, e
atualizações frequentes, sua última versão 1.19.0 foi lançada em 18 de
Fevereiro de 2016 e será esta a versão utilizada neste estudo.

\chapter{Metodologia}

Visando então caracterizar as ferramentas de análise estática de código-fonte
será feito um levantamento de artigos com publicação de ferramentas deste
domínio e uma busca por ferramentas de análise estática na indústria.

Este levantamento resultará num conjunto de ferramentas de análise estática de
código-fonte, estas ferramentas serão caracterizadas através da análise de
suas métricas de qualidade interna e darão valores de referência de métricas
para ferramentas deste domínio.

A avaliação destes valores juntamente com as características arquiteturais
encontradas darão origem a recomendações de refatoração para ferramentas de
análise estática de código-fonte.

\section{Trabalhos relacionados}\label{trabalhos-relacionados}

%4- Os trabalhos relacionados, num primeiro momento, devem ser colocados na
%primeira subseção da metodologia, para fazer um ganho com o que tem diferente
%deste trabalho, levando às hipótese na seção seguintes. Antes de falar dos
%trabalhos relacionados, deve-se ter uma introdução no capítulo de metodologia
%resgatando o problema tratado pelo trabalho e que tem estudos da área etc
%etc...

(pendente)

\section{Hipóteses}

Para guiar os estudos, conforme os objetivos acima, definimos as seguintes
hipóteses:

\begin{enumerate}
  \item[{\bf H1:}] {\em É possível calcular valores de referência de métricas
    de código-fonte para ferramentas de análise estática a partir de um
    conjunto de softwares da academia e da indústria}
  \item[{\bf H2:}] {\em Ferramentas de análise estática tendem a ter uma
    maior complexidade estrutural do que ferramentas de outros domínios de
    aplicação}
  \item[{\bf H3:}] {\em Dentre as ferramentas de análise estática de
    código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
    complexidade estrutural}
\end{enumerate}

A hipótese {\bf H1} será validada a partir da análise das métricas calculadas
para cada uma das ferramentas estudadas, esta análise levará em consideração a
caracterização das ferramentas (explicados na Seção
\ref{caracterizacao-das-ferramentas}), em especial um subconjunto das
ferramentas com melhores valores de métricas.

A hipótese {\bf H2} será validada a partir da comparação com os trabalhos
relacionados (Seção \ref{trabalhos-relacionados}), onde
realizou-se estudos similares com cálculo e distribuição de métricas
utilizando conjuntos de softwares e ferramentas distintos dos estudados aqui.

A hipótese {\bf H3} será validada a partir do cálculo da distância das
métricas de cada ferramenta com os valores de referências encontrados neste
estudo (explicados na Seção \ref{distancia}).

\section{Planejamento do estudo}

%\subsection{Seleção de métricas}
%
%Estas métricas serão coletadas para cada classe/módulo presente nas
%ferramentas de análise estática selecionadas e servirão de base para
%avaliar a qualidade das mesmas.
%
%(pendente) ``retomar complexidade estrutural e linkar com trabalho de
%terceiro, iremos olhar com mais detalhes algumas ferramentas e para este
%subconjunto vamos analisar a organização arquitetural dos módulos, isto
%será base para o guia de refatoração que faremos.''

\subsection{Seleção de ferramentas de análise estática}\label{levantamento}

Iremos realizar
uma busca por ferramentas de análise estática desenvolvidas no contexto da
academia e da indústria, para isso, será feito um planejamento detalhado para
realizar a seleção de ferramentas em cada um destes contextos.

No contexto acadêmico a busca por ferramentas será feita
através de artigos publicados em conferências que tenham histórico de
publicação sobre ferramentas de análise estática de código-fonte. Estes
artigos serão analisados e aqueles com publicação de ferramenta
serão selecionados.

Na indústria, a busca por ferramentas será feita a partir da base mantida pelo
projeto SAMATE, um projeto do NIST dedicado ao desenvolvimento de métodos que
permitam avaliar e medir a eficiência de ferramentas e técnicas sobre garantia
de qualidade em software. O site do projeto mantém uma lista de ferramentas de
análise estática.

Uma vez que as ferramentas tenham sido selecionadas iniciaremos a extração de
seus atributos de qualidade interna a partir do cálculo de suas métricas de
código-fonte.

\subsection{Revisão estruturada}\label{revisao-estruturada}

Chamamos de revisão estruturada um processo disciplinado para seleção de
artigos a partir de critérios bem definidos de forma que seja possível a
reprodução do estudo por parte de pesquisadores interessados.

A primeira etapa da revisão é definir onde os artigos serão encontrados, as
fontes serão conferências com o tema de interesse ao estudo realizado, uma vez
definido a origem é feito cópia local de todos os artigos em formato
PDF.

A caracterização dos artigos se inicia por uma busca
textual realizada através de um script\footnote{http://github.com/joenio/dissertacao-ufba-2016/blob/master/revisao-estruturada/filter}
escrito especialmente para este estudo, esta busca seleciona os
artigos através dos seguintes termos:

\begin{verbatim}
  "tool" OU "framework"; E
  "download" OU "available"; E
  "http" OU "ftp"; E
  "static analysis" OU "parser".
\end{verbatim}

O segundo passo é realizado a partir de uma leitura do artigo a fim de
identificar se realmente trata-se de um artigo com publicação de ferramenta de
análise estática, uma vez que se confirme que o artigo publica uma ferramenta
este artigo será selecionado,
ferramentas que sejam mais abrangentes do que apenas análise estática mas que
contenham esta função em seu conjunto também serão considerados.

Uma vez identificado os artigos que publicam ferramentas de
análise estática, procuramos no próprio artigo referências de onde encontrar o
software, neste momento algumas ações serão tomadas a partir da situação
encontrada.

\begin{itemize}

  \item Aqueles autores que afirmam que a ferramenta está disponível mas o
    artigo não contém referências de onde encontrar o software serão
    contactados por email solicitando informações de onde obter o
    código-fonte.

  \item Os artigos que indicam onde obter o cófigo-fonte mas o acesso ao local
    indicado não está disponível, ou está disponível mas o software não se
    encontra lá, os autores também serão contactados solicitando informações
    atualizadas de onde obter uma cópia do código-fonte da ferramenta

  \item Os demais artigos que indicam onde obter o código-fonte e a referência
    está correta, iremos fazer download da última versão disponível do software

\end{itemize}

Uma vez que os autores contactados por email respondam com informações de onde
obter o software iremos adicionar estes softwares no conjunto de softwares a
serem analisados.

\section{Coleta de dados}

Serão realizadas duas etapas para identificar e mapear as ferramentas de
análise estática com código-fonte disponível, uma atividade relacionada ao
levantamento de ferramentas da academia, descrita na Seção
\ref{ferramentas-da-academia}, outra atividade relacionada ao levantamento de
ferramentas da indústria, descrita na Seção \ref{ferramentas-da-industria}.

Uma vez definido o conjunto de ferramentas a serem estudados iremos
identificar em qual linguagem de programação cada ferramenta é escrita, isto é
necessário pois apenas as linguagens suportadas pela ferramenta Analizo serão
selecionadas. Esta análise será feita pela ferramenta {\it
sloccount}\footnote{http://www.dwheeler.com/sloccount}, uma ferramenta livre
para contar linhas de código fonte e que identifica em qual linguagem de
programação um projeto é escrito.

As ferramentas selecionadas serão analisadas com o Analizo para extração de
suas métricas de código-fonte, esta análise utilizará o comando {\it metrics}
da súite Analizo, ele calcula métricas globais de projeto e métricas por
módulos, este estudo levará em consideração a distribuição das métricas por módulos.

\subsection{Ferramentas da academia}\label{ferramentas-da-academia}

A seleção de ferramentas da academia será relizada através da revisão estruturada dos
artigos da conferência SCAM - Source Code Analysis and Manipulation Working
Conference\footnote{http://www.ieee-scam.org} e mais uma dentre as seguintes
conferências:

\begin{itemize}
  \item ASE - Automated Software
    Engineering\footnote{http://ase-conferences.org}
  \item CSMR\footnote{A conferência CSMR tornou-se SANER - Software Analysis,
    Evolution, and Reengineering a partir da edição 2015.} - Conference on
    Software Maintenance and
    Reengineering\footnote{http://ansymore.uantwerpen.be/csmr-wcre}
  \item ICSME - International Conference on Software Maintenance and
    Evolution\footnote{http://www.icsme.org}
\end{itemize}

\subsection{Ferramentas da indústria}\label{ferramentas-da-industria}

A seleção de ferramentas da indústria será feita de forma não estruturada a
partir de uma busca livre e manual no site do projeto
SAMATE\footnote{http://samate.nist.gov} - {\em Software Assurance Metrics and
Tool Evaluation} disponível em \citeonline{SamateAnalysers}. As ferramentas
com código-fonte disponível, escritas nas linguagens de programaçção suportadas
pelo Analizo serão selecionadas.

\section{Análise de dados}

Após download do código-fonte de cada ferramenta em sua versão mais recente,
foi utilizada a ferramenta Analizo para a coleta das métricas. Com todas as
métricas perfeitamente calculadas utilizamos a linguagem R para manipulação
dos dados, tabelas e plotagem de gráficos.

Foram calculados os percentis de cada métrica para cada ferramenta analisada,
cada percentil é a centésima parte dos dados ordenados de forma crescente, os
percentis calculados foram: 1, 5, 10, 25, 50, 75, 90, 95 e 99. Dentre estes
iremos discutir os resultados em função dos percentis 75, 90 e 95,
correspondendo a valores muito frequentes, frequentes e pouco frequentes,
respectivamente.

\subsection{Distribuição dos valores das métricas}\label{distancia}

(pendente) ``como será calculado a distribuição dos valores''.

\subsection{Cálculo de distância e modelo de aproximação}

(pendente) ``como será feito este cálculo''.

\subsection{Caracterização das ferramentas}\label{caracterizacao-das-ferramentas}

%As métricas coletadas serão também utilizadas para identificar se existem
%valores de referência para métricas de ferramentas de análise estática, caso
%existam, estes valores de métricas serão utilizados para calcular quão
%distante cada ferramenta analisada se encontra dos valores de referência, isto
%será feito com base no trabalho realizado \citeonline{Ronaldo2015} onde o
%mesmo estudo foi feito para o sistema Android e seus aplicativos.

(pendente) ``como as ferramentas serão caracterizadas''.

\chapter{Resultados preliminares}

\section{Análise exploratória da revisão estruturada}

%(pendente) ``documentar aqui os artigos incluídos na revisão estruturada,
%identificar aqueles que publicam ferramenta, dentre os que publicam quais
%tinham o software de fato disponível, as referencias indicadas no artigo para
%obtenção do software estavam corretas? foi necessário contactar o autor?''

A Tabela \ref{artigos-do-scam} apresenta um resumo do número de artigos em
cada edição do SCAM e quantos artigos trazem publicação de ferramenta de análise
estática com código fonte disponível.

\begin{table}[h]
\caption{Total de artigos analisados por edições do SCAM}
\centering
\begin{tabular}{| l | c | c | c |}
\hline
Edição    & Total de artigos & Script filter & Artigos com ferramenta \\
\hline
SCAM 2001 & 23               & 6             & -                      \\
SCAM 2002 & 18               & 6             & -                      \\
SCAM 2003 & 21               & 7             & -                      \\
SCAM 2004 & 17               & 3             & -                      \\
SCAM 2005 & 19               & 7             & -                      \\
SCAM 2006 & 22               & 9             & 2                      \\
SCAM 2007 & 23               & 7             & 1                      \\
SCAM 2008 & 29               & 14            & -                      \\
SCAM 2009 & 20               & 10            & -                      \\
SCAM 2010 & 21               & 15            & 1                      \\
SCAM 2011 & 21               & 9             & 1                      \\
SCAM 2012 & 22               & 12            & 4                      \\
SCAM 2013 & 24               & 12            & -                      \\
SCAM 2014 & 35               & 16            & 1                      \\
SCAM 2015 & 30               & 18            & 0                      \\
\hline
Total     & 315              & 133           & 10                     \\
\hline
\end{tabular}
\label{artigos-do-scam}
\end{table}

\section{Ferramentas com código-fonte disponível}

A Tabela \ref{total-de-ferramentas} apresenta as ferramenta da academia e da
indústria após avaliação final sobre disponibilidade do código-fonte e
possibilidade de ser analizada. Das 54 ferramentas do NIST apenas 19 tinham código
fonte disponível, destas apenas 15 eram suportadas pelo Analizo. Dos 315
artigos avaliados na revisão estruturada apenas 10 tinham ferramentas
disponíveis capaz de serem analizadas pelo Analizo.

\begin{table}[h]
  \caption{Lista com total de ferramentas a serem analisadas}
  \centering
  \begin{tabular}{| c | l | l | c | l | l |}
    \hline
    n & Ferramentas da indústria & Linguagem  & n  & Ferramentas da academia & Linguagem  \\
    \hline
    1  & BOON                     & ansic     & 16 & Indus                   & java       \\
    2  & CQual                    & ansic     & 17 & TACLE                   & java       \\
    3  & RATS                     & ansic     & 18 & JastAdd                 & java       \\
    4  & Smatch                   & ansic     & 19 & WALA                    & java       \\
    5  & Splint                   & ansic     & 20 & error-prone             & java       \\
    6  & UNO                      & ansic     & 21 & AccessAnalysis          & java       \\
    7  & Clang Static Analyzer    & cpp       & 22 & Bakar Alir              & java       \\
    8  & Cppcheck                 & cpp       & 23 & InputTracer             & ansic      \\
    9  & Jlint                    & cpp       & 24 & srcML                   & cpp        \\
    10 & WAP                      & java      & 25 & Source Meter            & java       \\
    11 & Closure Compiler         & java      &    &                         &            \\
    12 & FindBugs                 & java      &    &                         &            \\
    13 & FindSecurityBugs         & java      &    &                         &            \\
    14 & Pixy                     & java      &    &                         &            \\
    15 & PMD                      & java      &    &                         &            \\
    \hline
  \end{tabular}
  \label{total-de-ferramentas}
\end{table}

Assim, temos um total de 25 ferramentas, 15 da indústria e 10 da academia.

\section{Análise exploratória dos valores das métricas}

(pendente) ``métricas das ferramentas, cálculo dos percentis, score de
aproximação, valores de referências, discussão sobre cada métrica, discussão
sobre as ferramentas com melhor qualidade, discutir detalhes da arquitetura
das melhores ferramentas''.

\subsection{Métricas para as ferramentas da academia}

\subsubsection{Conexões aferentes de uma classe (ACC)}

A Tabela \ref{metrica-acc} apresenta a métrica ACC para cada ferramenta
acadêmica.

%% begin.rcode metrica-acc, fig.align='center', results="asis"
% table = percentis_by_project("acc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica acc", "metrica-acc")
%% end.rcode

\subsubsection{Média de complexidade ciclomática por método (ACCM)}

A Tabela \ref{metrica-accm} ...

%% begin.rcode metrica-accm, fig.align='center', results="asis"
% table = percentis_by_project("accm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica accm", "metrica-accm")
%% end.rcode

\subsubsection{Média do número de linhas de código por método (AMLOC)}

A Tabela \ref{metrica-amloc}...

%% begin.rcode metrica-amloc, fig.align='center', results="asis"
% table = percentis_by_project("amloc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica amloc", "metrica-amloc")
%% end.rcode

\subsubsection{Média do Número de Parâmetros por Método (ANPM)}

A Tabela \ref{metrica-anpm}...

%% begin.rcode metrica-anpm, fig.align='center', results="asis"
% table = percentis_by_project("anpm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica anpm", "metrica-anpm")
%% end.rcode

\subsubsection{Acoplamento entre objetos (CBO)}

A Tabela \ref{metrica-cbo}...

%% begin.rcode metrica-cbo, fig.align='center', results="asis"
% table = percentis_by_project("cbo")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica cbo", "metrica-cbo")
%% end.rcode

\subsubsection{Profundidade da árvore de herança (DIT)}

A Tabela \ref{metrica-dit}...

%% begin.rcode metrica-dit, fig.align='center', results="asis"
% table = percentis_by_project("dit")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica dit", "metrica-dit")
%% end.rcode

\subsubsection{Ausência de coesão em métodos (LCOM4)}

A Tabela \ref{metrica-lcom4}...

%% begin.rcode metrica-lcom4, fig.align='center', results="asis"
% table = percentis_by_project("lcom4")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica lcom4", "metrica-lcom4")
%% end.rcode

\subsubsection{Número de linhas de código (LOC)}

A Tabela \ref{metrica-loc}...

%% begin.rcode metrica-loc, fig.align='center', results="asis"
% table = percentis_by_project("loc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica loc", "metrica-loc")
%% end.rcode

\subsubsection{Número de atributos (NOA)}

A Tabela \ref{metrica-noa}...

%% begin.rcode metrica-noa, fig.align='center', results="asis"
% table = percentis_by_project("noa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noa", "metrica-noa")
%% end.rcode

\subsubsection{Número de filhos (NOC)}

A Tabela \ref{metrica-noc}...

%% begin.rcode metrica-noc, fig.align='center', results="asis"
% table = percentis_by_project("noc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noc", "metrica-noc")
%% end.rcode

\subsubsection{Número de métodos (NOM)}

A Tabela \ref{metrica-nom}...

%% begin.rcode metrica-nom, fig.align='center', results="asis"
% table = percentis_by_project("nom")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica nom", "metrica-nom")
%% end.rcode

\subsubsection{Número de atributos públicos (NPA)}

A Tabela \ref{metrica-npa}...

%% begin.rcode metrica-npa, fig.align='center', results="asis"
% table = percentis_by_project("npa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npa", "metrica-npa")
%% end.rcode

\subsubsection{Número de métodos públicos (NPM)}

A Tabela \ref{metrica-npm}...

%% begin.rcode metrica-npm, fig.align='center', results="asis"
% table = percentis_by_project("npm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npm", "metrica-npm")
%% end.rcode

\subsubsection{Resposta para uma classe (RFC)}

A Tabela \ref{metrica-rfc}...

%% begin.rcode metrica-rfc, fig.align='center', results="asis"
% table = percentis_by_project("rfc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica rfc", "metrica-rfc")
%% end.rcode

\subsubsection{Complexidade estrutural (SC)}

A Tabela \ref{metrica-sc}...

%% begin.rcode metrica-sc, fig.align='center', results="asis"
% table = percentis_by_project("sc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica sc", "metrica-sc")
%% end.rcode

\clearpage

\subsection{Métricas para as ferramentas da indústria}

%% begin.rcode metrica-acc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("acc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica acc", "metrica-acc-industria")
%% end.rcode

%% begin.rcode metrica-accm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("accm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica accm", "metrica-accm-industria")
%% end.rcode

%% begin.rcode metrica-amloc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("amloc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica amloc", "metrica-amloc-industria")
%% end.rcode

%% begin.rcode metrica-anpm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("anpm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica anpm", "metrica-anpm-industria")
%% end.rcode

%% begin.rcode metrica-cbo-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("cbo")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica cbo", "metrica-cbo-industria")
%% end.rcode

%% begin.rcode metrica-dit-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("dit")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica dit", "metrica-dit-industria")
%% end.rcode

%% begin.rcode metrica-lcom4-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("lcom4")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica lcom4", "metrica-lcom4-industria")
%% end.rcode

%% begin.rcode metrica-loc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("loc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica loc", "metrica-loc-industria")
%% end.rcode

%% begin.rcode metrica-noa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noa", "metrica-noa-industria")
%% end.rcode

%% begin.rcode metrica-noc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noc", "metrica-noc-industria")
%% end.rcode

%% begin.rcode metrica-nom-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("nom")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica nom", "metrica-nom-industria")
%% end.rcode

%% begin.rcode metrica-npa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npa", "metrica-npa-industria")
%% end.rcode

%% begin.rcode metrica-npm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npm", "metrica-npm-industria")
%% end.rcode

%% begin.rcode metrica-rfc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("rfc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica rfc", "metrica-rfc-industria")
%% end.rcode

%% begin.rcode metrica-sc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("sc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica sc", "metrica-sc-industria")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas academicas}

%% begin.rcode grafico-accessanalysis, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta accessanalysis"
% plot_lines_for_project("dataset/PAPERS/accessanalysis/AccessAnalysis-1.2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-bakar-ali, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta bakar-ali"
% plot_lines_for_project("dataset/PAPERS/bakar-ali/bakar-dev-20160415-002013.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-error-prone, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta error-prone"
% plot_lines_for_project("dataset/PAPERS/error-prone/error-prone-2.0.9.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-indus, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta indus"
% plot_lines_for_project("dataset/PAPERS/indus/indus.staticanalyses.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-inputtracer, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta inputtracer"
% plot_lines_for_project("dataset/PAPERS/inputtracer/valgrind-inputtracer.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jastadd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jastadd"
% plot_lines_for_project("dataset/PAPERS/jastadd/jastadd2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-source-meter, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta source-meter"
% plot_lines_for_project("dataset/PAPERS/source-meter/SonarQube-plug-in-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-srcml, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta srcml"
% plot_lines_for_project("dataset/PAPERS/srcml/srcML-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-tacle, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta tacle"
% plot_lines_for_project("dataset/PAPERS/tacle/tacle_1_2_1_src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wala, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wala"
% plot_lines_for_project("dataset/PAPERS/wala/WALA-R_1.3.8.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas da indústria}

%% begin.rcode grafico-boon-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta boon"
% plot_lines_for_project("dataset/NIST/boon/boon-1.0.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-clang-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta clang"
% plot_lines_for_project("dataset/NIST/clang/clang-tools-extra-3.7.1.src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-closure-compiler, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta closure-compiler"
% plot_lines_for_project("dataset/NIST/closure-compiler/compiler-latest.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cppcheck, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cppcheck"
% plot_lines_for_project("dataset/NIST/cppcheck/cppcheck-1.72.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cqual, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cqual"
% plot_lines_for_project("dataset/NIST/cqual/cqual-0.981.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-findbugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findbugs"
% plot_lines_for_project("dataset/NIST/findbugs/findbugs-3.0.1.analizo.metrics.dat")
%% end.rcode


%% begin.rcode grafico-findsecuritybugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findsecuritybugs"
% plot_lines_for_project("dataset/NIST/findsecuritybugs/findsecbugs-plugin-1.4.5-sources.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jlint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jlint"
% plot_lines_for_project("dataset/NIST/jlint/jlint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pixy, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pixy"
% plot_lines_for_project("dataset/NIST/pixy/pixy-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pmd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pmd"
% plot_lines_for_project("dataset/NIST/pmd/pmd-src-5.4.1.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-rats, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta rats"
% plot_lines_for_project("dataset/NIST/rats/rats-2.4.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-smatch, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta smatch"
% plot_lines_for_project("dataset/NIST/smatch/smatch.git.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-splint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta splint"
% plot_lines_for_project("dataset/NIST/splint/splint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-uno, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta uno"
% plot_lines_for_project("dataset/NIST/uno/uno.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wap, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wap"
% plot_lines_for_project("dataset/NIST/wap/wap-2.1.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas academicas}

%% begin.rcode grafico-lcom4, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas da indústria}

%% begin.rcode grafico-lcom4-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\section{Evolução inicial da ferramenta Analizo}\label{evolucao-analizo}

(pendente) ``apenas se der tempo''.

%\section{Resultados}
%
%%7- Nos resultados, teremos duas coisas: Referência dos valores frequentes e Aplicação do cálculo do score de similaridade
%
%(pendente) ``a caracterização das ferramentas dará indícios para documentar
%sugestões de refatoração para ferramentas de análise estática, estas sugestões
%serão aplicadas na refatoração do Analizo.''

\chapter{Conclusão}

(pentende) ``discutir as contribuições dando resposta ao que foi colocado na
introdução, fizemos isto, conseguimos estes resultados, e iremos fazer aquilo
nos proximos passos.''

\section{Limitações do trabalho}

(pendente)

\section{Trabalhos futuros}

(pendente)

\backmatter
\bibliography{bibliografia}
\appendix
\end{document}

% vim: filetype=tex
