\documentclass[qual, classic, a4paper]{ufbathesis}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage[alf]{abntex2cite}
\usepackage{graphicx}
%\usepackage{longtable}
\usepackage{multicol}
\DeclareGraphicsExtensions{.pdf}

\defenseyear{2016}
\date{08 de Julho de 2016}
\adviser[f]{Profa. Dra. Christina von Flach G. Chavez}
\coadviser{Prof. Dr. Paulo Roberto Miranda Meirelles}

\title{
  Caracterização da complexidade estrutural em ferramentas de análise estática
  de código-fonte
}

\author{Joenio Marques da Costa\\
  {\small joenio@joenio.me}
}

\begin{document}

\frontpage
\frontmatter
\presentationpage

\acknowledgements

(pendente)

\resumo

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\abstract

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\tableofcontents
\listoffigures
\listoftables

\mainmatter

%------------------------------------------%
\xchapter{Introdução}{}

%\section{Motivação}
%paulo: 1- Num primeiro momento, não precisa de uma subseção "motivação" na
%introdução, pois, acho que atrapalha a escrita. 

(pendente) ``segue abaixo uma proposta da motivação escrita de forma livre e
informal''.

{\it Eu, como um desenvolvedor de ferramenta de análise estática de
código-fonte, estou interessado em compreender a fundo este domínio de
aplicação, suas técnicas e limitações, bem como compreender o estado da arte
das ferramentas existentes na indústria e na academia, através da
caracterização de seus atributos de qualidade interna, a fim de ter
conhecimento suficiente para tomada de decisão sobre a evolução e manutenção
da minha própria ferramenta de análise estática, a ser realizada durante este
trabalho, com objetivo de melhorar seus atributos de qualidade interna.}

\section{Objetivos}

O objetivo principal deste trabalho é compreender as ferramentas de software
para análise estática de código-fonte, do ponto de vista de sua
manutenabilidade, a partir da análise de sua complexidade estrutural,
discutindo quais características arquiteturais explicam seus atributos de
qualidade interna.


Objetivos específicos:

\begin{itemize}
  \item Realizar uma revisão da literatura para conceituar análise estática de
    código-fonte.
  \item Selecionar e obter código-fonte de ferramentas de análise estática 
  desenvolvidas na academia, para coletar suas métricas de código-fonte. 
  A seleção terá como base o resultado de uma revisão estruturada feita 
  a partir de  artigos publicados em conferências relacionadas. 
  \item Selecionar e obter o código-fonte de ferramentas de análise estática
    desenvolvidas pelo indústria, para coletar suas métricas de
    código-fonte.
  \item Propor intervalos de referência  para a observação parametrizada da
    qualidade interna das ferramentas de análise estática, a partir de suas
    métricas de código-fonte.
  \item Calcular a distância Bayesiana entre valores de referência e os valores
    das ferramentas estudadas.
  \item Aplicar a abordagem em um estudo para avaliação de  uma ferramenta de análise de código-fonte.
\end{itemize}


Questões de pesquisa:
\begin{itemize}
\item O que?
\item Como?

\end{itemize}

\section{Contribuições esperadas}

Ao final deste trabalho, as seguintes
contribuições científicas ({\bf CC}) e tecnológicas ({\bf CT}) 
são esperadas:

\begin{enumerate}
  \item [{\bf CC1:}] Um conjunto de intervalos de referência da frequência dos
    valores de métricas de código-fonte para o domínio de ferramentas de
    análise estática.
  \item [{\bf CC2:}] Explicação da alta complexidade estrutural em ferramentas de
    análise de código-fonte.
  \item [{\bf CT1:}] Evolução de uma ferramenta de análise de código-fonte.
\end{enumerate}

%Lembrar que:
%Neste trabalho, são utilizadas métricas de produto, especificamente,
%métricas de código-fonte, que cobrem aspectos
%de tamanho, complexidade e qualidade, que podem ser medidos a partir 
%do código-fonte de um software, ao longo de sua evolução no tempo.


\section{Estrutura do texto} 

O capítulo ...

O capítulo ... A seção~\ref{revisao-estruturada}) ...

%-----------------------------------------------------%
\xchapter{Fundamentação Teórica}
{Este capítulo apresenta conceitos necessários para a compreensão do trabalho.}

A análise estática de código é o primeiro passo para coletar informações
necessárias para diversas atividades de verificação, medição e melhoria da
qualidade de produtos de software \cite{Cruz2009} \cite{Kirkov2010}.

A análise estática de código é realizada com base apenas no código-fonte de um
programa ou sistema de software, para descobrir problemas e propriedades de
sua qualidade estrutural \cite{Chess2007}.

Ferramentas de análise estática estão disponíveis há decadas, em especial,
para programadores. A ferramenta Lint \cite{Johnson1978}, considerada a
primeira ferramenta de análise estática \cite{Gosain2015}, é uma ferramenta
para examinar programas escritos em linguagem C com a capacidade de aplicar
regras de tipagem mais estritas do que os próprios compiladores
da linguagem.

% \cite{Li2010} cita FlexeLint como a primeira ferramenta de análise estática

Neste trabalho, ... 
interesse em ferramentas de análise estática de código para desenvolvedores.

Neste trabalho o nosso interesse reside em compreender características de
qualidade interna de ferramentas de análise estática de código-fonte do ponto
de vista do desenvolvedor interessado em manter e evoluir tais ferramentas
melhorando seus atributos de qualidade interna.

A seção \ref{sec:analise} apresenta a definição de análise estática de
código-fonte e suas principais aplicações; A seção \ref{sec:anatomia} descreve
a anatomia comum da análise de código-fonte em suas partes básicas. A seção
\ref{formatos} traz uma breve descrição dos formatos de representação interna
mais comuns. A seção \ref{tecnicas} apresenta as técnicas e métodos mais
comuns de análise. A seção \ref{metricas} traz definição de métricas de
software, secao \ref{metricas-de-codigo} apresenta as métricas utilizadas neste
estudo. (pendente capitulo sobre estatistica).

\section{Análise estática de código-fonte} \label{sec:analise}

Análise estática de código-fonte é um ramo da engenharia de software voltado a
obter informações acerca de um programa a partir do seu código-fonte sem
necessidade de execução, e sem requerer qualquer outro artefato do programa
além do próprio código.
É considerada uma atividade meio com objetivo de
suportar uma variedade de tarefas comuns da engenharia de software; 
muitas dessas tarefas são substancialmente úteis em atividades de manutenção.
Binkley \citeonline{Binkley2007}
define uma extensa lista dessas atividades, segue abaixo um sub-conjunto delas.

\begin{multicols}{2}
  \begin{itemize}
    \item recuperação arquitetural
    \item detecção de clones
    \item compreensão de programas
    \item pesquisa em engenharia de software empírica
    \item localizaçao de falhas
    \item desenvolvimento baseado em modelos
    \item análise de performance
    \item evolução de software
    \item garantia de qualidade
    \item engenharia reversa
    \item manutenção de software
    \item versionamento de software
    \item testes
    \item ferramentas e ambientes
    \item desenvolvimento de aplicações web
  \end{itemize}
\end{multicols}

Seja em qual atividade for, a análise estática possui uma importância
significativa, pois ao ser capaz de extrair informações diretamente do
código-fonte de um programa, pode auxiliar a responder com precisão a seguinte
pergunta: ``O que é que este programa significa?''

\subsection{Usos da análise estática de código-fonte}

A análise de programas trata, de modo geral,
da descoberta de problemas e fatos sobre programas. 
Tal análise por ser realizada sem necessidade de executar o programa
(análise estática) ou com informações provenientes de sua execução (análise dinâmica).

A idéia de que programas de computador podem ser utilizados para analisar
código-fonte de outros programas tem uma história de mais de 40 anos. 
O programa PFORT \cite{Ryder1974} foi projetado para localizar potenciais
problemas na portabilidade de código Fortran; em função da diversidade de
dialetos de Fortran, uma compilação sem erros não indicava
que o programa estava correto segundo os padrões da linguagem
\cite{Wichmann1995}.

Desde então, ferramentas de análise estática de código-fonte
têm surgido para os mais diversos fins 
-- muitas delas a partir de pesquisa e desenvolvimento na área de compiladores. 
O {\it parser} utilizado nessas ferramentas têm funcionalidades análogas
aos analisadores usados em compiladores \cite{Anderson2008}.

O uso de ferramentas de análise estática de código-fonte têm 
se tornado mais e mais comum no ciclo de desenvolvimento de software.
O campo de aplicação destas ferramentas é bastante variado, 
cobrindo diferentes objetivos. Dentre as atividades em que a análise
estática de código-fonte é usada \cite{Chess2007}, destacam-se:

\begin{description}
    \item \textit{Verificação de tipos}. 
A forma mais amplamente utilizada de análise estática, 
e uma das quais os programadores estão mais familiarizados, 
é a checagem de tipo. Programadores
dão pouca atenção a isto, visto que as regras são
definidas pela linguagem de programação e executadas pelo próprio compilador,
de forma que não se torna necessário entender como a análise acontece.
No entando, esta atividade de verificação é análise estática e elimina
toda uma categoria de erros de programaçao. Por exemplo, previne que
programadores acidentalmente atribuam valores de forma incorreta a variáveis.
Ainda, ao capturar erros em tempo de compilação, esta checagem de tipo previne
erros em tempo de execução.
    \item \textit{Verificação de estilo}. 
Os verificadores de estilo são um tipo de análise estática que aplicam regras
de forma mais superficial do que os verificadores de tipo. São regras
relacionadas a espaços em branco, nomes, funções depreciadas, comentários,
estrutura do programa, entre outros.  A maioria dos verificadores de estilo
costumam ser bem flexíveis quanto ao conjunto de regras que aplicam uma vez
que os programadores costumam ser bastante apegados aos seus próprios estilos
de programação. Os erros reportados por verificadores de estilo
são aqueles que afetam a leitura e a manutenabilidade do código-fonte, não
indicando potenciais erros em tempo de execução como fariam os verificadores
de tipo.
    \item \textit{Compreensão de programas}. 
Ferramentas de compreensão de programa ajudam programadores a terem uma visão
clara frente a grandes programas de computador, ou seja, programas com alto
volume de código-fonte. Ambientes de desenvolvimento integrados (IDE)
geralmente incluem funcionalidade de compreensão, por exemplo,
``encontrar todos os usos de um certo método'' ou ``encontrar
a declaração de uma variável global''. Análises mais avançadas chegam a
incluir, por exemplo, refatoração automática. Estas ferramentas de
compreensão também são úteis para programadores interessados
em entender código-fonte escrito por outros programadores.
    \item \textit{Verificação programas}. 
Ferramentas de verificação de programa aceitam como entrada uma especificação
e um conjunto de código-fonte e tenta provar que o código está deacordo com a
especificação. Quando a especificação é uma descrição completa de todo o
programa, a ferramenta de verificação poderá realizar uma checagem de
equivalência para garantir que o código-fonte e a especificação combinam de
forma exata. Programadores raramente tem acesso a uma especificação detalhada
suficientemente para ser usada numa checagem de equivalência, o trabalho de
criar esta especificação pode ser maior do que o trabalho de escrever o
próprio código-fonte do programa, desta forma este tipo de verificação formal
raramente acontece. Sendo mais comum a verificação em relação a uma
especificação parcial que detalha apenas parte do comportamento do programa.
Isto costuma ser chamado de verificação de propriedade, grande parte das
ferramentas de verificação de propriedade funcionam aplicando inferências
lógicas ou verificação de modelos.
    \item \textit{Localização de bugs}. 
O propósito de uma ferramenta de localização de bugs não está em questões de
formatação, como é a verificação de estilo, nem em realizar uma exaustiva e
completa comparação contra uma especificação, como uma ferramenta de
verificacao de programa. Ao invés disso, um localizador de bugs está
preocupado em apontar locais onde o programa, possivelmente, irá se comportar
de forma inesperada. A maioria das ferramentas de localização de bugs são
fáceis de usar porque costumam vir com um conjunto de regras (bug idioms) para
descrição de padrões de código que indicam bugs. Algumas destas ferramentas
costumam usar os mesmos algoritmos utilizados por ferramentas de verificação
de propriedade.
    \item \textit{Avaliação de segurança}. 
Ferramentas de análise estática para segurança usam as mesmas técnicas
encontradas nas outras ferramentas, mas por ter um propósito diferente, identificar
problemas de segurança, aplicam estas técnicas de forma diferente. As
primeiras ferramentas de segurança (ITS4, RATS, Flawfinder) eram pouco mais do
que um ``grep'' melhorado; na maior parte, elas escaneavam o codigo procurando
por funcoes como por exemplo ``strcpy()'' que sao facilmente usadas de forma
inadequada e devem ser inspecionadas manualmente no processo de revisao de
código-fonte. Mas a evolução deste tipo de ferramenta de segurança levou a
utilizarem técnicas híbridas de verificação de propriedade e de localização de
bugs. De forma que muitas propriedades de segurança podem ser suscintamente
expressas como propriedades de programas.
  \end{description}

%Para um property checker, buscas potenciais
%vulnerabilidades de buffer overflow podem ser feitas como a checagem da
%propriedade "este prorama nao acessa um endereco fora dos limites de memoria
%alocados". Para o dominio de localizacao de bugs, ferramentas de seguranca
%adoram a nocao que desenvoovedores continuam recintando o mesmo metodo
%inseguro para resolver um problema, o que pode ser descrito como um idiome
%inseguro de programacao.
%Neste sentido, estas ferramentas estao talvez mais
%perto relacionadamente com verificadores de estilo - o que elas apontam nao
%necessariamente podem causar problemas de segurança, mas indicam que há razões
%para preocupar-se com problemas de segurança. 
%Ao longo do tempo estas
%ferramentas foram indicadas por terem alto indice de falso positivos porque
%pessoas tentavam interpretas a saida da ferramenta como uma lista de bugs ao
%inves de uma ajuda/apoio durante a revisao de codigo. 

\subsection{Anatomia da análise de código-fonte} \label{sec:anatomia}

Ferramentas de análise estática de código-fonte estão organizadas em 
partes ou componentes, responsáveis por implementar 
três funções básicas \cite{Cruz2009} \cite{Binkley2007}: 
a) extração de dados, b) geração de representação interna, e c) análise. 
A ferramenta de análise de código-fonte
CodeSonar\footnote{https://www.grammatech.com/products/codesonar}
segue tal organização, conforme mostra 
a Figura \ref{static-analysis-representation}.

\begin{figure}[h]
  \center
  \includegraphics[scale=0.4]{imagens/static-analysis-representation.png}
  \caption{CodeSonar: Representação da Análise Estática \cite{GrammaTech2016}}
  \label{static-analysis-representation}
\end{figure}

%As seções a seguir detalham estes componentes.

\begin{description}
\item \textit{Extração de dados}.

O processo de recuperar dados para futuro processamento ou armazenamento é
chamado de extração de dados. 

O primeiro componente da análise de código-fonte é a extração de dados,
responsável por ler o código-fonte do programa e gerar uma ou mais
representações internas para ele. 
Em essência, este componente converte a sintaxe de um
programa em uma outra sintaxe abstrata e mais adequada para análise posterior.
Este componente é usualmente chamado de analisador sintático (ou {\it parser}).
Apesar de teoricamente não ser uma tarefa difícil, a
complexidade das linguagens de programação modernas podem dificultar
a análise de código-fonte.

\item \textit{Representação interna}.

Exportar os dados extraídos para uma representação intermediária 
é uma estratégia comum para facilitar análise e transformação de
dados e possivelmente adição de metadados.

Os dados obtidos na extração precisam ser representados em um
formato mais abstrato. 
Esta é a responsabilidade do segundo componente da
análise de código-fonte: 
armazenar os dados coletados usando uma representação
interna em formato mais adequado para análise automática, 
abstraindo aspectos particulares do programa e da linguagem de programação.

Alguns tipos de representação interna têm sua origem na área de
compiladores; algumas delas são produzidas diretamente pelo {\it parser}
enquanto outras requerem uma análise específica. 
Os formatos mais comuns são baseados em grafos. 

Alguns formatos comumente utilizados são:
\begin{multicols}{2}
  \begin{itemize}
    \item Identifiers Table
    \item Abstract Syntax Tree (AST)
    \item Decorated Abstract Syntax Tree (AST)
    \item Control Flow Graph (CFG)
    \item Call Graph
    \item Value Dependence Graph (VDG)
    \item Module Dependence Graph (MDG)
    \item Trace Flow Graph (TFG)
    \item Static Single Assignment (SSA)
  \end{itemize}
\end{multicols}
  
Estas representações podem ser utilizadas tanto na análise estática quanto na
análise dinâmica.
O uso de um ou outro formato depende do tipo de análise e
seu propósito. Pode-se combinar diferentes tipos no
sentido de enriquecer e estruturar a informação extraída.

\item \textit{Análise}.

O componente da análise de código é responsável por realizar inferências 
a partir dos dados representados internamente. 
Este processo requer que as informações armazenadas estejam interconectadas e também
interrelacionadas com conhecimento anterior. 
Esta análise pode gerar conhecimento quantitativo ou qualitativo, 
como, por exemplo, métricas de software ou mineração de dados, respectivamente. 
Técnicas de visualização podem ser usadas para a apoiar este processo.

A análise pode ser categorizada segundo seis dimensões básicas: 
\begin{itemize}
\item estática versus dinâmica, 
\item sound versus unsound, 
\item segura vesus insegura, 
\item sensível ao fluxo (``which values a variable may have at each program point?'')
versus insensível ao fluxo (which variables can be accessed by a code?''),
\item sensível ao contexto (``different solutions are computed for different chains of callers'') versus 
insensível ao contexto (``a single solution is computed for each function, no matter who calls the function''),\item complexidade. %precision vs effort
\end{itemize} 

Estas características da análise vão afetar o resultado gerado quanto a
confiabiliade, completude, garantia de precisão, eficiência, performance,
complexidade computacional, precisão da informaçao, entre outras.

\end{description}

%\section{Teoria da análise estática}
%
%(falar de falso positivos / negativos)
%
%(Tools that are sound with respect to a counterexample are sometimes called
%complete in academic circles.)
%
%Existem diferentes técnicas de análise estática de código-fonte, que variam desde
%simples análises léxicas, análises de fluxo de dados até a análise de grafos de fluxo de con-
%trole. Ao apontar defeitos no código, uma ferramenta de análise estática pode ou não
%cometer erros quando analisando determinado trecho de código, dada a natureza do
%defeito ali presente (ou ausência de defeitos) e à técnica de análise empregada. Al-
%gumas técnicas são menos complexas e estão mais suscetíveis a erros do que outras
%(KRATKIEWICZ, 2005). Ainda assim, cada uma das técnicas de análise estática tem
%suas limitações (CUOQ; KIRCHNER; YAKOBOWSKI, 2012), o que justifica o uso de e
%a busca por diferentes técnicas de análise.
%
%Como definido em (BLACK et al., 2007), chama-se falso positivo, ou alarme
%falso, um trecho de código apontado como defeituoso por uma ferramenta de análise
%estática que, na verdade, não se trata de um defeito, ou seja, a ferramenta cometeu
%um erro ao apontar um trecho de código não defeituoso como defeituoso. Chama-se falso
%negativo um defeito no código fonte, que se enquadra na categoria de defeitos detectados
%pela ferramenta que analisa o código em questão, que não foi detectado pela ferramenta,
%ou seja, a ferramenta cometeu um erro ao não apontar um trecho de código defeituoso.
%Uma ferramenta ideal não cometeria erros, apontando todos os defeitos do código
%(mesmo que apenas em uma dada categoria) e nunca apontando um trecho de código
%correto como defeituoso (a ferramenta não comete falsos positivos nem falsos negativos).
%Trabalhos anteriores mostram que é impossível, mesmo em teoria, produzir tal ferramenta
%(BLACK et al., 2007) devido ao Teorema de Rice (RICE, 1953), que prova que para
%qualquer propriedade de software que não seja trivial, não existe algoritmo capaz de decidir
%se um programa qualquer possui tal propriedade, de modo que buscam-se aproximações
%para a solução de problemas ou tomadas de decisões relacionadas à análise estática. É
%possível, porém, produzir ferramentas capazes de cometer apenas um dos tipos de erro
%(falsos positivos ou falsos negativos). À análise estática que não gera falsos negativos, ou
%seja, aponta todos os defeitos no código, chamamos análise correta. À análise estática
%que não gera falsos positivos, ou seja, todos os possíveis defeitos apontados por ela são
%de fato trechos de código defeituosos, chama-se análise completa. Por fim, pode-se
%relacionar os termos com os Teoremas de Incompletude (GODEL et al., 1986), de modo
%que não é possível realizar uma análise completa e correta.

\subsection{Formatos de representação interna} \label{formatos}

(pendente) ``falar sobre os formatos citados anteriormente, mostrar os usos
comuns destes formatos''.

Observação (Chris):
Algumas dessas RIs são necessárias para calcular alguns tipos de métricas.
Às vezes há alguns workarounds em ferramentas, em
geral, dependentes de linguagem.


Por exemplo,
Uma métrica pode ser definida com base em informações disponíveis em uma dada representação interna.
A métrica de complexidade ciclomática de McCabe [REF] é definida com base
no grafo de fluxo de controle (CFG) do programa.

\begin{verbatim}
CC = e - n + 2p, onde e é o número de arestas, n é o número de nós e p é i número
de componentes fortemente conectados no grafo CFG.
\end{verbatim}


Mas algumas ferramentas implementam a métrica de outra forma.
\begin{verbatim}
NDepend:

CC = 1 + {number of the following expressions found in a method} :
if|while|for|foreach|case|default|continue|goto|&&| etc.

\end{verbatim}


%Control and Dataflow Analysis
%
%One representation that is widely used in formal methods for optimizing and verifying source code
%is that of Control Flow Graphs (CFG). In a CFG, each node represents a basic bloc of code, i.e.
%lines of code that will not be executed independently during normal program execution. In other
%words, the nodes do not contain any jumps or labels (jump targets). The jumps are represented by
%directed edges. Usually CFG implementations have two special nodes: the “entry point”, which is
%the starting point of the execution; and the “exit point”, where the execution exits the graph.


\subsection{Técnicas de análise} \label{tecnicas}

Inúmeras técnicas e métodos distintos podem ser utilizados pelas ferramentas
de análise estática, seja com o objetivo de verificação de tipos, localização
de bugs, compreensão de programas, avaliação de segurança, ou outra finalidade
qualquer. Tais técnicas estão relacionadas à análise propriamente dita.
Segundo \citeonline{German2003}, \citeonline{Li2010}, \citeonline{Hofer2010}
as técnicas e métodos mais comumente encontradas nas ferramentas atuais são:

% análise de fluxo de dados, erros de runtime (divisão por zero, overflows, etc.), 
% análise de impacto, medições, identificação de \textit{code smells},  e reengenharia de software.

\begin{description}
\item \textit{Análise léxica.}
A análise léxica é responsável por 
quebrar o programa em pequenos fragmentos (ou tokens) e
verificar se estes tokens são palavras válidas para uma dada linguagem.
A análise léxica não leva em consideração a sintaxe do programa, sua
semântica ou a interação entre módulos.


\item \textit{Text-based Pattern Matching.}
Combinação de padrões de texto é a maneira mais simples e rápida de procurar
vulnerabilidades num código fonte.

\item \textit{Type inference.}
Inferência de tipos refere-se a inferir o tipo de variáveis
e funções através do compilador, e avaliar se o acesso a variáveis e funções
está em conformidade com as regras. Linguagens de programação com sistema de
tipagem incluem mecanismos para definição de tipos de dados e conjunto de
regras para tipagem.

\item \textit{Data flow analysis.} 
Análise de fluxo de dados resume-se a coletar informação semântica do
código-fonte do programa, e com métodos algébricos deduzir a definição e uso
das variáveis em tempo de compilação. O objetivo é mostrar que nenhum caminho
de execução no programa acessa uma variável sem definição prévia de valor.

%Esta pode ser uma atividade
%complexa, como variaveis globais podem ser acessadas de qualquer lugar. Esta
%analise tb pode detectar outras anomalias como multiplas gravacoes sem
%leitura.
%Com o uso de Control
%Flow Graph a análise de fluxo de dados determina se um valor no programa é
%atribuído para uma possível vulnerabilidade de variáveis.

%\item \textit{Control Flow Analysis.}
%
%CFA - Control Flow Analysis (Controle de Análise de Fluxo) (incluindo Complexidade Ciclomática)
%
%CFA pode ser conduzida usando ferramentas ou manualmente sob varios niveis de
%abstracao (modulo, nó, etc) e é pelos seguintes razões:
%
%Garantir que o código é executado na sequencia correta
%Garantir que o código é bem estruturado
%Localizar qualquer código sintaticamente não atingivel
%Destacar partes do código (ex loops) onde o termino precisa ser considerado
%
%Isto pode resultar em representacoes diagramas e graficos do codigo sendo
%produzido.
%
%Interprocedural analysis is fairly straightforward in a language with only first-
%order functions. If we introduce higher-order functions, objects, or function
%pointers, then control flow and dataflow suddenly becomes intertwined. The
%task of control flow analysis is to approximate conservatively the control flow
%graph for such languages.
%\cite{Schwartzbach2008}

\item \textit{Rule checking.}
Verificação de regra é checar a segurança do programa usando regras de
segurança pré-estabelecidas. Existe algumas regras de segurança no projeto do
programa, tal como nos privilégios de ``root'' se o programa chama a função
``exec'' isto vai trazer implicações de segurança.

\item \textit{Constraint analysis.}
Análise de restrição é dividida em geração de restrição e resolução de
restrição no processo de análise de programa. Geração de restrição significa
estabelecer tipos de variáveis ou analisar limitações do sistema entre
diferentes estados usando as regras de geração de restrição; resolução de
restrição é para resolver as restrições do sistema.

\item \textit{Patch comparison.}
Comparação patch inclui comparação de patch de código-fonte e comparação patch
de código-binário, e é usado principalmente para encontrar brechas
"conhecidos". Após as vulnerabilidades de segurança do programa serem
encontradas, os fabricantes normalmente lançam patches correspondentes, assim
você pode comparar o código com os patches para determinar a localização e as
causas da vulnerabilidade.

\item \textit{Symbolic execution.}
% (Path Function Analysis or Also Called Semantic Analysis)
Execução simbólica é para representar as entradas do programa através do uso de
valores simbolicos ao invés de dados reais, e produz expressões algébricas
sobre a entrada de símbolos no processo de implementação. Pelo método de
resolução de restrição de execução simbólica pode detectar possibilidade de
erros.

Usada para verificar propriedades de uma programa através de manipulacao
algebrica do codigo fonte, sem requerer especificacao formal. Envolve checar
semantica de cada caminho atraves secoes do programa ou precedimentos.
Ferramentas sofisticadas dao expressoes para uma precisa relacao matematica
entre as entradas e saidas de uma secao particular do programa: Ele
efetivamente da a funcoes de transferir para esta secao do programa. Ele passa
pelo codigo, associado expressoes ao inves de valores para cada variavel.
Entao a logica sequencial é convertida em um conjunto de associacoes paralelas
que os valores de saida sao expresso em termos de valores de entrada - este
formato eh facil de interpretar. Ferramentas produzem saida para cada caminho
cosistindo de condicoes que causa o caminho ser executado, e o resultado da
execucao do caminho.

\item \textit{Abstract interpretation.}
Interpretação abstrata é uma descrição formal da análise do programa. Pelo
fato de apenas controlar atributos de programa de preocupaçao dos usuários, a
interpretação da análise semântica é similar ao seu significado semantico
real.

\item \textit{Theorem proving.}
Prova de teoremas é baseada na análise semantiva do programa, e pode resolver
problemas de ``infinite state systems''. Prova de teoremas primeiro converte o
programa em fórmulas de lógica, então prova que o programa é um teorema válido
usando axiomas e regras.

\item \textit{Model checking.}
O processo de verificaçao de modelos primeiro contrói um modelo formal do
programa tal como uma máquina de estado ou grafo direcionado, então examina e
compara o modelo para verificar se o sistema cumpre as características
pré-definidas. Se verificação de modelos realmente se encaixa na categoria de
análise de código fonte automática é discutível.  Na verdade, esta técnica
requer a definição e descrição das propriedades que devem ser verificados por
um pedaço de software, na maioria das vezes em um formato específico
ferramenta. No entanto, uma vez que esta especificação foi estabelecida
nenhuma entrada humana adicional é necessário para realizar a análise.

\item \textit{Formal Checking.}
% Verificacao formal (Also Called Compliance Analysis)
É o processo de prover, num processo automatizado, que o codigo do programa eh
correto em respeito a uma especificacao formal dos seus requisitos. Todas as
possibilidades de execucao sao exploradas, o que n eh possivel via teste
dinamico somente. Dependendo do poder da ferrmente sendo usada, e sua
habilidade de simplificacao, o  envolvimento da analise pode ser alto ou
baixo.

%Compliance analysis effectively performs a proof of the code against a
%lowlevel mathematical specification. In this respect, it is by far the most
%rigorous of the static analysis techniques.

\item \textit{Information Flow Analysis.}
Identifica como execução de uma unidade de código cria dependência entre
entradas e saídas. Estas dependências podem ser verificadas contra as
dependências da especificação. Esta análise é frequentemente apropriada para
uma saída crítica que pode ser rastreada de volta às entradas da interface do
programa.

\item \textit{Syntax Checks.}
Verificação de sintaxe tem o objetivo de encontrar regras de violação de
linguagem tais como a utilizaçao de uma variável de tipo incorreto ou antes de
ser declarada. Os compiladores de algumas linguagens como Ada e Pascal
realizam checagem de sintaxe automaticamente, enquanto que linguagens como C e
assembler precisam de ferramentas adicionais.

\item \textit{Range Checking.}
Análise de verificação de intervalo tem objetivo de verificar que os valores
dos dados permanecem dentro de intervalos especificados, bem como manter a
precisão especificada. Esta técnica pode detectar: Overflow and underflow
analysis, Rounding errors, Array bounds, Stack usage analysis.

%Tools Available
%There are a number of static code analy-
%sis tools available. They offer different
%depths of analysis, and some will only
%operate on a few languages. Most of
%them run on uncompiled source code
%and first translate to an intermediate lan-
%guage, which the analysis tool itself can
%read.
%The time taken for the tool to analyze
%the code may be only a small fraction of
%the time taken to carry out static analysis
%of the code. Many tools produce reams
%of data that must be laboriously analyzed
%and processed; staff requires skill and a
%lot of training.

\end{description}


%--------------------------------------%
\section{Métricas de software} \label{metricas}

No glossário de terminologia para engenharia de software\footnote{IEEE-STD-610.12-1990 Glossary of Software Engineering Terminology} do IEEE \cite{ieee1990ieee}, 
a qualidade de software é definida como 
(1) o grau em que um sistema, componente ou processo atende a requisitos especificados e 
(2) o grau em que um sistema, componente ou processo atende às necessidades ou expectativas
de um usuário. 

%Segundo o padrão ISO/IEC 25010 \cite{iso2011iec25010}, 
%uma métrica é a composição de procedimentos para a definição de 
%escalas e métodos para medição.

Segundo o padrão para metodologia de qualidade de métricas de software\footnote{IEEE-STD-1061-1998 Standard for Software Quality Metrics Methodology} do IEEE,
uma métrica de qualidade de software é 
``uma função cujas entradas são dados de software e cuja saída é um valor numérico,
que pode ser interpretado como o grau em que um software''
 ( .. sistema, componente ou processo ... ) 
``possui um determinado atributo que afeta sua qualidade'' \cite{software1998ieee}.

%Metrics make a statement about some quality attributes, are quantitative, 
%but will have to be interpreted by a human.

Métricas de software podem ser classificadas em
métricas de processo, métricas de projeto e métricas de produto.

Métricas de processo medem atributos relacionados ao ciclo de
desenvolvimento e manutenção de software.
Métricas de projeto indicam se a execução do processo
está progredindo conforme planejado 
(por exemplo, relação entre o tamanho do software entregue 
e o esfoço total dispendido em seu desenvolvimento).
%descrevem características dos recursos disponíveis ao desenvolvimento.

Métricas de produto medem atributos de produtos e artefatos
(documentos, diagramas, código-fonte e arquivos binários) 
desenvolvidos. 
Neste trabalho, apenas métricas de produto serão utilizadas.

Métricas de produto podem ser classificadas em 
internas (medem propriedades visíveis apenas aos desenvolvedores)
ou externas (medem propriedades visíveis aos usuários) \cite{Mohamed1994}.

Neste trabalho, são utilizadas métricas de produto e,
especificamente, métricas de código-fonte,
que cobrem aspectos de tamanho, complexidade e qualidade que podem ser medidos
a partir do código-fonte de um software.
%, ao longo de sua evolução no tempo.

\subsection{Métricas de código-fonte} \label{metricas-de-codigo}

As propriedades visíveis aos desenvolvedores podem ser medidas através de
métricas de código-fonte.
A observação e o monitoramento de seus valores podem indicar aspectos relevantes à
manutenibilidade de um programa. 
Dentre as inúmeras métricas de código-fonte
iremos destacar aquelas utilizadas no estudo de \citeonline{Meirelles2013}
onde associou-se características de qualidade de produto de software a
características de qualidade de código-fonte através da observação de
suas métricas.

\begin{itemize}
  \item {\bf ACC} {\it Aferent Connections per Class (Conexões aferentes de
    uma classe)}: Mede a conectividade de uma classe. [REF]
  \item {\bf ACCM} {\it Average Cyclomatic Complexity per Method (Média de
    complexidade ciclomática por método)}: mede a complexidade do programa
    \cite{McCabe1976}.
  \item {\bf AMLOC} {\it Average Method LOC (Média do número de linhas de
    código por método)}: indica se o código está bem distribuído entre os
    métodos, quanto maior mais ``pesados'' são os métodos. [REF]
  \item {\bf ANPM} {\it Average Number of Parameters per Method (Média do
    Número de Parâmetros por Método)}: calcula a média de parâmetros dos
    métodos da classe \cite{Jagdish1997}.
  \item {\bf CBO} {\it Coupling Between Objects (Acoplamento entre objetos)}:
    mede o acoplamento entre objetos do software \cite{Chidamber1994}.
  \item {\bf DIT} {\it Depth of Inheritance Tree (Profundidade da árvore de
    herança)}: mede o número de ancestrais de uma classe \cite{Shih1997}.
  \item {\bf LCOM4} {\it Lack of Cohesion in Methods (Ausência de coesão em
    métodos)}: mede o grau de falta de coesão em métodos \cite{Hitz1995}.
  \item {\bf LOC} {\it Lines of Code (Número de linhas de código)}: mede o
    número de linhas excluindo linhas em branco e comentários. [REF]
  \item {\bf NOA} {\it Number of Attributes (Número de atributos)}: calcula o
    número de atributos de uma classe. [REF]
  \item {\bf NOC} {\it Number Of Children (Número de filhos)}: número total de
    filhos de uma classe \cite{Rosenberg1997}.
  \item {\bf NOM} {\it Number of Methods (Número de métodos)}: mede o tamanho
    das classes em termos das suas operações implementadas. [REF]
  \item {\bf NPA} {\it Number of Public Attributes (Número de atributos
    públicos)}: mede o encapsulamento. [REF]
  \item {\bf NPM} {\it Number of Public Methods (Número de métodos públicos)}:
    representa o tamanho da ``interface'' da classe. [REF]
  \item {\bf RFC} {\it Response For a Class (Resposta para uma classe)}:
    número de métodos dentre todos os métodos que podem ser invocados em
    resposta a uma mensagem enviada por um objeto de uma classe
    \cite{Sharble1993}.
  \item {\bf SC} {\it Structural Complexity (Complexidade estrutural)}: mede a
    complexidade do software \cite{Darcy2005}.
\end{itemize}

\subsection{Complexidade estrutural}

A complexidade estrutural (SC - Structural Complexity) de um programa
é uma medida calculada através da combinação das
métricas de acoplamento (CBO) e coesão (LCOM4).
Esta medida é, possivelmente, um indicativo de problemas 
na manutenibilidade de sistemas de software, em
especial sobre o esforço necessário para atividades de manutenção
\cite{Terceiro2012}. Ela está relacionada a como os módulos de um programa
estão organizados bem como à estrutura interna de cada módulo.

Esta métrica pode dar indícios importantes sobre características arquiteturais
de um programa de software, e pode explicar seus atributos de qualidade
interna.


\subsection{Ferramentas para cálculo de métricas de código-fonte}

%* qual a diferenca entre um analisador, um compilador, tradutor, etc...

(pendente) ``fazer link com métricas para entrar na próxima seção''.
Referencias: \cite{Kratkiewicz2005} \cite{Black2007} \cite{Emanuelsson2008}
\cite{Chelf2008} \cite{Wedyan2009} \cite{Novak2010} \cite{Johns2011}
\cite{Alemerien2013} \cite{Ataide2014}.


\section{Pensar em título - fundamentos de matemática e estatística}

\subsection{Distância Bayesiana}
\subsection{etc}

%------------------------------------------------------%
\xchapter{Metodologia}{}


Seção~\ref{trabalhos-relacionados}

Seção~\ref{hipoteses}

Seção~\ref{sec:metod:planejamento}

Seção~\ref{sec:metod:coleta}

Seção~\ref{sec:metod:analise}



\section{Trabalhos relacionados}\label{trabalhos-relacionados}

%4- Os trabalhos relacionados, num primeiro momento, devem ser colocados na
%primeira subseção da metodologia, para fazer um ganho com o que tem diferente
%deste trabalho, levando às hipóteses na seção seguinte. Antes de falar dos
%trabalhos relacionados, deve-se ter uma introdução no capítulo de metodologia
%resgatando o problema tratado pelo trabalho e que tem estudos da área etc
%etc...

(pendente)

\section{Hipóteses} \label{hipoteses}

Para guiar os estudos, conforme os objetivos acima, definimos as seguintes
hipóteses:

\begin{enumerate}
  \item[{\bf H1:}] {\em É possível calcular valores de referência de métricas
    de código-fonte para ferramentas de análise estática a partir de um
    conjunto de softwares da academia e da indústria}
  \item[{\bf H2:}] {\em Ferramentas de análise estática tendem a ter uma
    maior complexidade estrutural do que ferramentas de outros domínios de
    aplicação}
  \item[{\bf H3:}] {\em Dentre as ferramentas de análise estática de
    código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
    complexidade estrutural}
\end{enumerate}

A hipótese {\bf H1} será validada a partir da análise das métricas calculadas
para cada uma das ferramentas estudadas.
Esta análise levará em consideração a caracterização das ferramentas 
(Seção~\ref{caracterizacao-das-ferramentas}), em especial, um subconjunto das
ferramentas com melhores valores de métricas.

A hipótese {\bf H2} será validada a partir da comparação com os trabalhos
relacionados (Seção \ref{trabalhos-relacionados}) que 
realizaram estudos similares, com cálculo e distribuição de métricas,
e utilizando conjunto ferramentas distinto do estudado aqui.

A hipótese {\bf H3} será validada a partir do cálculo da distância das
métricas de cada ferramenta com os valores de referências encontrados neste
estudo (Seção \ref{distancia}).

\section{Planejamento do estudo} \label{sec:metod:planejamento}

%\subsection{Seleção de métricas}
%
%Estas métricas serão coletadas para cada classe/módulo presente nas
%ferramentas de análise estática selecionadas e servirão de base para
%avaliar a qualidade das mesmas.
%
%(pendente) ``retomar complexidade estrutural e linkar com trabalho de
%terceiro, iremos olhar com mais detalhes algumas ferramentas e para este
%subconjunto vamos analisar a organização arquitetural dos módulos, isto
%será base para o guia de refatoração que faremos.''

\subsection{Seleção de ferramentas de análise estática}\label{levantamento}

A seleção de ferramentas de análise estática será realizada 
por meio de uma busca por ferramentas desenvolvidas no contexto da
academia e da indústria, com base em critérios pré-definidos.
Será feito um planejamento detalhado para
realizar a seleção de ferramentas em cada um destes contextos.

No contexto acadêmico, a busca por ferramentas será feita
em artigos publicados em conferências que tenham histórico de
publicação sobre ferramentas de análise estática de código-fonte. 
Estes artigos serão analisados e aqueles com publicação de ferramenta
serão selecionados.

Na indústria, a busca por ferramentas será feita a partir da base mantida pelo
projeto SAMATE, um projeto do NIST dedicado ao desenvolvimento de métodos que
permitam avaliar e medir a eficiência de ferramentas e técnicas sobre garantia
de qualidade em software. 
O site do projeto mantém uma lista de ferramentas de análise estática.
QUAL é o site???

As ferramentas selecionadas serão avaliadas, com  extração de
seus atributos de qualidade interna a partir do cálculo de suas métricas de
código-fonte.

\subsection{Revisão estruturada}\label{revisao-estruturada}

A revisão estruturada é um processo disciplinado para seleção de
artigos a partir de critérios bem definidos, 
de forma que seja possível a reprodução do estudo 
por parte de pesquisadores interessados.

A revisão está organizada em atividades de  
(1) busca de artigos (definição das fontes de busca, 
definição de critérios de busca, definição de script de busca, realização da busca nas fontes)
e (2) caracterização / seleção de artigos. 

No primeiro passo da revisão estruturada,
as fontes de busca serão definidas, considerando
conferências que abordam o tema de interesse do estudo. 

A busca textual será realizada automaticamente, utilizando um 
script\footnote{http://github.com/joenio/dissertacao-ufba-2016/blob/master/revisao-estruturada/filter}
escrito especialmente para este estudo.
A busca seleciona artigos que contêm os seguintes termos:

\begin{verbatim}
  "tool" OU "framework"; E
  "download" OU "available"; E
  "http" OU "ftp"; E
  "static analysis" OU "parser".
\end{verbatim}

Uma cópia local de todos os artigos encontrados, em formato PDF,
será feita.

No segundo passo, a seleção de artigos será feita com
base nos artigos encontrados pela busca.
Na seleção, pretende-se identificar se cada artigo resulta, de fato,
em publicação de ferramenta de análise estática.
Uma vez que se confirme que o artigo publica uma ferramenta,
este artigo será incluído para leitura. 
Ferramentas que sejam mais abrangentes do que apenas análise estática mas que
contenham esta função em seu conjunto também serão selecionadas.

Uma vez identificados os artigos que publicaram ferramentas de
análise estática, procuramos no próprio artigo referências de onde encontrar o
software. Neste contexto,  algumas ações serão tomadas a partir da situação
encontrada.

\begin{itemize}

  \item Autores que afirmam que a ferramenta está disponível mas o
    artigo não contém referências de onde encontrar o software. Os autores serão
    contactados por email, solicitando informações de onde obter o
    código-fonte.

  \item Artigos indicam onde obter o código-fonte da ferramenta, mas o acesso ao local
    indicado não está disponível, ou está disponível mas o software não se
    encontra lá. Os autores também serão contactados, solicitando informações
    atualizadas de onde obter uma cópia do código-fonte da ferramenta.

  \item Artigos indicam onde obter o código-fonte da ferramenta e a referência
    está correta. Será feito o download da última versão disponível do software.

\end{itemize}

Uma vez que os autores contactados por email respondam com informações sobre
local para obter o software, iremos adicionar a ferramenta ao conjunto de ferramentas 
a serem analisadas.

Por fim, a ferramenta livre {\it sloccount}\footnote{http://www.dwheeler.com/sloccount} 
será  utilizada para identificar a linguagem de programação usada na implementação de cada
ferramenta selecionada. 
A identificação da linguagem de programação usada é necessária,
pois apenas as ferramentas implementadas nas linguagens de programação suportadas 
pela ferramenta Analizo serão consideradas.
%
Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte, calcula uma grande quantidade de
métricas, como CBO, LCOM4, RFC, LOC, e suporta análise das linguagens de
programação C, C++ e Java.
É uma ferramenta mantida constantemente, com desenvolvedores ativos, e
atualizações frequentes, sua última versão 1.19.0 foi lançada em 18 de
Fevereiro de 2016 e será esta a versão utilizada neste estudo.

\section{Coleta de dados} \label{sec:metod:coleta}

Serão realizadas duas etapas para identificar e mapear as ferramentas de
análise estática com código-fonte disponível:  
uma atividade de seleção de ferramentas da academia, descrita 
na Seção \ref{ferramentas-da-academia}, 
e outra atividade seleção de ferramentas da indústria, descrita 
na Seção \ref{ferramentas-da-industria}.

As ferramentas selecionadas para o estudo serão analisadas com Analizo 
para extração dos valores de métricas de código-fonte.
Esta análise utilizará o comando {\it metrics}
da suite de Analizo, que calcula métricas globais de projeto 
e métricas por módulos.
Este estudo levará em consideração a distribuição das métricas por módulos.

\subsection{Ferramentas da academia}\label{ferramentas-da-academia}

A seleção de ferramentas da academia será relizada por meio
de uma revisão estruturada (seção~\ref{revisao-estruturada}).
As fontes de busca para busca de artigos
são a conferência SCAM - Source Code Analysis and Manipulation Working
Conference\footnote{http://www.ieee-scam.org} e mais uma dentre as seguintes
conferências:

\begin{itemize}
  \item ASE - Automated Software
    Engineering\footnote{http://ase-conferences.org}
  \item CSMR\footnote{A conferência CSMR tornou-se SANER - Software Analysis,
    Evolution, and Reengineering a partir da edição 2015.} - Conference on
    Software Maintenance and
    Reengineering\footnote{http://ansymore.uantwerpen.be/csmr-wcre}
  \item ICSME - International Conference on Software Maintenance and
    Evolution\footnote{http://www.icsme.org}
\end{itemize}


POR QUE ESTAS?  JUSTIFICAR.

POR QUE APENAS MAIS UMA? JUSTIFICAR?

Após download do código-fonte de cada ferramenta selecionada,
em sua versão mais recente,
a ferramenta Analizo será utilizada para a coleta das métricas. 

\subsection{Ferramentas da indústria}\label{ferramentas-da-industria}

A seleção de ferramentas da indústria será feita de forma não estruturada a
partir de uma busca livre e manual no site do projeto
SAMATE\footnote{http://samate.nist.gov} - {\em Software Assurance Metrics and
Tool Evaluation} disponível em \citeonline{SamateAnalysers}. As ferramentas
com código-fonte disponível, implementadas nas linguagens de programação suportadas
pelo Analizo serão selecionadas.

Após download do código-fonte de cada ferramenta selecionada,
em sua versão mais recente,
a ferramenta Analizo será utilizada para a coleta das métricas. 

\section{Análise de dados} \label{sec:metod:analise}

Os dados coletados incluem .... DESCREVER.

métricas .

A linguagem R [REF]  será usada  para manipulação de  dados, tabelas e plotagem de gráficos.

Foram calculados os percentis de cada métrica para cada ferramenta analisada.
Cada percentil é a centésima parte dos dados ordenados de forma crescente.
Os percentis calculados foram: 1, 5, 10, 25, 50, 75, 90, 95 e 99. Dentre estes
iremos discutir os resultados em função dos percentis 75, 90 e 95,
correspondendo a valores muito frequentes, frequentes e pouco frequentes,
respectivamente.

\subsection{Distribuição dos valores das métricas}\label{distancia}

(pendente) ``como será calculado a distribuição dos valores''.

\subsection{Cálculo de distância e modelo de aproximação}

(pendente) ``como será feito este cálculo''.

\subsection{Caracterização das ferramentas}\label{caracterizacao-das-ferramentas}

%As métricas coletadas serão também utilizadas para identificar se existem
%valores de referência para métricas de ferramentas de análise estática, caso
%existam, estes valores de métricas serão utilizados para calcular quão
%distante cada ferramenta analisada se encontra dos valores de referência, isto
%será feito com base no trabalho realizado \citeonline{Ronaldo2015} onde o
%mesmo estudo foi feito para o sistema Android e seus aplicativos.

(pendente) ``como as ferramentas serão caracterizadas''.

\section{Avaliação da ferramenta Analizo}

Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte.
Analizo calcula uma grande quantidade de métricas, como CBO, LCOM4, RFC, LOC, 
e suporta análise das linguagens de programação C, C++ e Java.

A ferramenta Analizo está em constante evolução, 
com desenvolvedores ativos e  atualizações frequentes.
A versão 1.19.0 do Analizo -- lançada em 18 de
fevereiro de 2016 -- será utilizada neste trabalho.


\section{Cronograma} \label{sec:cronograma}

COLOCAR.

%------------------------------------------%
\xchapter{Conclusões}{}

\section{Resultados preliminares}

Os resultados preliminares são apresentados no Apêndice.

SINTESE AQUI ?  TRENDS? 

(pendente) ``discutir as contribuições dando resposta ao que foi colocado na
introdução, fizemos isto, conseguimos estes resultados, e iremos fazer aquilo
nos proximos passos.''

\section{Próximos passos}

(pendente)

%------------------------------------------%

\backmatter
\bibliography{bibliografia}
\appendix

\xchapter{Resultados preliminares}{}

\section{Ferramentas selecionadas} 

Ferramentas selecionadas ... 

\subsection{Indus}

Indus é uma biblioteca de {\it program
slicing}\footnote{http://en.wikipedia.org/wiki/Program\_slicing} publicada no
artigo ``An Overview of the Indus Framework for Analysis and Slicing of
Concurrent Java Software'' do SCAM 2006, disponível em
http://indus.projects.cis.ksu.edu. 
O projeto está organizado em três módulos.
Os seguintes arquivos, contendo o código-fonte dos três módulos,
foram copiados localmente para análise:
\begin{itemize}
  \item indus.indus-src-20091220.zip
  \item indus.javaslicer-src-20091220.zip
  \item indus.staticanalyses-src-20070305.zip
\end{itemize}

\subsection{AccessAnalysis}

AccessAnalysis é um plugin do Eclipse de análise estática 
para cálculo das métricas IGAT e IGAM
publicadas no artigo ``AccessAnalysis — A Tool for Measuring the
Appropriateness of Access Modifiers in Java Systems'' do SCAM 2012,
disponível em http://accessanalysis.sourceforge.net. 
O código-fonte da versão 1.2 foi utilizado neste estudo:

\begin{itemize}
  \item AccessAnalysis-1.2-src.zip
\end{itemize}

\subsection{Bakar Alir}

Bakar Alir é ... ?

SCAM 2012/06392111.pdf 
 http://www.sireum.org/downloads/Alir, link desatualizado, mas link para github leva aos sources


\section{Análise exploratória da revisão estruturada}

%(pendente) ``documentar aqui os artigos incluídos na revisão estruturada,
%identificar aqueles que publicam ferramenta, dentre os que publicam quais
%tinham o software de fato disponível, as referencias indicadas no artigo para
%obtenção do software estavam corretas? foi necessário contactar o autor?''

A Tabela \ref{artigos-do-scam} apresenta um resumo do número de artigos em
cada edição do SCAM e quantos artigos trazem publicação de ferramenta de análise
estática com código fonte disponível.

\begin{table}[h]
\caption{Total de artigos analisados por edições do SCAM}
\centering
\begin{tabular}{| l | c | c | c |}
\hline
Edição    & Total de artigos & Script filter & Artigos com ferramenta \\
\hline
SCAM 2001 & 23               & 6             & -                      \\
SCAM 2002 & 18               & 6             & -                      \\
SCAM 2003 & 21               & 7             & -                      \\
SCAM 2004 & 17               & 3             & -                      \\
SCAM 2005 & 19               & 7             & -                      \\
SCAM 2006 & 22               & 9             & 2                      \\
SCAM 2007 & 23               & 7             & 1                      \\
SCAM 2008 & 29               & 14            & -                      \\
SCAM 2009 & 20               & 10            & -                      \\
SCAM 2010 & 21               & 15            & 1                      \\
SCAM 2011 & 21               & 9             & 1                      \\
SCAM 2012 & 22               & 12            & 4                      \\
SCAM 2013 & 24               & 12            & -                      \\
SCAM 2014 & 35               & 16            & 1                      \\
SCAM 2015 & 30               & 18            & 0                      \\
\hline
Total     & 315              & 133           & 10                     \\
\hline
\end{tabular}
\label{artigos-do-scam}
\end{table}

A Tabela \ref{total-de-ferramentas} apresenta um resumo com todas as
ferramentas, tanto da academia quanto da indústria, após a avaliação final
sobre disponibilidade do código-fonte e possibilidade de ser analizada. Das 54
ferramentas do NIST apenas 19 tinham código fonte disponível, destas apenas 15
eram suportadas pelo Analizo. Dos 315 artigos avaliados na revisão estruturada
apenas 10 tinham ferramentas disponíveis capaz de serem analizadas pelo
Analizo.

\begin{table}[h]
  \caption{Lista com total de ferramentas a serem analisadas}
  \centering
  \begin{tabular}{| c | l | l | c | l | l |}
    \hline
    n & Ferramentas da indústria & Linguagem  & n  & Ferramentas da academia & Linguagem  \\
    \hline
    1  & BOON                     & ansic     & 16 & Indus                   & java       \\
    2  & CQual                    & ansic     & 17 & TACLE                   & java       \\
    3  & RATS                     & ansic     & 18 & JastAdd                 & java       \\
    4  & Smatch                   & ansic     & 19 & WALA                    & java       \\
    5  & Splint                   & ansic     & 20 & error-prone             & java       \\
    6  & UNO                      & ansic     & 21 & AccessAnalysis          & java       \\
    7  & Clang Static Analyzer    & cpp       & 22 & Bakar Alir              & java       \\
    8  & Cppcheck                 & cpp       & 23 & InputTracer             & ansic      \\
    9  & Jlint                    & cpp       & 24 & srcML                   & cpp        \\
    10 & WAP                      & java      & 25 & Source Meter            & java       \\
    11 & Closure Compiler         & java      &    &                         &            \\
    12 & FindBugs                 & java      &    &                         &            \\
    13 & FindSecurityBugs         & java      &    &                         &            \\
    14 & Pixy                     & java      &    &                         &            \\
    15 & PMD                      & java      &    &                         &            \\
    \hline
  \end{tabular}
  \label{total-de-ferramentas}
\end{table}

Assim, temos um total de 25 ferramentas, 15 da indústria e 10 da academia.

\section{Análise exploratória dos valores das métricas}

(pendente) ``métricas das ferramentas, cálculo dos percentis, score de
aproximação, valores de referências, discussão sobre cada métrica, discussão
sobre as ferramentas com melhor qualidade, discutir detalhes da arquitetura
das melhores ferramentas''.

Vamos analisar os dados e tentar explicar seu comportamento
com relação às características das ferramentas, compará-los a outros estudos, e até mesmo
comparar com dados de métricas em aplicativos, utilizando os próprios aplicativos do
sistema como base de comparação.


\subsection{Conexões aferentes de uma classe (ACC)}

A Tabela \ref{metrica-acc} apresenta a métrica ACC para cada ferramenta
acadêmica.

%% begin.rcode metrica-acc, fig.align='center', results="asis"
% table = percentis_by_project("acc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica acc", "metrica-acc")
%% end.rcode


Colocar industria tambem na mesma seção? 
As Tabelas X e Y  apresentam a métrica ACC 
para as ferramentas da academia e da indústria, respectivamente.


\subsection{Média de complexidade ciclomática por método (ACCM)}

A Tabela \ref{metrica-accm} ...

%% begin.rcode metrica-accm, fig.align='center', results="asis"
% table = percentis_by_project("accm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica accm", "metrica-accm")
%% end.rcode

\subsection{Média do número de linhas de código por método (AMLOC)}

LOC representa o número de linhas de código fonte de um módulo, enquanto AMLOC
a média do número de linhas dos métodos daquele módulo. O valor de AMLOC deve
ser o menor possível, pois métodos grandes ``abrem espaço'' para problemas de
complexidade excessiva.

As Tabelas \ref{metrica-amloc} e \ref{metrica-amloc-industria} apresentam a
métrica AMLOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-amloc, fig.align='center', results="asis"
% table = percentis_by_project("amloc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da academia", "metrica-amloc")
%% end.rcode

%% begin.rcode metrica-amloc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("amloc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da indústria", "metrica-amloc-industria")
%% end.rcode

\subsection{Média do Número de Parâmetros por Método (ANPM)}

A Tabela \ref{metrica-anpm}...

%% begin.rcode metrica-anpm, fig.align='center', results="asis"
% table = percentis_by_project("anpm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica anpm", "metrica-anpm")
%% end.rcode

\subsection{Acoplamento entre objetos (CBO)}

A Tabela \ref{metrica-cbo}...

%% begin.rcode metrica-cbo, fig.align='center', results="asis"
% table = percentis_by_project("cbo")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica cbo", "metrica-cbo")
%% end.rcode

\subsection{Profundidade da árvore de herança (DIT)}

A Tabela \ref{metrica-dit}...

%% begin.rcode metrica-dit, fig.align='center', results="asis"
% table = percentis_by_project("dit")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica dit", "metrica-dit")
%% end.rcode

\subsection{Ausência de coesão em métodos (LCOM4)}

A Tabela \ref{metrica-lcom4}...

%% begin.rcode metrica-lcom4, fig.align='center', results="asis"
% table = percentis_by_project("lcom4")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica lcom4", "metrica-lcom4")
%% end.rcode

\subsection{Número de linhas de código (LOC)}

A Tabela \ref{metrica-loc}...

%% begin.rcode metrica-loc, fig.align='center', results="asis"
% table = percentis_by_project("loc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica loc", "metrica-loc")
%% end.rcode

\subsection{Número de atributos (NOA)}

A Tabela \ref{metrica-noa}...

%% begin.rcode metrica-noa, fig.align='center', results="asis"
% table = percentis_by_project("noa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noa", "metrica-noa")
%% end.rcode

\subsection{Número de filhos (NOC)}

A Tabela \ref{metrica-noc}...

%% begin.rcode metrica-noc, fig.align='center', results="asis"
% table = percentis_by_project("noc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noc", "metrica-noc")
%% end.rcode

\subsection{Número de métodos (NOM)}

A Tabela \ref{metrica-nom}...

%% begin.rcode metrica-nom, fig.align='center', results="asis"
% table = percentis_by_project("nom")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica nom", "metrica-nom")
%% end.rcode

\subsection{Número de atributos públicos (NPA)}

A Tabela \ref{metrica-npa}...

%% begin.rcode metrica-npa, fig.align='center', results="asis"
% table = percentis_by_project("npa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npa", "metrica-npa")
%% end.rcode

\subsection{Número de métodos públicos (NPM)}

A Tabela \ref{metrica-npm}...

%% begin.rcode metrica-npm, fig.align='center', results="asis"
% table = percentis_by_project("npm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npm", "metrica-npm")
%% end.rcode

\subsection{Resposta para uma classe (RFC)}

A Tabela \ref{metrica-rfc}...

%% begin.rcode metrica-rfc, fig.align='center', results="asis"
% table = percentis_by_project("rfc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica rfc", "metrica-rfc")
%% end.rcode

\subsection{Complexidade estrutural (SC)}

A Tabela \ref{metrica-sc}...

%% begin.rcode metrica-sc, fig.align='center', results="asis"
% table = percentis_by_project("sc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica sc", "metrica-sc")
%% end.rcode

\clearpage


% nao separar em secoes.
%\section{Métricas para as ferramentas da indústria}

%% begin.rcode metrica-acc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("acc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica acc", "metrica-acc-industria")
%% end.rcode

%% begin.rcode metrica-accm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("accm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica accm", "metrica-accm-industria")
%% end.rcode

%% begin.rcode metrica-anpm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("anpm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica anpm", "metrica-anpm-industria")
%% end.rcode

%% begin.rcode metrica-cbo-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("cbo")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica cbo", "metrica-cbo-industria")
%% end.rcode

%% begin.rcode metrica-dit-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("dit")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica dit", "metrica-dit-industria")
%% end.rcode

%% begin.rcode metrica-lcom4-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("lcom4")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica lcom4", "metrica-lcom4-industria")
%% end.rcode

%% begin.rcode metrica-loc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("loc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica loc", "metrica-loc-industria")
%% end.rcode

%% begin.rcode metrica-noa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noa", "metrica-noa-industria")
%% end.rcode

%% begin.rcode metrica-noc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica noc", "metrica-noc-industria")
%% end.rcode

%% begin.rcode metrica-nom-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("nom")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica nom", "metrica-nom-industria")
%% end.rcode

%% begin.rcode metrica-npa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npa", "metrica-npa-industria")
%% end.rcode

%% begin.rcode metrica-npm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica npm", "metrica-npm-industria")
%% end.rcode

%% begin.rcode metrica-rfc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("rfc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica rfc", "metrica-rfc-industria")
%% end.rcode

%% begin.rcode metrica-sc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("sc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica sc", "metrica-sc-industria")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas academicas}

%% begin.rcode grafico-accessanalysis, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta accessanalysis"
% plot_lines_for_project("dataset/PAPERS/accessanalysis/AccessAnalysis-1.2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-bakar-ali, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta bakar-ali"
% plot_lines_for_project("dataset/PAPERS/bakar-ali/bakar-dev-20160415-002013.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-error-prone, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta error-prone"
% plot_lines_for_project("dataset/PAPERS/error-prone/error-prone-2.0.9.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-indus, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta indus"
% plot_lines_for_project("dataset/PAPERS/indus/indus.staticanalyses.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-inputtracer, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta inputtracer"
% plot_lines_for_project("dataset/PAPERS/inputtracer/valgrind-inputtracer.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jastadd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jastadd"
% plot_lines_for_project("dataset/PAPERS/jastadd/jastadd2-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-source-meter, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta source-meter"
% plot_lines_for_project("dataset/PAPERS/source-meter/SonarQube-plug-in-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-srcml, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta srcml"
% plot_lines_for_project("dataset/PAPERS/srcml/srcML-src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-tacle, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta tacle"
% plot_lines_for_project("dataset/PAPERS/tacle/tacle_1_2_1_src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wala, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wala"
% plot_lines_for_project("dataset/PAPERS/wala/WALA-R_1.3.8.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráficos das métricas para as ferramentas da indústria}

%% begin.rcode grafico-boon-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta boon"
% plot_lines_for_project("dataset/NIST/boon/boon-1.0.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-clang-industria, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta clang"
% plot_lines_for_project("dataset/NIST/clang/clang-tools-extra-3.7.1.src.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-closure-compiler, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta closure-compiler"
% plot_lines_for_project("dataset/NIST/closure-compiler/compiler-latest.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cppcheck, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cppcheck"
% plot_lines_for_project("dataset/NIST/cppcheck/cppcheck-1.72.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-cqual, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta cqual"
% plot_lines_for_project("dataset/NIST/cqual/cqual-0.981.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-findbugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findbugs"
% plot_lines_for_project("dataset/NIST/findbugs/findbugs-3.0.1.analizo.metrics.dat")
%% end.rcode


%% begin.rcode grafico-findsecuritybugs, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta findsecuritybugs"
% plot_lines_for_project("dataset/NIST/findsecuritybugs/findsecbugs-plugin-1.4.5-sources.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-jlint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta jlint"
% plot_lines_for_project("dataset/NIST/jlint/jlint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pixy, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pixy"
% plot_lines_for_project("dataset/NIST/pixy/pixy-master.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-pmd, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta pmd"
% plot_lines_for_project("dataset/NIST/pmd/pmd-src-5.4.1.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-rats, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta rats"
% plot_lines_for_project("dataset/NIST/rats/rats-2.4.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-smatch, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta smatch"
% plot_lines_for_project("dataset/NIST/smatch/smatch.git.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-splint, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta splint"
% plot_lines_for_project("dataset/NIST/splint/splint-3.1.2.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-uno, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta uno"
% plot_lines_for_project("dataset/NIST/uno/uno.analizo.metrics.dat")
%% end.rcode

%% begin.rcode grafico-wap, fig.show='hold', fig.width=3.5, fig.height=3, fig.cap="distribuição das métricas para a ferramenta wap"
% plot_lines_for_project("dataset/NIST/wap/wap-2.1.analizo.metrics.dat")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas academicas}

%% begin.rcode grafico-lcom4, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc, fig.show='hold', fig.cap="distribuição para as ferramentas da academia"
% table = percentis_by_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\subsection{Gráfico comparativo para as ferramentas da indústria}

%% begin.rcode grafico-lcom4-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("lcom4")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%% end.rcode

%% begin.rcode grafico-cbo-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("cbo")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%% end.rcode

%% begin.rcode grafico-sc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("sc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

%% begin.rcode grafico-amloc-nist, fig.show='hold', fig.cap="distribuição para as ferramentas da indústria"
% table = percentis_by_nist_project("amloc")
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% legend("topleft", legend=names(table), col=1:length(table), pch=1)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="amloc")
%% end.rcode

\clearpage

\section{Evolução inicial da ferramenta Analizo}\label{evolucao-analizo}

(pendente) ``apenas se der tempo''.

%\section{Resultados}
%
%%7- Nos resultados, teremos duas coisas: Referência dos valores frequentes e Aplicação do cálculo do score de similaridade
%
%(pendente) ``a caracterização das ferramentas dará indícios para documentar
%sugestões de refatoração para ferramentas de análise estática, estas sugestões
%serão aplicadas na refatoração do Analizo.''


\end{document}

% vim: filetype=tex
