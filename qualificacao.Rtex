\documentclass[qual, classic, a4paper]{ufbathesis}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage[alf]{abntex2cite}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{float}
\usepackage{rotating}
\DeclareGraphicsExtensions{.pdf}

\defenseyear{2016}
\date{08 de Julho de 2016}
\adviser[f]{Profa. Dra. Christina von Flach G. Chavez}
\coadviser{Prof. Dr. Paulo Roberto Miranda Meirelles}

\title{
  Caracterização da complexidade estrutural em ferramentas de análise estática
  de código-fonte
}

\author{Joenio Marques da Costa\\
  {\small joenio@joenio.me}
}

\begin{document}

\frontpage
\frontmatter
\presentationpage

\resumo

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\abstract

(pendente)

\begin{keywords}

  (pendente)

\end{keywords}

\tableofcontents
\listoffigures
\listoftables

\mainmatter

%------------------------------------------%
\xchapter{Introdução}{}

%{\it Eu, como um desenvolvedor de ferramenta de análise estática de
%código-fonte, estou interessado em compreender a fundo este domínio de
%aplicação, suas técnicas e limitações, bem como compreender o estado da arte
%das ferramentas existentes na indústria e na academia, através da
%caracterização de seus atributos de qualidade interna, a fim de ter
%conhecimento suficiente para tomada de decisão sobre a evolução e manutenção
%da minha própria ferramenta de análise estática, a ser realizada durante este
%trabalho, com objetivo de melhorar seus atributos de qualidade interna.}

O domínio de aplicação de análise estática tem evoluído constantemente desde o
seu surgimento a mais de 40 anos, e apesar da sua evolução constante poucos
estudos demonstram a preocupação em avaliar ou comparar ferramentas de análise
estática de código-fonte em relação a seus atributos de qualidade interna, um
aspecto importante para guiar e auxiliar desenvolvedores em atividades de
evolução e manutenção de software.

Desta forma, estudar e comparar tais ferramentas a fim de compreender seus
atributos de qualidade interna e entender quais características arquiteturais
explicam tais atributos é de fundamental importância do ponto de vista de
desenvolvedores interessados em melhorar a qualidade interna de suas
ferramentas.

\section{Objetivos}

Diante disso, definimos como objetivo principal deste trabalho: compreender
as ferramentas de software para análise estática de código-fonte do ponto de
vista de sua manutenabilidade, a partir da análise de sua complexidade
estrutural, discutindo quais características arquiteturais explicam seus
atributos de qualidade interna.

\subsection{Questão de pesquisa}

Com este objetivo em mente, levantamos a seguinte questão de pesquisa:

\begin{enumerate}
  \item [{\bf Q1:}] {\em Como a complexidade estrutural pode ser interpretada
    e explicada para ferramentas de software do domínio de aplicação de
    análise estática de código-fonte?}
\end{enumerate}

\subsubsection{Hipóteses}

Para responder a questão colocada acima, definimos as seguintes hipóteses:

\begin{enumerate}
  \item[{\bf H1:}] {\em É possível calcular valores de referência de métricas
    de código-fonte para ferramentas de análise estática a partir de um
    conjunto de softwares da academia e da indústria.}
  \item[{\bf H2:}] {\em Ferramentas de análise estática tendem a ter uma
    maior complexidade estrutural do que ferramentas de outros domínios de
    aplicação.}
  \item[{\bf H3:}] {\em Dentre as ferramentas de análise estática de
    código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
    complexidade estrutural.}
\end{enumerate}

A Seção \ref{hipoteses} traz detalhes sobre como cada hipótese será testada.

\subsection{Objetivos específicos}

São objetivos específicos deste trabalho:

\begin{itemize}
%  \item Realizar uma revisão da literatura para conceituar análise estática de
%    código-fonte.
  \item Selecionar e obter código-fonte de ferramentas de análise estática
    desenvolvidas na academia, para coletar suas métricas de código-fonte.  A
    seleção terá como base o resultado de uma revisão estruturada realizada a
    partir de artigos publicados em conferências relacionadas. 
  \item Selecionar e obter código-fonte de ferramentas de análise estática
    desenvolvidas pela indústria, para coletar suas métricas de código-fonte.
  \item Propor intervalos de referência para a observação parametrizada da
    qualidade interna das ferramentas de análise estática, a partir de suas
    métricas de código-fonte.
  \item Calcular a distância Euclidiana entre valores de referência e os
    valores das ferramentas estudadas.
\end{itemize}

\section{Contribuições esperadas}

Ao final deste trabalho, as seguintes contribuições científicas ({\bf CC}) e
tecnológicas ({\bf CT}) são esperadas:

\begin{enumerate}
  \item [{\bf CC1:}] Um conjunto de intervalos de referência da frequência dos
    valores de métricas de código-fonte para o domínio de aplicação de
    análise estática de código-fonte.
  \item [{\bf CC2:}] Definição de argumentos que expliquem a alta complexidade
    estrutural em ferramentas de análise estática de código-fonte.
  \item [{\bf CT1:}] Evolução de uma ferramenta de análise estática de
    código-fonte.
\end{enumerate}

Lembrando que neste trabalho serão utilizadas métricas de produto,
especificamente, métricas de código-fonte, que cobrem aspectos de tamanho,
complexidade e qualidade.

\section{Estrutura do texto} 

O capítulo \ref{fundamentacao} apresenta conceitos sobre análise estática e
métricas de código-fonte necessários para compreensão do trabalho. O capítulo
\ref{metodologia} apresenta trabalhos relacionados, hipóteses do estudo,
planejamento sobre a coleta e análise dos dados
e o cronograma do estudo. O capítulo \ref{conclusoes} traz a
discussão e interpretação dos dados e apresenta os próximos passos do estudo.

%-----------------------------------------------------%
\xchapter{Fundamentação Teórica}
{Este capítulo apresenta conceitos necessários para a compreensão do trabalho.}
\label{fundamentacao}

A análise estática de código-fonte é o primeiro passo para coletar informações
necessárias em diversas atividades de verificação, medição e melhoria da
qualidade de produtos de software \cite{Cruz2009} \cite{Kirkov2010}. Ela é
realizada com base no código-fonte de um programa ou sistema de software, e a
partir daí descobre problemas e propriedades de sua qualidade estrutural
\cite{Chess2007}.

Ferramentas de análise estática estão disponíveis há décadas, em especial,
para programadores. A ferramenta Lint \cite{Johnson1978}, considerada a
primeira ferramenta de análise estática \cite{Gosain2015}, foi criada para
examinar programas escritos em linguagem C e aplicar regras de tipagem mais
estritas do que as regras dos próprios compiladores da linguagem.

% \cite{Li2010} cita FlexeLint como a primeira ferramenta de análise estática

Neste trabalho o nosso interesse reside em compreender características de
qualidade interna de ferramentas deste domínio de aplicação, do ponto
de vista de desenvolvedores interessados em manter e evoluir tais ferramentas
melhorando seus atributos de qualidade interna.

A seção \ref{analise-estatica} apresenta uma definição geral da análise
estática de código-fonte, suas aplicações, sua anatomia, seus formatos de
representação intermediária e técnicas mais comuns. A seção \ref{metricas} traz uma
definição de métricas de software e apresenta um conjunto de métricas
utilizados neste estudo, trazendo detalhes sobre métricas de complexidade
estrutural.

%\ref{formatos}
%\ref{tecnicas}
%\ref{usos}
%\ref{anatomia}
%(\ref{complexidade}) (pendente capitulo sobre estatistica).
%(\ref{metricas-de-codigo})

\section{Análise estática de código-fonte} \label{analise-estatica}

Análise estática de código-fonte é um ramo da engenharia de software voltado a
obter informações acerca de um programa a partir do seu código-fonte sem
necessidade de execução, e sem requerer qualquer outro artefato do programa
além do próprio código.

É um ramo que possui muitas das suas abordagens em comum com os estudos da
área de análise de programa ({\it program analysis}), especialmente a área de
compiladores, onde atua especialmente nas primeiras etapas do processo de compilação.

A análise estática de código-fonte é considerada uma atividade meio com
objetivo de suportar uma variedade de tarefas comuns da engenharia de
software; muitas dessas tarefas são substancialmente úteis em atividades de
manutenção. \citeonline{Binkley2007} define uma extensa lista dessas
atividades, alguns exemplos são:

\begin{multicols}{2}
  \begin{itemize}
    \item Análise de performance
    \item Compreensão de programas
    \item Desenvolvimento baseado em modelos
    \item Detecção de clones
    \item Evolução de software
    \item Garantia de qualidade
    \item Localizaçao de falhas
    \item Manutenção de software
    \item Recuperação arquitetural
    \item Testes
  \end{itemize}
\end{multicols}

Seja em qual atividade for, a análise estática possui uma importância
significativa, pois ao ser capaz de extrair informações diretamente do
código-fonte de um programa, pode auxiliar a responder com precisão a seguinte
pergunta: ``O que é que este programa significa?''.

\cite{Harman2010}

\subsection{Usos da análise estática de código-fonte} \label{usos}

A análise de programas trata, de modo geral, da descoberta de problemas e
fatos sobre programas. Essa análise pode ser realizada sem a necessidade de executar o
programa (análise estática) ou com informações provenientes de sua execução
(análise dinâmica).

A idéia de que programas de computador podem ser utilizados para analisar
código-fonte de outros programas tem uma história de mais de 40 anos.  O
programa PFORT \cite{Ryder1974} foi projetado para localizar potenciais
problemas na portabilidade de código Fortran; em função da diversidade de
dialetos de Fortran, uma compilação sem erros não indicava que o programa
estava correto segundo os padrões da linguagem \cite{Wichmann1995}.

Desde então, ferramentas de análise estática de código-fonte têm surgido para
os mais diversos fins -- muitas delas a partir das pesquisas e
desenvolvimentos da área de compiladores.  O {\it parser} utilizado nessas
ferramentas têm funcionalidades análogas aos analisadores usados em
compiladores \cite{Anderson2008}.

O uso de tais ferramentas tem se
tornado mais e mais comum no ciclo de desenvolvimento de
software, sendo aplicadas em uma infinidade de atividades distintas visto que o
campo de aplicação destas ferramentas é bastante variado, cobrindo diferentes
objetivos. Dentre as atividades em que a análise estática de código-fonte é
usada \cite{Chess2007}, destacam-se:

\begin{description}

  \item \textit{Verificação de tipos}. 
    A forma mais amplamente utilizada de análise estática e uma das quais os
    programadores estão mais familiarizados, é a checagem de tipo.
    Programadores dão pouca atenção a isto, visto que as regras são definidas
    pela linguagem de programação e executadas pelo próprio compilador, de
    forma que não se torna necessário entender como a análise acontece.  No
    entanto, esta atividade de verificação é análise estática e elimina toda
    uma categoria de erros de programação. Por exemplo, previne que
    programadores acidentalmente atribuam valores de forma incorreta a
    variáveis.  Ainda, ao capturar erros em tempo de compilação, esta checagem
    de tipo previne erros em tempo de execução.

  \item \textit{Verificação de estilo}. 
    Os verificadores de estilo são um tipo de análise estática que aplicam regras
    de forma mais superficial do que os verificadores de tipo. São regras
    relacionadas a espaços em branco, nomes, funções depreciadas, comentários,
    estrutura do programa, entre outros.  A maioria dos verificadores de
    estilo costumam ser bem flexíveis quanto ao conjunto de regras que aplicam
    uma vez que os programadores costumam ser bastante apegados aos seus
    próprios estilos de programação. Os erros reportados por verificadores de
    estilo são aqueles que afetam a leitura e a manutenabilidade do
    código-fonte, não indicando potenciais erros em tempo de execução como
    fariam os verificadores de tipo.

  \item \textit{Compreensão de programas}. 
    Ferramentas de compreensão de programa ajudam programadores a terem uma visão
    clara frente a grandes programas de computador, ou seja, programas com
    alto volume de código-fonte. Ambientes de desenvolvimento integrados (IDE)
    geralmente incluem funcionalidade de compreensão, por exemplo, ``encontrar
    todos os usos de um certo método'' ou ``encontrar a declaração de uma
    variável global''. Análises mais avançadas chegam a incluir, por exemplo,
    refatoração automática. Estas ferramentas de compreensão também são úteis
    para programadores interessados em entender código-fonte escrito por
    outros programadores.

  \item \textit{Verificação de programas}.
    Ferramentas de verificação de programa aceitam como entrada uma especificação
    e um conjunto de código-fonte e tenta provar que o código está de acordo
    com a especificação. Quando a especificação é uma descrição completa de
    todo o programa, a ferramenta de verificação poderá realizar uma checagem
    de equivalência para garantir que o código-fonte e a especificação
    combinam de forma exata. Programadores raramente têm acesso a uma
    especificação suficientemente detalhada para ser usada numa checagem de
    equivalência e o trabalho de criar esta especificação pode ser maior do que
    o trabalho de escrever o próprio código-fonte do programa, desta forma,
    este tipo de verificação formal raramente acontece. Sendo mais comum a
    verificação em relação a uma especificação parcial que detalha apenas
    parte do comportamento do programa.  Isto costuma ser chamado de
    verificação de propriedade, grande parte das ferramentas de verificação de
    propriedade funcionam aplicando inferências lógicas ou verificação de
    modelos.

  \item \textit{Localização de bugs}. 
    O propósito de uma ferramenta de localização de bugs não está em questões de
    formatação, como é a verificação de estilo, nem em realizar uma exaustiva
    e completa comparação contra uma especificação, como uma ferramenta de
    verificacao de programa. Ao invés disso, um localizador de bugs está
    preocupado em apontar locais onde o programa, possivelmente, irá se
    comportar de forma inesperada. A maioria das ferramentas de localização de
    bugs são fáceis de usar porque costumam vir com um conjunto de regras
    ({\it bug idioms}) para descrição de padrões de código que indicam bugs.
    Algumas destas ferramentas costumam usar os mesmos algoritmos utilizados
    por ferramentas de verificação de propriedade.

  \item \textit{Avaliação de segurança}. 
    Ferramentas de análise estática para segurança usam as mesmas técnicas
    encontradas nas outras ferramentas, mas por ter um propósito diferente,
    identificar problemas de segurança, aplicam estas técnicas de forma diferente.
    As primeiras ferramentas de segurança (ITS4, RATS, Flawfinder) eram pouco mais
    do que um {\it ``grep''} melhorado; na maior parte, elas escaneavam o código
    procurando por funções como por exemplo {\it ``strcpy()''} que são
    facilmente usadas de forma inadequada e devem ser inspecionadas
    manualmente no processo de revisão de código-fonte. A evolução deste tipo
    de ferramenta de segurança levou a técnicas híbridas de verificação de
    propriedade e de localização de bugs, de forma que muitas propriedades de
    segurança podem ser suscintamente expressas como propriedades de
    programas.

\end{description}

\subsection{Anatomia da análise de código-fonte} \label{anatomia}

Ferramentas de análise estática de código-fonte estão organizadas em partes ou
componentes, responsáveis por implementar três funções básicas \cite{Cruz2009}
\cite{Binkley2007}: a) extração de dados, b) geração de representação
intermediária, e c) análise. A ferramenta de análise de código-fonte
CodeSonar\footnote{https://www.grammatech.com/products/codesonar} segue tal
organização, conforme mostra a Figura \ref{static-analysis-representation}.

\begin{figure}[h]
  \center
  \includegraphics[scale=0.4]{imagens/static-analysis-representation.png}
  \caption{CodeSonar: Representação da Análise Estática \cite{GrammaTech2016}}
  \label{static-analysis-representation}
\end{figure}

\begin{description}

  \item \textit{Extração de dados}.
    O processo de recuperar dados para futuro processamento ou armazenamento é
    chamado de extração de dados. 

    O primeiro componente da análise de código-fonte é a extração de dados,
    responsável por ler o código-fonte do programa e gerar uma ou mais
    representações intermediárias. Em essência, este componente converte a sintaxe
    de um programa em uma outra sintaxe abstrata e mais adequada para análise
    posterior. Este componente é usualmente chamado de analisador sintático
    (ou {\it parser}) e apesar de teoricamente não ser uma tarefa difícil,
    apresenta enormes desafios diante da complexidade das linguagens de
    programação modernas.

  \item \textit{Representação intermediária}.
    Exportar os dados extraídos para uma representação intermediária é uma
    estratégia comum para facilitar análise e transformação de dados e
    possivelmente adição de metadados.

    Os dados obtidos na extração precisam ser representados em um formato mais
    abstrato. Esta é a responsabilidade do segundo componente da análise de
    código-fonte: armazenar os dados coletados usando uma representação
    intermediária em formato mais adequado para análise automática, abstraindo
    aspectos particulares do programa e da linguagem de programação.

    Alguns tipos de representação intermediária têm sua origem na área de
    compiladores; algumas delas são produzidas diretamente pelo {\it parser}
    enquanto outras requerem uma análise específica. Os formatos mais comuns
    são geralmente baseados em grafos. 

    Alguns formatos comumente utilizados são:
    \begin{multicols}{2}
      \begin{itemize}
        \item Árvore sintática abstrata
        \item Grafo de fluxo de controle
        \item Árvore sintática abstrata decorada
        \item Grafo de dependência de módulos
        \item Atribuição estática única
        \item Grafo de dependência de valores
      \end{itemize}
    \end{multicols}

    Estas representações podem ser utilizadas tanto na análise estática quanto
    na análise dinâmica. O uso de um ou outro formato depende do tipo de
    análise e seu propósito. Pode-se combinar diferentes tipos no sentido de
    enriquecer e estruturar a informação extraída.

  \item \textit{Análise}.
    Este componente é responsável por realizar inferências a partir dos dados
    representados internamente. O processo requer que as informações
    armazenadas estejam interconectadas e também interrelacionadas com
    conhecimento anterior. Esta análise pode gerar conhecimento quantitativo
    ou qualitativo, como, por exemplo, métricas de software ou mineração de
    dados, respectivamente. Técnicas de visualização podem ser usadas para
    apoiar este processo.

    Diversas técnicas foram desenvolvidas ao longo do tempo para realizar
    análise, algumas delas são brevemente descritas na seção \ref{tecnicas}.

\end{description}

\subsection{Formatos de representação intermediária} \label{formatos}

Essencialmente, um formato de representação intermediária é uma abstração precisa
das propriedades de um programa representado em um domínio menor. Os
compiladores normalmente constroem esta representação a fim de possuir um
modelo do programa sendo compilado, é comum que compiladores utilizem diversos
formatos durante o curso da compilação.

Em ferramentas de análise estática estes formatos são utilizados durante a
fase de análise para cumprir diversos objetivos, como por exemplo, calcular
métricas de código-fonte. A métrica de complexidade ciclomática de McCabe
\cite{McCabe1976}, por exemplo, é definida com base no grafo de fluxo de controle (CFG) do
programa com o seguinte cálculo $CC = e - n + 2p$. Onde: {\bf e} é o número de
arestas; {\bf n} é o número de nós; e {\bf p} é o número de componentes
fortemente conectados no grafo CFG.

%Observação (Chris):
%Algumas dessas RIs são necessárias para calcular alguns tipos de métricas.
%Às vezes há alguns workarounds em ferramentas, em
%geral, dependentes de linguagem.
%
%Mas algumas ferramentas implementam a métrica de outra forma.
%\begin{verbatim}
%NDepend:
%
%CC = 1 + {number of the following expressions found in a method} :
%if|while|for|foreach|case|default|continue|goto|&&| etc.
%
%\end{verbatim}

Assim, percebe-se que cada formato de representação intermediária \cite{Nielson2015}
\cite{Stanier2013} \cite{Cruz2009} \cite{Ramalho1996} pode ter fins e
objetivos bastante distintos, dentre os formatos mais comuns podemos destacar:

\begin{description}

  \item \textit{Árvore sintática abstrata}.
    A árvore sintática abstrata (AST - Abstract Syntax Tree) representa um
    programa tratando os elementos do código-fonte como operadores e
    operandos organizados em nós numa árvore. Este formato de representação é
    muito popular em tradutores {\it
    source-to-source}\footnote{http://en.wikipedia.org/wiki/Source-to-source\_compiler}.

  \item \textit{Grafo de fluxo de controle}.
    O grafo de fluxo de controle (CFG - Control Flow Graph ou Call Graph) é um grafo direcionado
    representando a estrutura de controle de um programa e sua sequência de
    instruções, onde as arestas mostram os possíveis caminhos de execução. Este
    formato é amplamente utilizado em métodos formais para otimização de
    código-fonte.

  \item \textit{Grafo de fluxo de dados}.
    O grafo de fluxo de dados (DFG - Data Flow Graph) é também um grafo
    direcionado onde as arestas representam o fluxo de dados entre as
    operações do programa. Este formato pode ser visto como um companheiro do
    grafo de fluxo de controle (CFG) e pode ser gerado ao longo de uma mesma
    análise.

  \item \textit{Árvore sintática abstrata decorada}.
    Árvore sintática abstrata decorada (DAST - Decorated Abstract Syntax Tree) é
    uma árvore sintática abstrata (AST) melhorada através de um processo de
    definiçao de atributos para os símbolos do programa de forma declarativa
    com uso de uma Gramática de
    Atributos\footnote{https://en.wikipedia.org/wiki/Attribute\_grammar}.

  \item \textit{Grafo de dependência de módulos}.
    O grafo de dependência de módulos (MDG - Module Dependence Graph) é um grafo
    onde os módulos são representados como nós e as arestas representam as
    relacões entre eles, indicando dependência entre os mesmos.

  \item \textit{Atribuição estática única}.
    Atribuição estática única (SSA - Static Single Assignment) pode ser vista
    como uma variação ou uma propriedade de outros formatos de representação
    intermediária, é um método que faz cada variável ser atribuída apenas uma única
    vez, facilitando a descoberta de informaçoes sobre os dados representados.

  \item \textit{Grafo de dependência de valores}.
    O grafo de dependência de valores (VDG - Value Dependence Graph) é uma
    variação que melhora (ao menos para algumas análises) os resultados
    obtidos a partir da atribuição estática única (SSA). Ele representa tanto
    o fluxo de controle quanto o fluxo de dados e assim simplifica a análise.

\end{description}

\subsection{Técnicas de análise} \label{tecnicas}

Inúmeras técnicas e métodos distintos podem ser utilizados pelas ferramentas
de análise estática, seja com o objetivo de verificação de tipos, localização
de bugs, compreensão de programas, avaliação de segurança, ou outra finalidade
qualquer. Segundo \citeonline{German2003}, \citeonline{Li2010},
\citeonline{Hofer2010} as técnicas e métodos mais comumente encontrados nas
ferramentas atuais são:

% análise de fluxo de dados, erros de runtime (divisão por zero, overflows, etc.), 
% análise de impacto, medições, identificação de \textit{code smells},  e reengenharia de software.

\begin{description}

  \item \textit{Análise léxica}.
    A análise léxica é responsável por quebrar o programa em pequenos fragmentos
    (ou {\it tokens}) e verificar se estes fragmentos são palavras válidas
    para uma dada linguagem. A análise léxica não leva em consideração a
    sintaxe do programa, sua semântica ou a interação entre módulos.

  \item \textit{Combinação de padrões de texto}.
    A combinação de padrões de texto ({\it Text-based Pattern Matching}) é a
    maneira mais simples e rápida de procurar vulnerabilidades num código
    fonte.

  \item \textit{Inferência de tipos}.
    A inferência de tipos ({\it Type inference}) refere-se a identificar o
    tipo de variáveis e funções e avaliar se o acesso a elas está em
    conformidade com as regras da linguagem. Linguagens de programação com
    sistema de tipagem incluem mecanismos deste tipo de análise.

  \item \textit{Análise de fluxo de dados}.
    A análise de fluxo de dados ({\it Data flow analysis}) resume-se a coletar
    informação semântica do código-fonte do programa e com métodos algébricos
    deduzir a definição e uso das variáveis em tempo de compilação. O objetivo
    é mostrar que nenhum caminho de execução do programa acessa uma variável
    sem definição ou atribuição prévia.

  \item \textit{Verificação de regra}.
    A verificação de regra ({\it Rule checking}) consiste em checar a segurança
    do programa através de um conjunto de regras pré-estabelecidas.

  \item \textit{Análise de restrição}.
    A análise de restrição ({\it Constraint analysis}) consiste em gerar
    e resolver restrições no processo de análise de um programa.

  \item \textit{Comparação caminho}.
    Comparação caminho ({\it Patch comparison}) inclui comparação de caminho de
    código-fonte e de código-binário e é usada principalmente para encontrar
    brechas de vulnerabilidade já ``conhecidas'' e previamente divulgadas por
    fornecedores e praticantes da indústria de software.

  \item \textit{Execução simbólica}.
    A execução simbólica ({\it Symbolic execution}) é usada para representar
    as entradas de um programa através do uso de valores simbólicos ao invés
    de dados reais, produz expressões algébricas sobre a entrada dos símbolos
    do programa durante o processo de implementação e pode detectar
    possibilidade de erros.

  \item \textit{Interpretação abstrata}.
    Interpretação abstrata ({\it Abstract interpretation}) é uma descrição
    formal da análise do programa. Pelo fato de apenas controlar atributos de
    programa de preocupaçao dos usuários, a interpretação da análise semântica
    é similar ao seu significado semântico real.

  \item \textit{Prova de teoremas}.
    Prova de teoremas ({\it Theorem proving}) é baseada na análise semântica do
    programa. Converte o programa em fórmulas lógicas e então tenta provar que
    o programa é um teorema válido usando regras e axiomas.

  \item \textit{Verificação de modelo}.
    O processo de verificação de modelos ({\it Model checking}) primeiro constrói
    um modelo formal do programa tal como uma máquina de estados ou um grafo
    direcionado, então examina e compara o modelo para verificar se o sistema
    cumpre as características pré-definidas. Esta técnica requer a definição e
    descrição das propriedades que devem ser verificados por um pedaço de
    software.

  \item \textit{Verificação formal}.
    Verificação formal ({\it Formal Checking} ou {\it Compliance Analysis}) é o
    processo de provar de forma automatizada que o código do programa está
    correto em relação a uma especificação formal dos seus requisitos.

  \item \textit{Análise de fluxo da informação}.
    Análise de fluxo da informação ({\it Information Flow Analysis}) identifica
    como a execução de uma unidade de código cria dependência entre entradas e
    saídas.

  \item \textit{Verificação de sintaxe}.
    Verificação de sintaxe ({\it Syntax Checks}) tem o objetivo de encontrar
    violação de regras tais como a utilização de uma variável do tipo incorreto
    ou sem declaração.

  \item \textit{Verificação de intervalo}.
    A análise de verificação de intervalo ({\it Range Checking}) tem o objetivo
    de verificar se os valores dos dados permanecem dentro de intervalos
    especificados, bem como manter a precisão especificada.

\end{description}

%--------------------------------------%
\section{Métricas de software} \label{metricas}

No glossário de terminologia para engenharia de software do IEEE
\cite{ieee1990ieee}, a qualidade de software é definida como (1) o grau em que
um sistema, componente ou processo atende a requisitos especificados e (2) o
grau em que um sistema, componente ou processo atende às necessidades ou
expectativas de um usuário. 

Segundo o padrão para metodologia de qualidade de métricas de software do IEEE
\cite{software1998ieee}, uma métrica de qualidade de software é ``uma função
cujas entradas são dados de software e cuja saída é um valor numérico, que
pode ser interpretado como o grau em que um software possui um determinado
atributo que afeta sua qualidade''.

%Metrics make a statement about some quality attributes, are quantitative, 
%but will have to be interpreted by a human.

Métricas de software podem ser classificadas em métricas de processo, métricas
de projeto e métricas de produto.

Métricas de processo medem atributos relacionados ao ciclo de desenvolvimento
e manutenção de software. Métricas de projeto indicam se a execução do
processo está progredindo conforme planejado (por exemplo, relação entre o
tamanho do software entregue e o esforço total dispendido em seu
desenvolvimento).

Métricas de produto medem atributos de produtos e artefatos, como documentos,
diagramas, código-fonte e arquivos binários. Neste trabalho,
apenas métricas de produto serão utilizadas.

Métricas de produto podem ser classificadas em internas (medem propriedades
visíveis apenas aos desenvolvedores) ou externas (medem propriedades visíveis
aos usuários) \cite{Mohamed1994}.

Neste trabalho, são utilizadas métricas de produto e, especificamente,
métricas de código-fonte, que cobrem aspectos de tamanho, complexidade e
qualidade que podem ser medidos a partir do código-fonte de um software.

\subsection{Métricas de código-fonte} \label{metricas-de-codigo}

As propriedades visíveis aos desenvolvedores podem ser medidas através de
métricas de código-fonte. A observação e o monitoramento de seus valores podem
indicar aspectos relevantes à manutenibilidade de um programa. Dentre as
inúmeras métricas de código-fonte iremos destacar aquelas utilizadas no estudo
de \citeonline{Meirelles2013} onde associou-se características de qualidade de
produto de software à características de qualidade de código-fonte através da
observação de suas métricas, são elas:

\begin{itemize}
  \item {\bf ACC} {\it Aferent Connections per Class (Conexões aferentes de
    uma classe)}: mede a conectividade de uma classe \cite{Brito1994}.
  \item {\bf ACCM} {\it Average Cyclomatic Complexity per Method (Média de
    complexidade ciclomática por método)}: mede a complexidade do programa
    \cite{McCabe1976}.
  \item {\bf AMLOC} {\it Average Method LOC (Média do número de linhas de
    código por método)}: indica se o código está bem distribuído entre os
    métodos, quanto maior mais ``pesados'' são os métodos.
  \item {\bf ANPM} {\it Average Number of Parameters per Method (Média do
    Número de Parâmetros por Método)}: calcula a média de parâmetros dos
    métodos da classe \cite{Jagdish1997}.
  \item {\bf CBO} {\it Coupling Between Objects (Acoplamento entre objetos)}:
    mede o acoplamento entre objetos do software \cite{Chidamber1994}.
  \item {\bf DIT} {\it Depth of Inheritance Tree (Profundidade da árvore de
    herança)}: mede o número de ancestrais de uma classe \cite{Shih1997}.
  \item {\bf LCOM4} {\it Lack of Cohesion in Methods (Ausência de coesão em
    métodos)}: mede o grau de falta de coesão em métodos \cite{Hitz1995}.
  \item {\bf LOC} {\it Lines of Code (Número de linhas de código)}: mede o
    número de linhas excluindo linhas em branco e comentários
    \cite{Lorenz1994}.
  \item {\bf NOA} {\it Number of Attributes (Número de atributos)}: número de
    atributos de uma classe \cite{Kolewe1993}.
  \item {\bf NOC} {\it Number Of Children (Número de filhos)}: número total de
    filhos de uma classe \cite{Rosenberg1997}.
  \item {\bf NOM} {\it Number of Methods (Número de métodos)}: mede o tamanho
    das classes em termos das suas operações implementadas.
  \item {\bf NPA} {\it Number of Public Attributes (Número de atributos
    públicos)}: mede o encapsulamento \cite{Jagdish1997}.
  \item {\bf NPM} {\it Number of Public Methods (Número de métodos públicos)}:
    representa o tamanho da ``interface'' da classe \cite{Jagdish1997}.
  \item {\bf RFC} {\it Response For a Class (Resposta para uma classe)}:
    número de métodos dentre todos os métodos que podem ser invocados em
    resposta a uma mensagem enviada por um objeto de uma classe
    \cite{Sharble1993}.
  \item {\bf SC} {\it Structural Complexity (Complexidade estrutural)}: mede a
    complexidade do software \cite{Darcy2005}.
\end{itemize}

\subsection{Complexidade estrutural} \label{complexidade}

A complexidade estrutural (SC - Structural Complexity) de um programa é uma
medida calculada através da combinação das métricas de acoplamento (CBO) e
coesão (LCOM4).  Esta medida é, possivelmente, um indicativo de problemas na
manutenibilidade de sistemas de software, em especial sobre o esforço
necessário para atividades de manutenção \cite{Terceiro2012}. Ela está
relacionada a como os módulos de um programa estão organizados bem como à
estrutura interna de cada módulo.

Esta métrica pode dar indícios importantes sobre características arquiteturais
de um programa de software e pode explicar seus atributos de qualidade
interna.

%\section{Pensar em título - fundamentos de matemática e estatística}
%
%(nao criar este capitulo agora, ficara no nivel de proposta, discutris na
%analise dos resultados, mas fica como proposta ainda, devo descrever no texto
%isso como passos a serem amadurecidos ainda, apresento como primeira analise
%expliratoria que basicamente replica meirelles, explicar abordagem de paulo
%, se aprenda observar metrica dentro de contexto, ..., ou de um projeto ao
%longo do tempo)
%
%\subsection{Distância Euclidiana}
%\subsection{etc}

%------------------------------------------------------%
\xchapter{Metodologia}{} \label{metodologia}

%Antes de falar dos trabalhos relacionados, deve-se ter uma introdução no
%capítulo de metodologia resgatando o problema tratado pelo trabalho e que tem
%estudos da área etc etc...

O objetivo principal deste trabalho é compreender as ferramentas de software
para análise estática de código-fonte, de forma à interpretar suas
características de qualidade interna a fim de servirem como referência para
desenvolvedores em atividades de evolução e manutenção em ferramentas deste
mesmo domínio.

A seção \ref{trabalhos-relacionados} traz trabalhos relacionados à compreensão
e observação de atributos de qualidade interna de programas. A seção
\ref{hipoteses} detalha como as hipóteses serão testadas. A seção
\ref{planejamento} descreve o planejamento de estudo e os passos iniciais de
coleta de dados. A seção \ref{coleta} detalha a coleta de dados e a seção
\ref{analise} traz informações de como estes dados serão analisados e
interpretados.

\section{Trabalhos relacionados} \label{trabalhos-relacionados}

%Terceiro, Kecia Ferreira, \cite{Ferreira2009}
%
%Terceiro todos os artigos, .... mostrar e evolucao do trabalho dele ate chegar
%na caractrizacao da complexidade estrutural.
%
%O da Kecia posso pegar a inspiracao no trabalho de Paulo, pode n dar tempo de
%eu entrar nos artigos.. (ler os trab relacionados da tese de paulo).

\citeonline{Meirelles2013} apresenta argumentos para se observar a qualidade
do software através das métricas de código-fonte, associa qualidade do
software à qualidade do código. Afirma que uma maneira objetiva de se observar
as características de um código-fonte é analisando os valores de suas métricas
e alerta para o pouco uso de métricas por parte dos desenvolvedores no ciclo
de desenvolvimento, ele indica que um dos motivos desta sub-utilização
é a falta de conhecimento de como coletar automaticamente
os valores das métricas, interpretar os seus resultados e os associar à
qualidade do código-fonte. Assim, desenvolveu uma abordagem para identificar
valores de métricas de forma a servirem como referência para projetos futuros,
onde analisa estatísticamente a correlação entre as métricas e define um
subconjunto reduzido que podem ser monitoradas ao longo do tempo e
ainda oferecer uma boa visão do projeto.

\citeonline{Terceiro2010} chamam a atenção para a importância de medir e
compreender aspectos de qualidade interna de software, uma vez que tais
questões impactam fortemente em atividades de evolução e manutenção. Eles
afirmam que quanto menor a qualidade de código-fonte, maior será o esforço de
mantê-lo. Uma das formas de medir qualidade interna é em função da
complexidade estrutural, uma medida que leva em conta a relação entre o
acoplamento e coesão dos módulos de um programa.

Complexidade estrutural representa um aspecto arquitetural importante e envolve
tanto a organização interna dos módulos quanto a relação entre eles. Uma alta
complexidade estrutural faz projetos de software mais difíceis de entender, e
por isto mesmo, mais difíceis de manter e evoluir.

%Mas um outro aspecto tem sido constantemente associado
%à complexidade de software, este aspecto é o tamanho de um sistema, ele
%representa um fator importante nos estudos sobre evolução de software.
%Tamanho do sistema definitivamente eh um atributo que deve ser observado por
%pesquisadores e profissionais de software. Alem de senso comum observar que
%sistemas grandes sao mais dificeis de lidar, muitos acreditam que existe uma
%associacao entre tamanho e complexidade.

Não podemos perder de vista, no entanto, que projetos diferentes são
influenciados por fatores diferentes, de forma que a observação dos aspectos
de qualidade interna devem ser observados e interpretados separadamente por
projeto \cite{Terceiro2012Understanding} ou ao menos por domínio de
aplicação \cite{Meirelles2013}.

O domínio de aplicação análise estática, por exemplo, carece de observação
detalhada sobre aspectos de qualidade interna de suas ferramentas. A
área tem se desenvolvido rapidamente com novos métodos, técnicas e ferramentas
para os mais diversos fins, no entanto a comparação e avaliação de técnicas e ferramentas
não tem acompanhado tal velocidade \cite{Li2010}, e, apesar de existirem
estudos avaliando ferramentas de análise estática de código-fonte, poucos
fazem isso do ponto de vista de vista de sua qualidade interna.

Por exemplo, \citeonline{Rutar2004} compara cinco ferramentas de localização
de bugs para Java e discute as técnicas utilizadas por cada uma e seu impacto
nos resultados. \citeonline{Kratkiewicz2005} avalia cinco ferramentas de
análise estática para determinar seus pontos fortes e fracos em detecção de
falhas de buffer overflow em código C. \citeonline{Okun2007} avalia os efeitos
de ferramentas de segurança com objetivo de identificar se estas ferramentas
melhoram de fato a segurança de programas. \citeonline{Emanuelsson2008}
avaliam três ferramentas de análise estática da indústria com o objetivo de
mapear funcionalidades significativas destas ferramentas, normalmente não
fornecidas por compiladores normais. \citeonline{Wedyan2009} avaliaram três
ferramentas para verificar a efetividade de detectar falhas e predizer
refatorações. \citeonline{Mantere2009} compararam três ferramentas de análise
estática de código-fonte em relação à performance e dão subsídios para apoiar
tomada de decisão sobre seleção de ferramentas de análise estática.
\citeonline{Al2010} avaliaram quatro ferramentas de análise estática em
relação à capacidade de detectar bugs em programas concorrentes em Java e
responde se ferramentas comerciais são melhores que ferramentas {\it open
source}. \citeonline{Li2010} comparam sete diferentes ferramentas de análise
estática com foco em detecção de vulnerabilidades, comparando suas
caracteristicas através de um experimento. \citeonline{Johns2011} avaliaram a
qualidade de ferramentas de análise estática de segurança a partir de uma
série de critérios. \citeonline{Alemerien2013} avaliaram duas ferramentas de
análise estática para cálculo de métricas com objetivo de entender as
diferenças nos resultados de cada uma. \citeonline{Ataide2014} analisa os
resultados gerados por três ferramentas de análise estática que podem ser
eficientemente usadas por programadores para remover vulnerabilidades comuns
em programas.

Dentre estes estudos, a grande maioria realiza avaliação ou comparação de
ferramentas de análise estática de código-fonte levando em conta aspectos e
características de qualidade externa, o que nos leva a entender que estudos
que joguem luz sobre aspectos da qualidade interna neste domínio de aplicação
são requeridos do ponto de vista principalmente dos desenvolvedores
interessados em atividades de manutenção e evolução.

\section{Hipóteses} \label{hipoteses}

Segue como nossas hipóteses serão testadas.

A hipótese {\bf H1} ({\em É possível calcular valores de referência de
métricas de código-fonte para ferramentas de análise estática a partir de um
conjunto de softwares da academia e da indústria}) será validada a partir da
análise das métricas calculadas para cada uma das ferramentas estudadas.  Esta
análise levará em consideração a caracterização das ferramentas
(Seção~\ref{caracterizacao-das-ferramentas}), em especial, em um subconjunto
de ferramentas com melhores valores de métricas.

A hipótese {\bf H2} ({\em Ferramentas de análise estática tendem a ter uma
maior complexidade estrutural do que ferramentas de outros domínios de
aplicação}) será validada a partir da comparação com os trabalhos relacionados
(Seção \ref{trabalhos-relacionados}) que realizaram estudos similares, com
cálculo e distribuição de métricas, mas que utilizam como objeto de estudo
conjuntos ferramentas de outros domínios de aplicação.

A hipótese {\bf H3} ({\em Dentre as ferramentas de análise estática de
código-fonte, aquelas desenvolvidas na indústria apresentam uma menor
complexidade estrutural}) será validada a partir do cálculo da distância das
métricas de cada ferramenta com os valores de referências encontrados neste
estudo (Seção \ref{distancia}).

\section{Planejamento do estudo} \label{planejamento}

%\subsection{Seleção de métricas}
%
%Estas métricas serão coletadas para cada classe/módulo presente nas
%ferramentas de análise estática selecionadas e servirão de base para
%avaliar a qualidade das mesmas.
%
%(pendente) ``retomar complexidade estrutural e linkar com trabalho de
%terceiro, iremos olhar com mais detalhes algumas ferramentas e para este
%subconjunto vamos analisar a organização arquitetural dos módulos, isto
%será base para o guia de refatoração que faremos.''

\subsection{Seleção de ferramentas de análise estática} \label{levantamento}

A seleção de ferramentas de análise estática será realizada por meio de uma
busca por ferramentas desenvolvidas no contexto da academia e da indústria,
com base em critérios pré-definidos. Será feito um planejamento detalhado
para realizar a seleção de ferramentas em cada um destes contextos.

No contexto acadêmico, a busca por ferramentas será feita em artigos
publicados em conferências que tenham histórico de publicação sobre
ferramentas de análise estática de código-fonte.  Estes artigos serão
analisados e aqueles com publicação de ferramenta serão selecionados.

Na indústria, a busca por ferramentas será feita a partir da base mantida pelo
projeto SAMATE\footnote{http://samate.nist.gov} - {\em Software Assurance
Metrics and Tool Evaluation}, um projeto do NIST\footnote{http://nist.gov}
dedicado ao desenvolvimento de métodos que permitam avaliar e medir a
eficiência de ferramentas e técnicas sobre garantia de qualidade em software.
O site do projeto, disponível em \citeonline{SamateAnalysers}, mantém uma lista
de ferramentas de análise estática.

As ferramentas selecionadas serão avaliadas, com extração de
seus atributos de qualidade interna a partir do cálculo de suas métricas de
código-fonte.

\subsection{A ferramenta Analizo}

Analizo\footnote{http://analizo.org} é um {\it toolkit} livre, multi-linguagem
e extensível para análise de código-fonte, calcula uma grande quantidade de
métricas, como CBO, LCOM4, RFC, LOC, e suporta análise das linguagens de
programação C, C++ e Java.

Ela será a ferramenta utilizada por nós durante este estudo para análise do
código-fonte das ferramentas selecionadas, a decisão pela ferramenta Analizo
se deu por conta dela ser também a escolha utilizada nos trabalhos
relacionados (seção \ref{trabalhos-relacionados}) onde estamos nos apoiando,
além disso, Analizo também tem sido utilizada em diversos estudos
desenvolvidos em nosso grupo de pesquisa:

\begin{itemize}

  \item \cite{Terceiro2009} usaram as métricas calculadas pelo Analizo em um
    estudo exploratório sobre a evolução da complexidade estrutural em
    projetos de software livre escritos em C.

  \item \cite{Morais2009} usou a ferramenta de cálculo de métricas do Analizo
    como um backend para o software de avaliação de métricas Kalibro.

  \item \cite{Terceiro2010} usou a funcionalidade de processamento do histórico
    de metricas para analizar a história completa de mudanças em 7 projetos de
    servidor web.

  \item \cite{Meirelles2010} usou a ferramenta de processamento em lote do
    analizo para analisar mais de 6000 projetos de software livre.

  \item \cite{Ronaldo2015} utilizou o cálculo de métricas do Analizo para
    estudar a ecoluçao da API do sistema operacional Android e seus aplicativos.

\end{itemize}

A seleção de ferramentas a serem estudadas neste trabalho de pesquisa tomará
como um dos critérios de escolha as linguagens de programação suportadas pelo
Analizo, ou seja, apenas ferramentas escritas em C, C++ ou Java farão parte do
nosso estudo.

Analizo é uma ferramenta mantida constantemente, com desenvolvedores ativos, e
atualizações frequentes, sua última versão 1.19.0 foi lançada (no escopo deste
trabalho) em 18 de
Fevereiro de 2016 e será esta a versão utilizada neste estudo.

\subsection{Revisão estruturada} \label{revisao-estruturada}

A revisão estruturada é um processo disciplinado para seleção de artigos a
partir de critérios bem definidos, de forma que seja possível a reprodução do
estudo por parte de pesquisadores interessados.

A revisão está organizada em atividades de (1) busca de artigos (definição
das fontes de busca, definição de critérios de busca, definição de script de
busca, realização da busca nas fontes) e (2) seleção de artigos. 

No primeiro passo da revisão estruturada, as fontes de busca serão definidas,
considerando conferências que abordam o tema de interesse do estudo. 

A busca textual será realizada automaticamente, utilizando um
script\footnote{http://github.com/joenio/dissertacao-ufba-2016/blob/master/revisao-estruturada/filter}
escrito especialmente para este estudo. Esta busca seleciona os artigos que
contenham os seguintes termos:

\begin{verbatim}
  "tool" OU "framework"; E
  "download" OU "available"; E
  "http" OU "ftp"; E
  "static analysis" OU "parser".
\end{verbatim}

Uma cópia local de todos os artigos encontrados, em formato PDF, será feita.

No segundo passo, a seleção de artigos será feita com base nos artigos
encontrados pela busca no passo anterior.  Nesta seleção, pretende-se
identificar se cada artigo resulta, de fato, em publicação de ferramenta de
análise estática. Uma vez que se confirme que o artigo publica uma
ferramenta, este artigo será incluído para leitura. Ferramentas que sejam
mais abrangentes do que apenas análise estática mas que contenham esta função
em seu conjunto também serão selecionadas.

Uma vez identificados os artigos que publicaram ferramentas de análise
estática, procuramos no próprio artigo por referências de onde encontrar o
código-fonte da ferramenta. Neste contexto, algumas ações serão tomadas a
partir de algumas situações.

\begin{itemize}

  \item Se os autores afirmam que a ferramenta está disponível mas o artigo
    não contém referências de onde encontrar o código-fonte, então estes
    autores serão contactados, por email, solicitando informações sobre como
    obter o código-fonte da ferramenta.

  \item Se o artigo indica onde obter o código-fonte da ferramenta, mas o acesso ao local
    indicado não está disponível, ou está disponível mas o software não se
    encontra lá, então os autores serão contactados, solicitando informações
    atualizadas sobre como obter uma cópia do código-fonte da ferramenta.

  \item Artigos que indicam onde obter o código-fonte da ferramenta e a referência
    está correta. Será feito o {\it download} do código-fonte da última versão
    disponível.

\end{itemize}

Uma vez que os autores contactados por email respondam com informações sobre
como obter o software, iremos adicionar a ferramenta ao conjunto de ferramentas
a serem analisadas.

Por fim, a ferramenta livre {\it
sloccount}\footnote{http://www.dwheeler.com/sloccount} será  utilizada para
identificar a linguagem de programação usada na implementação de cada
ferramenta selecionada.  A identificação da linguagem de programação é
necessária, pois apenas as ferramentas implementadas nas linguagens de
programação suportadas pela ferramenta Analizo serão consideradas.

\section{Coleta de dados} \label{coleta}

Serão realizadas duas etapas para identificar e mapear as ferramentas de
análise estática com código-fonte disponível: uma atividade para seleção de
ferramentas da academia, descrita na Seção \ref{ferramentas-da-academia}, e
outra atividade para seleção de ferramentas da indústria, descrita na Seção
\ref{ferramentas-da-industria}.

As ferramentas selecionadas para o estudo serão analisadas com Analizo para
extração dos valores de métricas de código-fonte.  Esta análise utilizará o
comando {\it metrics} do Analizo, que calcula métricas globais de projeto e
métricas por módulos. Este estudo levará em consideração a distribuição das
métricas por módulos.

\subsection{Ferramentas da academia} \label{ferramentas-da-academia}

A seleção de ferramentas da academia será relizada por meio de uma revisão
estruturada (seção~\ref{revisao-estruturada}). A fonte de busca para artigos
será a conferência SCAM - Source Code Analysis and Manipulation Working
Conference\footnote{http://www.ieee-scam.org} e mais uma dentre as seguintes
conferências:

\begin{itemize}
  \item ASE - Automated Software
    Engineering\footnote{http://ase-conferences.org}
  \item CSMR\footnote{A conferência CSMR tornou-se SANER - Software Analysis,
    Evolution, and Reengineering a partir da edição 2015.} - Conference on
    Software Maintenance and
    Reengineering\footnote{http://ansymore.uantwerpen.be/csmr-wcre}
  \item ICSME - International Conference on Software Maintenance and
    Evolution\footnote{http://www.icsme.org}
\end{itemize}

Todas estas conferências possuem trilhas para publicação de ferramentas e tem
como tema, áreas de estudo relacionadas à análise de programa e análise
estática, o que representa um grande potencial de encontrarmos ferramentas de
análise estática de código-fonte publicadas em suas mais de 20 edições. A
decisão de incluir apenas mais uma conferência além da conferência SCAM se
justifica pelo pouco tempo que temos para concluir este trabalho, de forma que
não seria viável incluir mais fontes.

Após download do código-fonte de cada ferramenta selecionada, em sua versão
mais recente, a ferramenta Analizo será utilizada para a coleta das métricas. 

\subsection{Ferramentas da indústria} \label{ferramentas-da-industria}

A seleção de ferramentas da indústria será feita de forma não estruturada a
partir de uma busca livre e manual no site do projeto SAMATE. As ferramentas
com código-fonte disponível, implementadas nas linguagens de programação
suportadas pelo Analizo serão selecionadas.

Após download do código-fonte de cada ferramenta selecionada, em sua versão
mais recente, a ferramenta Analizo será utilizada para a coleta das métricas. 

\section{Análise de dados} \label{analise}

Os dados coletados incluem métricas de código-fonte para cada módulo/classe de
cada ferramenta selecionada, tanto da indústria quanto da academia. As
métricas a serem analisadas e interpretadas são as métricas descritas na Seção
\ref{metricas-de-codigo}.

A linguagem R \cite{Ihaka1996}, uma linguagem de programação para cálculos
estatísticos e gráficos, será utilizada para manipulação de dados, criação de
tabelas e plotagem de gráficos. Todos os cálculos em linguagem R utilizados
neste trabalho estão disponíveis
em nosso repositório\footnote{https://github.com/joenio/dissertacao-ufba-2016/blob/master/qualificacao.R}.

\subsection{Distribuição dos valores das métricas}

Iremos calcular os percentis de cada métrica para cada ferramenta a partir dos
valores das métricas dos seus módulos, um percentil é a centésima parte dos
dados ordenados de forma crescente, iremos calcular os percentis 1, 5, 10, 25,
50, 75, 90, 95 e 99, e dentre eles iremos discutir os resultados em função dos
percentis 75, 90 e 95, assim como feito por \citeonline{Meirelles2013},
correspondendo a valores muito frequentes, frequentes e pouco frequentes,
respectivamente.

Esta discussão irá nos fornecer como resultado intervalos de referência para
métricas de código-fonte neste domínio de aplicação, estes intervalos serão
definidos a partir da interpretação manual dos percentis e serão analisados
usando modelos de regressão a fim de serem compreendidos e validados, uma
comparação com intervalos encontrados nos trabalhos relacionados (seção
\ref{trabalhos-relacionados}) também será realizada com objetivo de reforçar
estes valores.

\subsection{Cálculo de distância e modelo de aproximação} \label{distancia}

A partir da distribuição das métricas nos percentis 75, 90 e 95 e dos
intervalos de referência encontrados propomos uma abordagem para calcular o
quão distante cada ferramenta se encontra destes intervalos.  Esta abordagem
terá como base um fator de aproximação chamado {\it score} de similaridade,
este {\it score} será primeiramente calculado para os intervalos de referência
e servirão como base de comparação para o cálculo da distância de cada
ferramenta.

O {\it score} de similaridade será calculado a nível de projeto, ou seja,
teremos um único valor para cada ferramenta calculado a partir de suas várias
métricas. Para isto, iremos abstrair o significado individual de cada métrica,
o que pode não ser muito efetivo já que diferentes métricas possuem diferentes
grandezas. Para resolver este problema será feita uma normalização dos valores
das várias métricas a fim de deixá-las num mesmo intervalo, com uma certa
equivalência, seguindo uma ideia semelhante ao que é feito com a distância
euclidiana, onde todas as variáveis tem suas distâncias unificadas em um único
valor.

Os valores do {\it score} calculados a partir dos intervalos de referência
serão centralizados em 0, indicando o centro de comparação para o cálculo da
distância com cada ferramenta, desta forma, ferramentas com {\it score} acima
de 0 indicam valores piores em relação aos intervalos de referência, e
ferramentas com {\it score} abaixo de 0 indicam valores melhores do que os
intervalos de referência.

\subsection{Caracterização das ferramentas} \label{caracterizacao-das-ferramentas}

\citeonline{Novak2010} através de um estudo para construção de uma taxonomia
para ferramentas de análise estática propuseram uma classificação para
ferramentas a partir das seguintes categorias:

\begin{description}

  \item {\it Entrada - quais tipos de arquivos podem ser carregados na ferramenta:}
    \begin{itemize}
      \item Código-fonte - arquivos de código texto podem ser carregados
      \item Byte code - arquivos com Java Byte Code ou Microsoft
      \item Linguagem intermediária (MSIL) pode ser carregada
    \end{itemize}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
      \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
      \item Obsoleta 0 vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagens suportadas - quais linguagens de programação a ferramenta suporta:}
    \begin{itemize}
      \item .NET - todas as linguagens compiladas em bibliotecas ou programas no framework .NET
      \item VB .NET - suporta VB.NET
      \item C\# - suporta C\#
      \item Java - suporta linguagem de programação Java
      \item C, C++ - suporta linguagem de programação C ou C++
    \end{itemize}

  \item {\it Tecnologia - quais tecnologias são usadas para procurar erros no código:}
    \begin{itemize}
      \item Dataflow - busca por erros com dataflow
      \item Sintaxe - busca por errors de sintaxe e correctness
      \item Prova de teoremas - procurar erros em provar diferentes teoremas
      \item Verificação de modelos - procurar erros com verificação de modelo
    \end{itemize}

  \item {\it Regras - conjunto de regras, quais são suportadas por diferentes código estático:}
    \begin{itemize}
      \item Estilo - inspeciona a aparência do código-fonte
      \item Naming - checa se as varáveis são nomeadas corretamente (ortografia, padroes de nomenclatura, ...)
      \item Geral - regras gerais de analise estática de código
      \item Concorrencia - erros com execução de código de concorrente
      \item Exceções - erros lançando ou não exceções
      \item Performance - erros de performance das aplicações
      \item Interoperabilidade - erros de comportamento comum
      \item Segurança - erros que podem impactar na segurança da aplicação
      \item SQL - procurar por "SQL injections" e outros erros de SQL
      \item Buffer overflow - erros de segurança, que explorar buffer overflow
      \item Manutenabilidade - regras para melhor manutenabilidade da aplicação
    \end{itemize}

  \item {\it Configurabilidade - habilidade de configurar a ferramenta:}
    \begin{itemize}
      \item Documento texto - comfiguração é feita via documento texto
      \item XML - configuração pe feita por documento XML
      \item GUI - configuraçãi é feita via interface gráfica
      \item Ruleset - ferramenta pode ligar/desligar conjunto de regras
    \end{itemize}

  \item {\it Extensibilidade - se a ferramenta pode ser extendida com regras próprias:}
    \begin{itemize}
      \item Possível - é possível extender
      \item Não possível - não é possível extender
    \end{itemize}

  \item {\it Disponibilidade - de que forma a ferramenta está disponível:}
    \begin{itemize}
      \item Código Aberto ({\it Open Source}) - a ferrament é livre e o código-fonte está disponível
      \item Grátis ({\it Free}) - a ferramenta é grátis mas o código-fonte não está disponível
      \item Comercial - a ferramenta está disponível mediante pagamento
    \end{itemize}

  \item {\it Experiência do usuário - de que forma a ferramenta pode ser usada, como é oferecida:}
    \begin{itemize}
      \item Integração com ambiente - como a ferramenta é integrada ao ambiente de trabalho
      \item Localização automática de erros no código - quando a ferramenta encontra um erro, ela leva ao local do erro
      \item Ajuda abrangente sobre falhas - se a ferramenta oferece ajuda na resolução de erros
      \item Interface de usuário - disponibilidade de uma interface de usuário
      \item Linha de comando - ela pode ser executada via linha de comando
      \item GUI - a ferramente pode ser executada em uma interface gráfica (GUI)
    \end{itemize}

  \item {\it Saída - representação dos resultados da ferramenta:}
    \begin{itemize}
      \item Arquivo texto - ferramenta pode apresentar resultados em arquivos texto
      \item Lista - ferramenta pode apresentar resultados numa interface de usuário customizada controlada em GUI
      \item Arquivo XML - ferramenta pode apresentar resultados em dados XML
      \item Arquivo HTML - ferramenta pode apresentar resultados em dados HTML
    \end{itemize}

\end{description}

Iremos utilizar algumas destas categorias na caracterização das ferramentas
selecionadas neste estudo, e vamos também caracterizar em relação à linguagem de
programação a qual foi escrita.

O Apêndice \ref{caracterizacao-ferramentas} traz uma caracterização inicial
das ferramentas segundo às categorias acima.

\section{Cronograma} \label{cronograma}

\begin{table}[h!]
  \centering
  \begin{tabular}{| l | c | c | c | c | c |}
    \hline
    {\bf Atividade}                                & Jul     & Ago       & Set      & Out      & Nov      \\
    \hline
    \hline
    Qualificação                                   &\checkmark&          &          &          &          \\
    \hline
    Análise da distribuição das métricas           &\checkmark&          &          &          &          \\
    \hline
    Definição dos valores de referência            &          &\checkmark&          &          &          \\
    \hline
    Cálculo de distância e modelo de aproximação   &          &\checkmark&          &          &          \\
    \hline
    Revisão estruturada com mais uma conferência   &          &\checkmark&          &          &          \\
    \hline
    Adicionar coleta/análise com novas ferramentas &          &          &\checkmark&          &          \\
    \hline                                                                                     
    Caracterização das ferramentas                 &          &          &\checkmark&          &          \\
    \hline                                                                                     
    Caracterização da complexidade estrutural      &          &          &          &\checkmark&          \\
    \hline                                                                                     
    Evolução da ferramenta Analizo                 &\checkmark&\checkmark&\checkmark&\checkmark&\checkmark\\
    \hline
    Defesa                                         &          &          &          &          &\checkmark\\
    \hline
  \end{tabular}
\end{table}

%------------------------------------------%
\xchapter{Conclusões}{} \label{conclusoes}

\section{Resultados preliminares}

\subsection{Revisão estruturada}

Realizamos uma busca por ferramentas na conferência SCAM, onde 315 artigos
foram avaliados em duas etapas referentes as duas atividades da revisão
estruturada: (1) busca automatizada a partir do script de busca e (2) seleção
a partir da leitura do artigo. A primeira etapa resultou em 133 artigos,
destes apenas 9 foram selecionados na segunda etapa, resultando daí 9
ferramentas de análise estática com disponibilidade de código-fonte.
A Tabela \ref{artigos-do-scam} apresenta um resumo desta revisão estruturada.

\begin{table}[H]
\caption{Total de artigos analisados em cada edição do SCAM}
\centering
\begin{tabular}{| l | c | c | c |}
\hline
Edição    & Total de artigos & (1) Busca & (2) Seleção \\
\hline
SCAM 2001 & 23    & 6         & -           \\
SCAM 2002 & 18    & 6         & -           \\
SCAM 2003 & 21    & 7         & -           \\
SCAM 2004 & 17    & 3         & -           \\
SCAM 2005 & 19    & 7         & -           \\
SCAM 2006 & 22    & 9         & 2           \\
SCAM 2007 & 23    & 7         & 1           \\
SCAM 2008 & 29    & 14        & -           \\
SCAM 2009 & 20    & 10        & -           \\
SCAM 2010 & 21    & 15        & 1           \\
SCAM 2011 & 21    & 9         & 1           \\
SCAM 2012 & 22    & 12        & 3           \\
SCAM 2013 & 24    & 12        & -           \\
SCAM 2014 & 35    & 16        & 1           \\
SCAM 2015 & 30    & 18        & 0           \\
\hline
Total     & 315   & 133       & 9           \\
\hline
\end{tabular}
\label{artigos-do-scam}
\end{table}

\subsection{Seleção e caracterização das ferramentas}

Junto à revisão estruturada para seleção de ferramentas da academia, fizemos
uma seleção manual no catálogo de ferramentas de análise estática do projeto
SAMATE\footnote{https://samate.nist.gov/index.php/Source\_Code\_Security\_Analyzers.html}
para encontrar ferramentas da indústria, nesta seleção os critérios foram,
ferramentas com código-fonte disponível, implementadas nas linguagens de
programação suportadas pelo Analizo. Nesta seleção, de um total de 54 ferramentas
presentes no catálogo do projeto SAMATE, 19 tinham código-fonte
disponível, destas apenas 14 eram suportadas pelo Analizo.

De forma que somando as ferramentas selecionadas na academia e na indústria
temos um total de 23 ferramentas, 14 da indústria e 9 da academia.  A
Tabela \ref{total-de-ferramentas} resume este total trazendo o nome de cada
ferramenta e a linguagem de programação em que é escrita.

\begin{table}[H]
  \caption{Ferramentas selecionadas e em qual linguagem é escrita}
  \centering
  \begin{tabular}{| c | l | l | c | l | l |}
    \hline
    \# & Ferramentas da indústria & Linguagem  & n  & Ferramentas da academia & Linguagem  \\
    \hline
    1  & Clang Static Analyzer    & cpp       & 15 & AccessAnalysis          & java       \\
    2  & Closure Compiler         & java      & 16 & error-prone             & java       \\
    3  & Cppcheck                 & cpp       & 17 & Indus                   & java       \\
    4  & CQual                    & ansic     & 18 & InputTracer             & ansic      \\
    5  & FindBugs                 & java      & 19 & JastAdd                 & java       \\
    6  & FindSecurityBugs         & java      & 20 & Sonar Qube Plug-in      & java       \\
    7  & Jlint                    & cpp       & 21 & srcML                   & cpp        \\
    8  & Pixy                     & java      & 22 & TACLE                   & java       \\
    9  & PMD                      & java      & 23 & WALA                    & java       \\
    10 & RATS                     & ansic     &    &                         &            \\
    11 & Smatch                   & ansic     &    &                         &            \\
    12 & Splint                   & ansic     &    &                         &            \\
    13 & UNO                      & ansic     &    &                         &            \\
    14 & WAP                      & java      &    &                         &            \\
    \hline
  \end{tabular}
  \label{total-de-ferramentas}
\end{table}

Para cada uma dessas 23 ferramentas selecionadas foi realizado uma caracterização
inicial em relaçao à categoria {\it Lançamentos ({\it Releases}) - quantos lançamentos
por ano}, identificando se é:

\begin{itemize}
  \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
  \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
  \item Obsoleta 0 vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
\end{itemize}

Os detalhes desta caracterização são apresentados no Apêndice \ref{caracterizacao-ferramentas}.

\subsection{Análise exploratória dos valores das métricas}

A distribuição dos percentis das métricas nos mostram numa análise inicial que
para a maioria das métricas será difícil encontrar um padrão de intervalos de
referência para as ferramentas, mostrando valores sem significado, valor 0,
para algumas ferramentas em algumas métricas.

%% begin.rcode metricas-academia-90, fig.align='center', results="asis"
% table_percentil('90%', 'valores das métricas no percentil 90 para as ferramentas da academia')
%% end.rcode

%% begin.rcode metricas-industria-90, fig.align='center', results="asis"
% table_percentil_nist('90%', 'valores das métricas no percentil 90 para as ferramentas da indústria')
%% end.rcode

%% begin.rcode grafico-comparativo, fig.show='hold', fig.cap="distribuição dos percentis para as ferramentas da academia e da indústria"
% par(mfrow=c(2,2), oma=c(0,0,0,0))
%
% table = data.frame(percentis_by_project("lcom4"), percentis_by_nist_project("lcom4"))
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="lcom4")
%
% table = data.frame(percentis_by_project("cbo"), percentis_by_nist_project("cbo"))
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="cbo")
%
% table = data.frame(percentis_by_project("acc"), percentis_by_nist_project("acc"))
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="acc")
%
% table = data.frame(percentis_by_project("sc"), percentis_by_nist_project("sc"))
% matplot(table, type="l", pch=1, xlab="percentis", ylab="valor", xaxt="n", cex.lab=0.6, cex.axis=0.6, cex.sub=0.6, cex.main=0.6)
% axis(1, at=1:length(rownames(table)), labels=rownames(table), cex.axis=0.6)
% title(main="sc")
%% end.rcode

Até o momento a análise e interpretação das métricas não mostrou ter
diferenças significativas entre ferramentas da academia e da indústria.

Mas os percentis 75, 90 e 95 se mostram como boa escolha para evitar os pontos
fora da curva e valores enviesados.

\section{Próximos passos}

Os próximos passos estão concentrados no estudo dos valores de distribuição
das métricas nos percentis 75, 90 e 95, comparar os valores e comportamentos
encontrados em nossos dados com os trabalhos de referência sobre valores de
métricas de código-fonte e sua discussão sobre a qualidade interna.

Numa primeira análise foram encontrados valores para algumas métricas bastante
discrepantes, isto denunciou que o código-fonte de algumas ferramentas foram
obtidos de forma incorreta, o que nos levou a analisar novamente tais
ferramentas para extração de suas métricas, estas ferramentas foram deixadas
de fora desta análise inicial pois estamos coletando suas métricas ainda. A
coleta de métricas pode levar horas ou dias, dependendo do tamanho do software
analisado.

%------------------------------------------%

\backmatter
\bibliography{bibliografia}
\appendix

\xchapter{Caracterização das ferramentas}
{Caracterização inicial das ferramentas selecionadas a partir da revisão estruturada.}
\label{caracterizacao-ferramentas}

\section{AccessAnalysis}

AccessAnalysis é um plugin do Eclipse de análise estática 
para cálculo das métricas IGAT e IGAM
publicadas no artigo ``AccessAnalysis — A Tool for Measuring the
Appropriateness of Access Modifiers in Java Systems'' do SCAM 2012,
disponível em \url{http://accessanalysis.sourceforge.net}. O código-fonte
utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{AccessAnalysis-1.2-src.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos    \\
        \hline
        2012 & 1.2, 1.1, 1.0  \\
        2010 & 0.17           \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta 0 vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{error-prone}

error-prone é uma ferramenta de localização de bugs construída em cima do
compilador {\it javac} publicada no artigo ``Building Useful Program Analysis
Tools Using an Extensible Java Compiler'' do SCAM 2012 disponível em
\url{http://code.google.com/p/error-prone}. O código-fonte utilizado em nosso
estudo obtido no site da ferramenta foi o \texttt{error-prone-2.0.9.tar.gz}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                          \\
        \hline
        2016 & 2.0.9, 2.0.8                                         \\
        2015 & 2.0.7, 2.0.6, 2.0.5, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{Indus}

Indus é uma biblioteca de {\it program
slicing}\footnote{http://en.wikipedia.org/wiki/Program\_slicing} publicada no
artigo ``An Overview of the Indus Framework for Analysis and Slicing of
Concurrent Java Software'' do SCAM 2006, disponível em
\url{http://indus.projects.cis.ksu.edu}.  O projeto está organizado em três
módulos, os seguintes arquivos, contendo o código-fonte dos três módulos,
foram obtidos no site do projeto para análise:
\texttt{indus.indus-src-20091220.zip},
\texttt{indus.javaslicer-src-20091220.zip} e
\texttt{indus.staticanalyses-src-20070305.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                              \\
        \hline
        2007 & 0.8.1, 0.8.3.10, 0.8.3.11, 0.8.3.12, 0.8.3.15, 0.8.3.1, 0.8.3.6, 0.8.3.7, 0.8.3, 0.8 \\
        2006 & 0.7.0, 0.7.1, 0.7.2.2, 0.7.2             \\
        2005 & 0.6.1, 0.6.2, 0.6.3, 0.6.4.1, 0.6.4, 0.5 \\
        2004 & 0.3, 0.2, 0.1, 0.1a                      \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{InputTracer}

InputTracer é uma ferramenta de análise dinâmica de binários x86 em Linux
publicado no artigo ``InputTracer: A Data-flow Analysis Tool for Manual
Program Comprehension of x86 Binaries'' do SCAM 2012 disponível em:
\url{http://www.ida.liu.se/divisions/adit/security/InputTracer}. O
código-fonte utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{valgrind-inputtracer.tar.gz}.  Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                       \\
        \hline
        2011 & 3.6.1                             \\
        2010 & 3.6.0                             \\
        2009 & 3.5.0, 3.4.1, 3.4.0               \\
        2008 & 3.3.1                             \\
        2007 & 3.3.0, 3.2.3, 3.2.2               \\
        2006 & 3.2.1, 3.2.0, 3.1.1               \\
        2005 & 3.1.0, 3.0.1, 3.0.0, 2.4.1, 2.4.0 \\
        2004 & 2.2.0, 2.2.0, 2.1.2, 2.1.1        \\
        2003 & 2.1.0, 2.0.0, 1.9.6, 1.9.5        \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{JastAdd}

JastAdd é um sistema para análise de código-fonte através da descrição de
atributos via gramática de atributos (AG) publicado no artigo ``Extending
Attribute Grammars with Collection Attributes – Evaluation and Applications''
do SCAM 2007 disponível em \url{http://jastadd.cs.lth.se/web}. O código-fonte
utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{jastadd2-src.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                              \\
        \hline
        2016 & 2.2.2, 2.2.1, 2.2.1, 2.2.0               \\
        2015 & 2.1.13, 2.1.12, 2.1.11                   \\
        2014 & 2.1.10, 2.1.9, 2.1.8, 2.1.7              \\
        2013 & 2.1.6, 2.1.5, 2.1.4, 2.1.3, 2.1.2, 2.1.1 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{Sonar Qube Plug-in}

Sonar Qube Plug-in é um plugin para o SourceMeter que extende a análise de
código Java com o uso do SonarQube publicado no artigo ``SourceMeter SonarQube
plug-in'' do SCAM 2014 disponível em:
\url{http://github.com/FrontEndART/SonarQube-plug-in}. O código-fonte
utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{SonarQube-plug-in-master.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos       \\
        \hline
        2016 & 8.0               \\
        2015 & 7.0.5, 7.0.4, 7.0 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

% Não cita a licença da ferramenta, diz que é free e pode ser baixado em
% http://www.sourcemeter.com
% Licença: não livre

\section{srcML}

srcML é um formato texto para representação de código-fonte e um conjunto de
ferramentas de transformação {\it source-to-source} publicada no artigo
``Lightweight Transformation and Fact Extraction with the srcML Toolkit'' do
SCAM 2011 disponível em
\url{http://www.sdml.info/projects/srcml/trunk}\footnote{este endereço
retornou "not found" em contato com os autores por email indicaram que o
projeto foi movido para http://www.srcML.org}. O código-fonte utilizado em
nosso estudo obtido no site da ferramenta foi o \texttt{srcML-src.tar.gz}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                                     \\
        \hline
        2015 & 0.9.5                                                           \\
        2014 & 0.8.0, Trunk 19109c, Trunk 19109b, Trunk 19109                  \\
        2013 & Trunk 17088                                                     \\
        2012 & Trunk 13990, Trunk 13953, Trunk 13925, Trunk 13528, Trunk 12359 \\
        2011 & Trunk 8007, Trunk 7990, Trunk 7481                              \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C++
    \end{itemize}

\end{description}

\section{TACLE}

TACLE é um plugin do Eclipse para análise de tipo ({\it Type Analysis}) e
construção de visualizaçao de grafos de chamada ({\it Call Graph}) publicado
no artigo ``Estimating the Run-Time Progress of a Call Graph Construction
Algorithm'' do SCAM 2006 disponível em
\url{http://presto.cse.ohio-state.edu/tacle}\footnote{este link está
indisponível, por email os autores indicaram o endereço
http://web.cse.ohio-state.edu/~rountev/presto/tacle/TACLE\_Download/tacle.html}.
O código-fonte utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{tacle\_1\_2\_1\_src.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos  \\
        \hline
        2006 & 1.2.1, 1.2.0 \\
        2005 & 1.1.0, 1.0.0 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{WALA}

WALA é uma ferramenta de análise estática para {\it bytecode} Java publicado
no artigo ``Effective Static Analysis to Find Concurrency Bugs In Java'' do
SCAM 2010 disponível em
\url{http://wala.sourceforge.net/wiki/index.php/Main_Page}. O código-fonte
utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{WALA-R\_1.3.8.tar.gz}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                        \\
        \hline
        2016 & 1.3.9                              \\
        2015 & 1.3.8, 1.3.7                       \\
        2013 & 1.3.6, 1.3.5                       \\
        2012 & 1.3.4, 1.3.3                       \\
        2011 & 1.3.2                              \\
        2010 & 1.3.1                              \\
        2009 & 1.3, 1.2.2                         \\
        2008 & 1.2.1, 1.2, 1.1.3, 1.1.2           \\
        2007 & 1.1.1, 1.1, 1.0.04, 1.0.03, 1.0.02 \\
        2006 & 1.0                                \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{Clang Static Analyzer}

O {\it Clang Static Analyzer} é uma ferramenta de análise de código-fonte para
localização de bugs em códigos C, C++, e Objective-C disponível em
\url{http://clang-analyzer.llvm.org}. É distribuído junto ao código do próprio
projeto Clang\footnote{http://clang.llvm.org} e em nosso estudo utilizamos o
código em \texttt{cfe-3.7.1.src.tar.xz}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                              \\
        \hline
        2016 & 3.8.0, 3.7.1                             \\
        2015 & 3.7.0, 3.6.2, 3.6.1, 3.6.0, 3.5.2, 3.5.1 \\
        2014 & 3.5.0, 3.4.2, 3.4.1, 3.4                 \\
        2013 & 3.3                                      \\
        2012 & 3.2, 3.1                                 \\
        2011 & 3.0, 2.9                                 \\
        2010 & 2.8, 2.7                                 \\
        2009 & 2.6, 2.5                                 \\
        2008 & 2.4, 2.3, 2.2                            \\
        2007 & 2.1, 2.0                                 \\
        2006 & 1.9, 1.8, 1.7                            \\
        2005 & 1.6, 1.5                                 \\
        2004 & 1.4, 1.3, 1.2                            \\
        2003 & 1.1, 1.0                                 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C++
    \end{itemize}

\end{description}

\section{Closure Compiler}

{\it Closure Compiler} é um compilador que traduz código JavaScript em outro
JavaScript melhor e mais otimizado, está disponível em
\url{https://developers.google.com/closure/compiler}\footnote{O código fonte do
Closure Compiler pode ser obtido em:
http://github.com/google/closure-compiler} e foi utilizado em nosso estudo o
seguinte lançamento
\texttt{closure-compiler-closure-compiler-parent-v20160619.tar.gz}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                              \\
        \hline
        2016 & v20160619, v20160517, v20160315, v20160208, v20160125 \\
        2015 & v20151216, v20151015, v20150920, v20150901, v20150729, v20150609, \\
             & v20150505, v20150315, v20150126 \\
        2014 & v20141215, v20141120, v20141023, v20140923, v20140814, v20140730, \\
             & v20140625, v20140508, v20140407, v20140303, v20140110 \\
        2013 & v20131118, v20131014, v20130823, v20130722, v20130603, v20130411, \\
             & v20130227, v20110811, v20110322, v20110405, v20110119, v20111003, \\
             & v20111114, v20112023, v20120305, v20120430, v20120711, v20121212, \\
             & v20120917 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{Cppcheck}

Ferramenta de análise estática de código C/C++ para checagem de vazamento de
memória, erros de alocação, entre outras falhas. Disponível em
\url{http://sourceforge.net/projects/cppcheck}. Em nosso estudo utilizamos o
código em \texttt{cppcheck-1.72.tar.bz2}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                                \\
        \hline
        2016 & 1.74, 1.73, 1.72                                           \\
        2015 & 1.71, 1.70, 1.69 1.68                                      \\
        2014 & 1.67, 1.66, 1.65, 1.64, 1.63                               \\
        2013 & 1.62, 1.61, 1.60.1, 1.60, 1.59, 1.58                       \\
        2012 & 1.57, 1.56, 1.55, 1.54, 1.53                               \\
        2011 & 1.52, 1.51, 1.50, 1.49, 1.48, 1.47                         \\
        2010 & 1.46.1, 1.46, 1.45, 1.44, 1.43, 1.42, 1.41, 1.40           \\
        2009 & 1.39, 1.38, 1.37, 1.36, 1.35, 1.34, 1.33, 1.32, 1.31, 1.30 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C++
    \end{itemize}

\end{description}

\section{CQual}

Ferramenta de análise de typo ({\it type-based analysis}) que fornece um
mecanismo leve e prático para especificação e verificação de propriedades de
programas C. Disponível em \url{http://www.cs.umd.edu/~jfoster/cqual}. Em
nosso estudo utilizamos o código em \texttt{cqual-0.981.tar.gz}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos  \\
        \hline
        2004 & 0.981, 0.991 \\
        2003 & 0.98, 0.99   \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{FindBugs}

Uma ferramenta para localização de bugs em código Java disponível em
\url{http://findbugs.sourceforge.net}. Em nosso estudo utilizamos o código em
\texttt{findbugs-3.0.1-source.zip}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                \\
        \hline
        2015 & 3.0.1                      \\
        2014 & 3.0.0                      \\
        2013 & 2.0.3                      \\
        2012 & 2.0.2, 2.0.1               \\
        2011 & 2.0.0                      \\
        2009 & 1.3.9, 1.3.8               \\
        2008 & 1.3.7, 1.3.6, 1.3.5, 1.3.4 \\
        2007 & 1.2.1                      \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{FindSecurityBugs}

Plugin do FindBugs para auditoria de segurança em aplicações web Java,
disponível em \url{http://find-sec-bugs.github.io}.  O código-fonte utilizado
em nosso estudo obtido no site da ferramenta foi o
\texttt{findsecbugs-plugin-1.4.5-sources.jar}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                     \\
        \hline
        2016 & 1.4.6, 1.4.5                                    \\
        2015 & 1.4.4, 1.4.3, 1.4.2, 1.4.1, 1.4.0, 1.3.1, 1.3.0 \\
        2014 & 1.2.1                                           \\
        2013 & 1.2.0, 1.1.0                                    \\
        2012 & 1.0.0                                           \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{Jlint}

Uma ferramenta para verificaçao de código Java em busca de bugs,
inconsistências e problemas de sincronização disponível em
\url{http://sourceforge.net/projects/jlint}.  O código-fonte utilizado em
nosso estudo obtido no site da ferramenta foi o \texttt{jlint-3.1.2.zip}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos \\
        \hline
        2011 & 3.1.2       \\
        2010 & 3.1.1       \\
        2006 & 3.1         \\
        2004 & 3.0         \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C++
    \end{itemize}

\end{description}

\section{Pixy}

Ferramenta de análise estática de código PHP para verificação de
vulnerabilidades de segurança. Disponível em
\url{http://github.com/oliverklee/pixy}. O código-fonte utilizado em nosso
estudo obtido no site da ferramenta foi o \texttt{pixy-master.zip}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos \\
        \hline
        2012 & 3.0.3       \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{PMD}

Ferramenta de análise de código-fonte para localização falhas comuns de
programação com suporte a várias linguagens, disponível em
\url{http://pmd.github.io}.  O código-fonte utilizado em nosso estudo obtido
no site da ferramenta foi o \texttt{pmd-src-5.4.1.zip}. Características da
ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                                   \\
        \hline
        2016 & 5.5.0, 5.4.2, 5.3.7                                           \\
        2015 & 5.4.1, 5.4.0, 5.3.6, 5.3.5, 5.3.4, 5.3.3, 5.3.2, 5.3.1, 5.3.0 \\
        2014 & 5.2.3, 5.2.2, 5.2.1, 5.2.0, 5.1.3, 5.1.2, 5.1.1, 5.1.0        \\
        2013 & 5.0.5, 5.0.4, 5.0.3, 5.0.2                                    \\
        2012 & 5.0.1, 5.0.0                                                  \\
        2011 & 4.3.0, 4.2.6                                                  \\
        2009 & 4.2.5                                                         \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\section{RATS}

Ferramenta de análise estática para auditoria de segurança disponível em
\url{http://code.google.com/archive/p/rough-auditing-tool-for-security}. O
código-fonte utilizado em nosso estudo obtido no site da ferramenta foi o
\texttt{rats-2.4.tgz}. Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos \\
        \hline
        2013 & 2.4         \\
        2009 & 2.3         \\
        ??   & 1.5         \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{Smatch}

Ferramenta de análise estática para detecção de erros no Kernel disponível em
\url{http://smatch.sourceforge.net}. O código-fonte utilizado em nosso estudo
obtido no site da ferramenta foi o \texttt{smatch.git}. Características da
ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos      \\
        \hline
        2015 & 1.60             \\
        2013 & 1.59, 1.58, 1.57 \\
        2012 & 1.56             \\
        2010 & 1.55, 1.54       \\
        2009 & 1.53, 1.52, 1.51 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Ocasionalmente $<$ 3 vezes ao ano - novas versões da ferramenta são lançadas menos que 3 vezes ao ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{Splint}

Splint is a tool for statically checking C programs for security
vulnerabilities and coding mistakes Ferramenta para verificação de programas
por vulnerabilidades de segurança e erros de código. Disponível em
\url{http://www.splint.org}. O código-fonte utilizado em nosso estudo obtido
no site da ferramenta foi o \texttt{splint-3.1.2.src.tgz}. Características da
ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                        \\
        \hline
        2007 & 3.1.2                              \\
        2003 & 3.1.0                              \\
        ??   & 3.0.1.6                            \\
        2002 & 3.0.1.5                            \\
        ??   & 3.0.1.4, 3.0.1, 3.0.0.19, 3.0.0.18 \\
        ??   & 3.0.0.17, 3.0.0.15, 3.0.0.14       \\
        2001 & 3.0.0.13                           \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{UNO}

Uma ferramenta de análise de código-fonte para detecção de defeitos.
Disponível em \url{http://spinroot.com/uno}. O código-fonte utilizado em nosso
estudo obtido no site da ferramenta foi o \texttt{uno\_v213.tar.gz}.
Características da ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                       \\
        \hline
        2007 & 2.13, 2.12, 2.11                  \\
        2006 & 2.9-2.10                          \\
        2005 & 2.8, 2.7, 2.6, 2.5, 2.4           \\
        2004 & 2.3, 2.2, 2.1, 2.0, 1.7           \\
        2003 & 1.8, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Obsoleta $0$ vezes ao ano - intervalo entre novos lançamentos é maior que 1 ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item C
    \end{itemize}

\end{description}

\section{WAP}

Ferramenta para análise estática de código-fonte e mineraçao de dados para
detectar e corrigir vulnerabilidades em aplicações web. Disponível em
\url{http://awap.sourceforge.net}. O código-fonte utilizado em nosso estudo
obtido no site da ferramenta foi o \texttt{wap-2.1.tar.gz}. Características da
ferramenta:

\begin{description}

  \item {\it Lançamentos ({\it Releases}) - quantos lançamentos por ano:}
    \begin{table}[h!]
      \centering
      \begin{tabular}{| l | l |}
        \hline
        Ano  & Lançamentos                                 \\
        \hline
        2015 & 2.1, 2.0.5, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0 \\
        \hline
      \end{tabular}
    \end{table}
    \begin{itemize}
      \item Frequentemente $>=$ 3 vezes ao ano - novas versões da ferramenta são lançadas 3 ou mais vezes por ano
    \end{itemize}

  \item {\it Linguagem de programação - em qual linguagem a ferramenta é escrita:}
    \begin{itemize}
      \item Java
    \end{itemize}

\end{description}

\xchapter{Análise exploratória dos valores das métricas}{Análise e
interpretação dos valores das métricas coletadas para cada ferramenta.}

\subsection{Conexões aferentes de uma classe (ACC)}

ACC é um valor parcial de uma das métricas MOOD (Metrics for Object Oriented
Design) \cite{Brito1994} e mede o nível de acoplamento de uma classe. O
cálculo é feito através do número de classes que fazem referência a um outra
por meio de métodos ou atributos.

As Tabelas \ref{metrica-acc} e \ref{metrica-acc-industria} apresentam os
valores da métrica ACC para as ferramentas da academia e da indústria,
respectivamente.

%% begin.rcode metrica-acc, fig.align='center', results="asis"
% table = percentis_by_project("acc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACC para as ferramentas da academia", "metrica-acc")
%% end.rcode

Duas ferramentas, accessanalysis e error-prone, tiveram valor 0 no percentil
75, é estranho que 75\% das classes destas 2 ferramentas, ambas escritas em
Java, não façam acesso através de métodos ou atributos a nenhuma outra classe
do mesmo sistema.

%% begin.rcode metrica-acc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("acc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACC para as ferramentas da indústria", "metrica-acc-industria")
%% end.rcode

As ferramentas cqual e uno tiveram valores no percentil 75\% bem acima das
demais ferramentas, 24 e 34, respectivamente. Onde entre todas as outras o
maior valor foi 8.

\subsection{Média de complexidade ciclomática por método (ACCM)}

ACCM contabiliza o número de caminhos independentes que métodos de uma classe
pode seguir em sua execução. O cálculo é feito a partir do número de
estruturas condicionais encontrados nos métodos de um programa.

As Tabelas \ref{metrica-accm} e \ref{metrica-accm-industria} apresentam os
valores da métrica ACCM para as ferramentas da academia e da indústria,
respectivamente.

%% begin.rcode metrica-accm, fig.align='center', results="asis"
% table = percentis_by_project("accm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACCM para as ferramentas da academia", "metrica-accm")
%% end.rcode

Esta métrica apresenta um comportamento sem muitas exceções dentro de cada
percentil, com intervalos entre 1.0 e 2.1 para percentil 75\%, 2.0 e 3.4 para
percentil 90\% e 2.9 e 5.0 para percentil 95\%.

%% begin.rcode metrica-accm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("accm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ACCM para as ferramentas da indústria", "metrica-accm-industria")
%% end.rcode

Também entre as ferramentas da indústria esta métrica não apresenta variações
muito grandes, com intervalos entre 1.0 e 6.9 para 75\%, 2.0 e 8.9 para
percentil 90\% e entre 4.0 e 15.6 para 95\%.

\subsection{Média do número de linhas de código por método (AMLOC)}

AMLOC é a média do número de linhas dos métodos de um módulo, apenas linhas
com código executável é calculada, comentários e linhas em branco são
desconsideradas do cálculo.

As Tabelas \ref{metrica-amloc} e \ref{metrica-amloc-industria} apresentam a
métrica AMLOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-amloc, fig.align='center', results="asis"
% table = percentis_by_project("amloc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da academia", "metrica-amloc")
%% end.rcode

Os valores para ferramentas da academia não nos chama atenção para nada
especial, com intervalos entre 5.4 e 14.5 para o percentil 75\%, entre 10.7 e
31.5 pra percentil 90\% e entre 15.4 e 51.4 para 95\%.

%% begin.rcode metrica-amloc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("amloc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica AMLOC para as ferramentas da indústria", "metrica-amloc-industria")
%% end.rcode

Para a indústria os intervalos foram entre 7.0 e 36.9 para o percentil 75\%,
entre 16.0 e 62.1 para percentil 90\% e entre 22.0 e 119.7 para 95\%. A
ferramenta chama atenção por apresentr o menor valor no percentil 75\%, 7, e o
maior valor no prcentil 95\%, 119.7.

\subsection{Média do número de parâmetros por método (ANPM)}

ANPM é a média de parâmetros dos métodos de uma classe.

As Tabelas \ref{metrica-anpm} e \ref{metrica-anpm-industria} apresentam a
métrica ANPM para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-anpm, fig.align='center', results="asis"
% table = percentis_by_project("anpm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ANPM para as ferramentas da academia", "metrica-anpm")
%% end.rcode

%% begin.rcode metrica-anpm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("anpm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica ANPM para as ferramentas da indústria", "metrica-anpm-industria")
%% end.rcode

\subsection{Acoplamento entre objetos (CBO)}

CBO é a recíproca da métrica ACC e mede quantas classes são utilizadas por uma
certa classe.

As Tabelas \ref{metrica-cbo} e \ref{metrica-cbo-industria} apresentam a
métrica CBO para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-cbo, fig.align='center', results="asis"
% table = percentis_by_project("cbo")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica CBO para as ferramentas da academia", "metrica-cbo")
%% end.rcode

%% begin.rcode metrica-cbo-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("cbo")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica CBO para as ferramentas da indústria", "metrica-cbo-industria")
%% end.rcode

\subsection{Profundidade da árvore de herança (DIT)}

DIT mede a profundidade que uma classe se encontra na árvore de herança.

Os intervalos sugeridos são: até 2 (bom); entre 2 e 4 (regular); de 4 em
diante (ruim).

As Tabelas \ref{metrica-dit} e \ref{metrica-dit-industria} apresentam a
métrica DIT para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-dit, fig.align='center', results="asis"
% table = percentis_by_project("dit")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica DIT para as ferramentas da academia", "metrica-dit")
%% end.rcode

%% begin.rcode metrica-dit-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("dit")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica DIT para as ferramentas da indústria", "metrica-dit-industria")
%% end.rcode

\subsection{Ausência de coesão em métodos (LCOM4)}

LCOM4 calcula quantos conjuntos de métodos relacionados existem dentro de uma
classe, isto é, métodos que compartilham utilização de algum atributo ou que
se referenciam.

Os intervalos sugeridos para código C++ e Java são: até 2 (bom); entre 2 e 5
(regular); de 5 em diante (ruim).

As Tabelas \ref{metrica-lcom4} e \ref{metrica-lcom4-industria} apresentam a
métrica LCOM4 para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-lcom4, fig.align='center', results="asis"
% table = percentis_by_project("lcom4")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LCOM4 para as ferramentas da academia", "metrica-lcom4")
%% end.rcode

%% begin.rcode metrica-lcom4-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("lcom4")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LCOM4 para as ferramentas da indústria", "metrica-lcom4-industria")
%% end.rcode

\subsection{Número de linhas de código (LOC)}

LOC é a medida mais comum para o tamanho de um software, conta o número linhas
executáveis excluindo linhas em branco e comentários.

Os intervalos sugeridos para o LOC de uma classe (Java e C++) são: até 70
(bom); entre 70 e 130 (regular); de 130 em diante (ruim).

As Tabelas \ref{metrica-loc} e \ref{metrica-loc-industria} apresentam a
métrica LOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-loc, fig.align='center', results="asis"
% table = percentis_by_project("loc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LOC para as ferramentas da academia", "metrica-loc")
%% end.rcode

%% begin.rcode metrica-loc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("loc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica LOC para as ferramentas da indústria", "metrica-loc-industria")
%% end.rcode

\subsection{Número de atributos (NOA)}

NOA contabiliza o número de atributos de uma classe.

As Tabelas \ref{metrica-noa} e \ref{metrica-noa-industria} apresentam a
métrica NOA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-noa, fig.align='center', results="asis"
% table = percentis_by_project("noa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOA para as ferramentas da academia", "metrica-noa")
%% end.rcode

%% begin.rcode metrica-noa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOA para as ferramentas da indústria", "metrica-noa-industria")
%% end.rcode

\subsection{Número de filhos (NOC)}

NOC é o número total de flhos de uma classe.

As Tabelas \ref{metrica-noc} e \ref{metrica-noc-industria} apresentam a
métrica NOC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-noc, fig.align='center', results="asis"
% table = percentis_by_project("noc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOC para as ferramentas da academia", "metrica-noc")
%% end.rcode

%% begin.rcode metrica-noc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("noc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOC para as ferramentas da indústria", "metrica-noc-industria")
%% end.rcode

\subsection{Número de métodos (NOM)}

NOM indica o tamanho das classes em termos das suas operações implementadas.

As Tabelas \ref{metrica-nom} e \ref{metrica-nom-industria} apresentam a
métrica NOM para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-nom, fig.align='center', results="asis"
% table = percentis_by_project("nom")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOM para as ferramentas da academia", "metrica-nom")
%% end.rcode

%% begin.rcode metrica-nom-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("nom")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NOM para as ferramentas da indústria", "metrica-nom-industria")
%% end.rcode

\subsection{Número de atributos públicos (NPA)}

NPA mede o encapsulamento entre classes.

Os intervalos sugeridos para Java e C++ são: até 1 (bom); entre 1 e 9
(regular); de 9 em diante (ruim).

As Tabelas \ref{metrica-npa} e \ref{metrica-npa-industria} apresentam a
métrica NPA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-npa, fig.align='center', results="asis"
% table = percentis_by_project("npa")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPA para as ferramentas da academia", "metrica-npa")
%% end.rcode

%% begin.rcode metrica-npa-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npa")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPA para as ferramentas da indústria", "metrica-npa-industria")
%% end.rcode

\subsection{Número de métodos públicos (NPM)}

NPM indica o tamanho da ``interface'' da classe.

Os intervalos sugeridos para Java e C++ são: até 10 (bom); entre 10 e 40
(regular); de 40 em diante (ruim).

As Tabelas \ref{metrica-npm} e \ref{metrica-npm-industria} apresentam a
métrica NPA para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-npm, fig.align='center', results="asis"
% table = percentis_by_project("npm")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPM para as ferramentas da academia", "metrica-npm")
%% end.rcode

%% begin.rcode metrica-npm-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("npm")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica NPM para as ferramentas da indústria", "metrica-npm-industria")
%% end.rcode

\subsection{Resposta para uma classe (RFC)}

RFC conta o número de métodos que podem ser executados a partir de uma
mensagem enviada a um objeto dessa classe.

As Tabelas \ref{metrica-rfc} e \ref{metrica-rfc-industria} apresentam a
métrica RFC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-rfc, fig.align='center', results="asis"
% table = percentis_by_project("rfc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica RFC para as ferramentas da academia", "metrica-rfc")
%% end.rcode

%% begin.rcode metrica-rfc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("rfc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica RFC para as ferramentas da indústria", "metrica-rfc-industria")
%% end.rcode

\subsection{Complexidade estrutural (SC)}

SC é medida através da combinação das métricas de acoplamento (CBO) e coesão
(LCOM4).

As Tabelas \ref{metrica-sc} e \ref{metrica-sc-industria} apresentam a
métrica SC para as ferramentas da academia e da indústria, respectivamente.

%% begin.rcode metrica-sc, fig.align='center', results="asis"
% table = percentis_by_project("sc")
% total_modules = metric_by_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica SC para as ferramentas da academia", "metrica-sc")
%% end.rcode

%% begin.rcode sumario-sc, fig.align='center', results="asis"
% table = percentis_by_project("sc")
% table = table[-1:-5,]
% table = table[-4,]
% xt = xtable(summary(t(table)), caption="resumo da métrica SC nos percentis 75, 90 e 95 para as ferramentas da academia")
% print(xt, table.placement="H")
%% end.rcode

%% begin.rcode metrica-sc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("sc")
% total_modules = metric_by_nist_project("total_modules")
% table = add_column(table, total_modules, colname = "classes")
% knitr_latex_table(table, "percentis da métrica SC para as ferramentas da indústria", "metrica-sc-industria")
%% end.rcode

%% begin.rcode sumario-sc-industria, fig.align='center', results="asis"
% table = percentis_by_nist_project("sc")
% table = table[-1:-5,]
% table = table[-4,]
% xt = xtable(summary(t(table)), caption="resumo da métrica SC nos percentis 75, 90 e 95 para as ferramentas da indústria")
% print(xt, table.placement="H")
%% end.rcode

\end{document}

% vim: filetype=tex
