\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage[alf]{abntex2cite}
\usepackage[top=2cm,left=0.5in,right=0.5in,bottom=2cm]{geometry}

\title{
  Caracterização de Softwares Científicos no Contexto de Engenharia de
  Software Experimental
}
\author{Joenio Marques da Costa\\
  {\small Universidade Federal da Bahia (UFBA)} \\
  {\small joenio@colivre.coop.br}
}
\date{\today}

% sugestão do professor Ecivaldo sobre a ordem para escrever a dissertação
% 01 Problemática
% 02 Problemas (+hipóteses se houver)
% 03 Objetivos (Geral e Específicos)
% 04 Metodologia
% 05 Revisão sistemática
% 06 Resultados parciais (se houver)
% 07 Considerações parciais
% 08 Problemática (processo ciclico)
% 09 Resumo/Abstract
% 10 Título
% 11 Revisão

% feedback durante apresentacao 01/out
% * caracterizar se a ferramenta tem manuais, isso inviabiliza o uso
% * reduzir escopo no Brasil? (chris: ser internacional eh bom)
% * reduzir escopo em domínio específico? Ex: recuperacao arquitetural
%     ** a disponibilidade das ferramentas eh muito dificil, os links estao offline
%     ** arcade, so tem um aluno mexendo, mas n sabe ensinar a ferramenta, a ferramenta tem mto recurso
% * archview eh uma ferramenta que recebe atencao de forma esporatica, faz e larga lá
% trabalho futuro
% * pegar pesquisas em desenvolvimento com criacao de ferramentas e convidar
%   para seguir boas praticas para evitar os problemas que estou mostrando

\begin{document}

\maketitle

\section{Resumo do projeto}

Ciência Aberta é um movimento que tem por objetivo tornar a pesquisa
científica, seus dados e sua disseminação acessíveis à todos os interessados,
dentre as várias iniciativas deste movimento, destaca-se a preocupação com a
reprodutibilidade dos resultados de pesquisas de forma independente e aberta,
visto que a maioria dos componentes necessários para a reprodução dos
resultados de uma pesquisa -- por exemplo, códigos fonte e dados -- não são
publicados.

Em diversas linhas de pesquisa da Computação e, em especial, em Engenharia de
Software, é bastante comum que novos sistemas de software sejam desenvolvidos,
tais sistemas costumam ser utilizados como meio para atingir os resultados da
pesquisa ou, em alguns casos, são o próprio fim do estudo realizado. Neste
trabalho, tais sistemas ou ferramentas de software são nosso objeto de
pesquisa e serão chamados de {\it software científico}.

Seja como meio ou como fim, tais {\it softwares científicos} são produtos de
software e, tal como propõe a Engenharia de Software Experimental, precisam
ser avaliadas com uso de métodos científicos adequados. Neste contexto, é de
fundamental importância que os softwares utilizados ou desenvolvidos durante
estudos estejam disponíveis e em funcionamento.

%Nas últimas décadas, o foco em estudos empíricos na área de
%Engenharia de Software tem crescido, resultando no uso crescente de métodos
%científicos como surveys, estudos de caso, experimentos e revisões
%sistemáticas de literatura.  A replicação desses estudos empíricos podem, e
%devem, ser realizados, de modo a averiguar a sua validade e aumentar o nível
%de confiança em seus resultados. 

Neste trabalho de mestrado, será realizada uma revisão sistemática de
literatura, a partir de artigos da área de Engenharia de Software que tratam
de publicação de "softwares científicos", visando coletar e caracterizar
alguns atributos de tais softwares para prover recomendações iniciais para o
seu desenvolvimento e adoção em ampla escala em estudos empíricos em
Engenharia de Software.

\section{Objetivos}

O objetivo principal deste trabalho é melhorar a compreensão sobre as
ferramentas de software para análise de código fonte desenvolvidos durante
pesquisas em Engenharia de Software -- aqui denominados "software científico"
\ -- por meio de sua caracterização no contexto de estudos empíricos em
Engenharia de Software.

São objetivos específicos deste trabalho:

\begin{itemize}
  \item Realizar uma revisão sistemática, com base em artigos publicados nas
    principais conferências e periódicos da área de Engenharia de Software,
    sobre "software científico";
  \item Caracterizar os "softwares científicos" coletados em termos de
    atributos relacionados ao seu desenvolvimento;
  \item Caracterizar os "software científicos" coletados em termos de
    atributos relacionados à sua distribuição;
  \item Caracterizar os "software científicos" coletados  em termos de
    atributos relacionados ao seu uso em estudos empíricos, sejam primários ou
    replicações;
  \item Sintetizar informações sobre "softwares científicos" coletados;
  \item Prover um conjunto inicial de recomendações para facilitar a adoção de
    "softwares científicos" em estudos empíricos em Engenharia de Software. 
\end{itemize}

\section{Fundamentação teórica}

\subsection{Ciência Aberta}

Ciência Aberta é um movimento que tem por objetivo tornar a pesquisa
científica, seus dados e sua disseminação acessíveis à todos os interessados,
sejam amadores ou profissionais \cite{WikipediaOpenScience}. Sua principal
motivação está em possibilitar a reprodução dos resultados de pesquisas e em
garantir transparência das metodologias utilizadas, isto aumenta o impacto
social das pesquisas e gera economia de tempo e dinheiro para os pesquisadores
e para as instituições \cite{Nesta2010}.

Este movimento é guiado por princípios básicos de transparência,
acessibilidade e reusabilidade universais, disseminadas via ferramentas
online, ele é dividido em quatro grandes áreas: (1) Open Access, (2) Open
Data, (3) Open Source e (4) Open Reproducible Research. Dentre elas destaca-se
a Open Reproducible Research por preocupar-se com a reprodutibilidade dos
resultados de pesquisas de forma independente \cite{Stodden2009} e aberta, no
entanto, esta área tem recebido ainda pouca atenção da comunidade de pesquisa
\cite{Nancy2015} \cite{Grand2010Open} apesar do aumento geral do interesse
pelas práticas da Ciência Aberta \cite{Grand2010}.

Enquanto pesquisadores publicam artigos descrevendo e divulgando seus
resultados, é raro que façam o mesmo com toda a produção gerada durante a
pesquisa. A maioria dos componentes necessários para a reprodução dos
resultados de uma pesquisa -- por exemplo, códigos fonte e dados -- usualmente
permanecem não publicados. Este é um problema sério já que um dos fundamentos
da ciência é que novas descobertas sejam reproduzidas antes de serem
consideradas parte da base de conhecimento \cite{Stodden2009}.

Neste sentido, \citeonline{Prlic2012} dão dicas para o desenvolvimento aberto de software
científico e citam que disponibilizar o código criado durante pesquisas não
apenas aumenta o impacto como também se torna essencial para outros
reproduzirem os resultados encontrados. Eles citam ainda que manutenabilidade
e disponibilidade do software após a publicação é o maior problema enfrentado
pelos pesquisadores que desenvolvem tais softwares, e é aí que a
participação no desenvolvimento aberto desde o início pode trazer maior
benefício.

Dentro deste contexto, e considerando que pesquisas em engenharia de software
produzem bastante softwares científicos, surge a preocupação de avaliar tais
softwares em termos de sua manutenabilidade e disponibilidade a partir de
métodos científicos adequados.

\subsection{Engenharia de Software}

Sistemas de software são utilizados em praticamente todas as áreas do
conhecimento humano e têm exercido um papel essencial em nossa sociedade
\cite{Mafra2006}. A dependência crescente de serviços oferecidos por tais
sistemas evidencia a necessidade de produzir software de qualidade,
contornando os  desafios relacionados a funcionalidades incompletas ou
incorretas, custos acima do esperado ou prazos não cumpridos.

Diante destes desafios, surge a Engenharia de Software, uma disciplina
centrada no desenvolvimento de sistemas de software \cite{Wohlin2012} através
de uma abordagem sistemática, disciplinada, e quantificável para o
desenvolvimento, operação e manutenção \cite{SWEBOK2014}.

Nas últimas décadas, o foco em estudos empíricos na área de Engenharia de
Software tem crescido significantemente \cite{Stol2015}, resultando no uso
crescente de métodos como surveys, estudos de caso, experimentos e revisões
sistemáticas de literatura. Através destes estudos empíricos, pesquisadores
transformam a Engenharia de Software em uma disciplina mais científica e
controlável -- a  Engenharia de Software Experimental -- provendo meios para
avaliar e validar métodos, técnicas, linguagens e ferramentas.

O crescimento no número de pesquisas e publicações em Engenharia de Software
Experimental desperta a atenção para a necessidade de verificar a validade dos
estudos empíricos realizados -- um ponto central em qualquer pesquisa
científica. A validade de um estudo empírico deve ser averiguada com o intuito
de aumentar o nível de confiança em seus resultados, replicação costuma ser
citado como um importante meio para atingir tal objetivo \cite{Almqvist2006}.

Um dos primeiros artigos discutindo replicação de experimentos em Engenharia
de Software foi publicado por Basili et al. \cite{Mantyla2010} e sugere
replicação não apenas como uma escolha, mas como um possível "próximo passo" a
ser tomado após o experimento original ser concluído. Apesar do conceito
replicação de estudos empíricos em Engenharia de Software estar usualmente
associado à experimentação, argumenta-se que ele deve ser estendido para
incluir ao menos estudos de caso e surveys \cite{Basili1986}.

Em diversas linhas de pesquisa da Computação e, em especial, em Engenharia de
Software, é bastante comum que novos sistemas de software sejam desenvolvidos,
tais sistemas costumam ser utilizados como meio para atingir os resultados da
pesquisa ou, em alguns casos, são o próprio fim do estudo realizado. Neste
trabalho, tais ferramentas de software são nosso objeto de pesquisa e serão
chamados de "software científico" \ -- \citeonline{Portillo12} utiliza o
termo "research tool" para designar este mesmo tipo de software.

Softwares científicos são produtos de software e, em geral, precisam ser
avaliados com uso de métodos científicos adequados, e, é de fundamental
importância que estejam disponíveis e em funcionamento \cite{Kon2011}.

%Reviewing, criticizing, and improving code is easier for readers who can run
%the code themselves. Use of languages, libraries, systems, and tools which are
%widely available is strongly recommended \cite{McCormick2014}
%\cite{Barnes2013}.
%
%Os tópicos "irreproducibility studies", "reproducibility guidelines",
%"reproducibility testing" e "webometrics" são possíveis "gaps" dentro da
%agenda da Ciência Aberta\cite{Nancy2015}.

\subsubsection{Análise de Código Fonte}

O rápido crescimento no número de softwares nas últimas décadas leva a uma
crescente demanda por mecanismos e ferramentas de apoio à compreensão de,
desenvolvedores necessitam entender em profundade a implementação de um
determinado software antes de realizar atividades de correção ou refatoração
de forma eficiente \cite{Kirkov2010}.

Isto é evidenciado ao perceber que a complexidade dos softwares vem crescendo
à cada dia \cite{Kirkov2010}, tornando assim, extremamente útil a existência
de ferramentas de análise automática de código-fonte, tais ferramentas
auxiliam os desenvolvedores e engenheiros à compreender a implementação de um
determinado software de forma profunda e abrangente.

Essas ferramentas geram modelos de alto nível representando entidades,
relacionamentos, métricas, características ou outra informação qualquer
extraída diretamente do código-fonte, e permitem que sejam geradas
visualizações em diversos níveis de abstração representando o código-fonte.

% Dentre as inúmeras sub-áreas da engenharia de software, este trabalho irá
% focar do domínio de ferramentas de análise de código-fonte, esta escolha tem
% por base o domínio do pesquisador nesta área e a escolha de um domínio é
% necessário para reduzir o escopo e viabilizar a revisão de estudos e
% ferramentas de um domínio específico, do contrário o trabalho seria muito
% extenso e a revisão sistemática seria inviável dentro do prazo de um trabalho
% de pesquisa num mestrado.

\subsection{Revisão Sistemática e Meta-análise}

Muitos pesquisadores argumentam que, para se obter progressos em uma
determinada área do conhecimento, os resultados de vários experimentos e
outros estudos empíricos -- surveys e estudos de caso, por exemplo -- devem
ser combinados. Quando um conjunto de estudos empíricos é coletado sobre um
tópico, a síntese ou agregação entra em cena.

Quando os procedimentos da meta-análise, ou seja, síntese baseada em métodos
estatísticos \cite{Almqvist2006}, não são aplicáveis, a síntese descritiva
deve ser utilizada. Esta inclui visualização, tabulação e estatística
descritiva dos dados. Quanto mais ampla é a questão guiando a revisão de
literatura, mais métodos qualitativos são necessários para sua síntese.
\citeonline{Cruzes2011} apresentam uma visão geral de métodos qualitativos de
síntese, entre eles a síntese temática.

Adicionalmente, com o aumento na adoção de estudos empíricos em Engenharia de
Software, surge a necessidade de agregar evidências de múltiplos estudos
relacionados, de modo a obter respostas a questões impossíveis de serem
respondidas com os estudos individuais. A coleta e síntese de evidências
empíricas podem ser realizadas com rigor científico, por meio de Revisão
Sistemática da Literatura \cite{Kitchenham2007}. A Revisão Sistemática da
Literatura  é um meio de avaliar e interpretar pesquisas relevantes -- estudos
primários -- sobre uma dada questão em particular, tópico, área, ou fenômeno
de interesse.

\section{Metodologia}

\subsection{Objetivos}

O objetivo geral é ...

\subsection{Questões de pesquisa e hipóteses}

Baseando-se nisso levantamos as seguintes...

\subsection{Trabalhos relacionados}

...

\subsection{Coleta de dados}

Como serão coletados os dados, organizados, ...

\subsection{Análise de dados}

Como os dados foram analisados, etc...

Primeiramente será feita uma revisão sobre estudos secundários -- em especial,
revisões sistemáticas -- relacionados ao uso e desenvolvimento de "softwares
científicos".

Em seguida, será realizada uma revisão sistemática de literatura, com base nas
recomendações encontradas em \cite{Kitchenham2007}, a partir de artigos da
área de Engenharia de Software que tratam de publicação de "softwares
científicos" para análise de código fonte, visando caracterizar seus atributos
a partir das seguites perguntas:

\begin{itemize}
  \item Quais são os "softwares científicos" associados a pesquisas em
    engenharia de software?
  \item Como os "softwares científicos" publicados nestes estudos são
    licenciados e distribuídos?
  \item Como os "softwares científicos" são desenvolvidos, em termos de
    métodos e processos recomendados pela engenharia de software?
  \item Há colaboração entre pesquisadores de universidades distintas no
    desenvolvimento dos "softwares científicos" publicados?
  \item Os "softwares científicos" são avaliados internamente e externamente?
    Se sim, como são avaliados?
\end{itemize}

Critérios de inclusão:

INCLUSAO 1: Trabalhos com publicação de ferramentas de análise
estática, ou seja, "software científico" de análise estática publicados entre
os anos 2013 e 2014 nas conferências SCAM e CSMR.

Idiomas dos artigos em portugues e ingles serão incluídos.

Critérios de exclusão:

ESCLUSAO 1: Trabalhos que não publica ferramenta de análise estática

EXCLUSAO 2: Trabalhos que publicam a ferramenta mas não
disponibiliza seu código-fonte de forma alguma.

Etapa e número de papers

Pesquisa de todos os papers do SCAM 2013: total de papers = 24 \\
Pesquisa de todos os papers do SCAM 2014: total de papers = 35 \\

A partir das informações coletadas na revisão sistemática será feita agregação
e síntese dos dados, utilizando métodos quantitativos e qualitativos, com
objetivo de identificar temas recorrentes e problemas comuns, além de elaborar
conclusão a respeito dos diversos estudos analisados na revisão sistemática.

Após a caracterização realizada, espera-se propor um conjunto preliminar de
recomendações para desenvolvimento e adoção de "softwares científicos" para a
comunidade acadêmica de Engenharia de Software.

\subsection{Mapeamento sistemático}

1º processo de seleção

Serão selecionados artigos que apresentem informações no título e abstract que
satisfaçam os critérios de inclusão.

2º processo de seleção

Para os artigos não selecionados na 1º seleção, uma nova seleção será feita a
partir da leitura completa do artigo, os artigos que não estiverem deacordo
com os critérios de inclusão serão excluídos.

Artigos do 1º processo de seleção

Artigos SCAM 2013

Nº | titulo | Critério

06648178 | Empirical Investigation of SEA-Based Dependence Cluster Properties | exclusao 1
06648179 | Characterization and Assessment of the Linux Configuration Complexity | exclusao 1
06648180 | Criticality of Defects in Cyclic Dependent Components | exclusao 1
06648181 | Code Clustering Workbench | inclusao 1
06648182 | ForkSim: Generating Software Forks for Evaluating Cross-Project Similarity Analysis Tools | exclusao 1 (precisa confirmacao)
06648183 | Empirical Evidence of Large-Scale Diversity in API Usage of Object-Oriented Software | exclusao 1
06648184 | Aspectual Source Code Analysis with GASR | inclusao 1
06648185 | Driving a Sound Static Software Analyzer with Branch-and-Bound | inclusao 1
06648186 | PtrTracker: Pragmatic Pointer Analysis | inclusao 1
06648187 | Tracing with a Minimal Number of Probes | exclusao 2
06648188 | A State Alteration and Inspection-based Interactive Debugger | exclusao 1
06648189 | Proteum/FL: a Tool for Localizing Faults using Mutation Analysis | inclusao 1
06648190 | GeCoS: A Framework for Prototyping Custom Hardware Design Flows | exclusao 1
06648191 | Review Efforts Reduction by Partitioning of Static Analysis Warnings | exclusao 1
06648192 | JSN OSE : Detecting JavaScript Code Smells | inclusao 1
06648193 | Determining Dynamic Coupling in JavaScript Using Object Type Inference | exclusao 1
06648194 | CodeMetropolis – code visualisation in MineCraft | exclusao 1
06648195 | MetricMiner: Supporting Researchers in Mining Software Repositories | exclusao 1
06648196 | Assembler Restructuring in FermaT | exclusao 1
06648197 | A Hidden Markov Model to Detect Coded Information Islands in Free Text | exclusao 1
06648198 | Fix-it: An Extensible Code Auto-Fix Component in Review Bot | exclusao 1
06648199 | sql-schema-comparer: Support of Multi-Language Refactoring with Relational Databases | exclusao 1
06648200 | A Relational Symbolic Execution Algorithm for Constraint-Based Testing of Database Programs | exclusao 1
06648201 | Ontological Interpretation of Object-Oriented Programming Abstractions | exclusao 1


Artigos SCAM 2014

Nº | titulo | Critério

06975630 | Effect of clone information on the performance of developers fixing cloned bugs | exc 1
06975631 | Automatic Identification of Important Clones for Refactoring and Tracking | exc 1
06975632 | A Comparative Study of Bug Patterns in Java Cloned and Non-cloned Code | exc 1
06975633 | A Change-Type Based Empirical Study on the Stability of Cloned Code | exc 1
06975634 | C/C++ Thread Safety Analysis | inc 1
06975635 | Toolset and Program Repository for Code Coverage- Based Test Suite Analysis and Manipulation | exc 1
06975636 | The E KEKO /X Program Transformation Tool | exc 1
06975637 | Flowgen: Flowchart-Based Documentation Framework for C++ | inc 1
06975638 | PESTO: A Tool for Migrating DOM-based to Visual Web Tests | exc 1
06975639 | Pangea: A Workbench for Statically Analyzing Multi-Language Software Corpora | inc 1
06975640 | Source Meter Sonar Qube Plug-in | inc 1
06975641 | Total ADS: Automated Software Anomaly Detection System | exc 1
06975642 | ACUA: API Change and Usage Auditor | inc 1
06975643 | Bulk Fixing Coding Issues and Its Effects on Software Quality: Is It Worth Refactoring? | exc 1
06975644 | Instrumentation of Annotated C Programs for Test Generation | inc 1
06975645 | Scalable Security Verification of Software at Compile Time | inc 1
06975646 | Impact of Code Refactoring Using Object-Oriented Methodology on a Scientific Computing Application | exc 1
06975647 | Concolic Fault Abstraction | exc 1
06975648 | On the Accuracy of Forward Dynamic Slicing and Its Effects on Software Maintenance | exc 1
06975649 | Efficient Utilization of Secondary Storage for Scalable Dynamic Slicing | exc 1
06975650 | SENSA: Sensitivity Analysis for Quantitative Change-Impact Prediction | exc 1
06975651 | Seeing Is Slicing: Observation Based Slicing of Picture Description Languages | exc 1
06975652 | Explaining Why Methods Change Together | exc 1
06975653 | Studying Fine-Grained Co-evolution Patterns of Production and Test Code | exc 1
06975654 | Supplementary Bug Fixes vs. Re-opened Bugs | exc 1
06975655 | Semantic Versioning versus Breaking Changes: A Study of the Maven Repository | exc 1
06975656 | Fast Flow Analysis with Godel Hashes | exc 1
06975657 | A Parallel On-Demand Algorithm for Computing Interprocedural Dominators | exc 1
06975658 | Are Object Graphs Extracted Using Abstract Interpretation Significantly Different from the Code? | exc 1
06975659 | Bit-Level Taint Analysis | exc 1
06975660 | Pruning, Pushdown Exception-Flow Analysis | exc 1
06975661 | On Automatically Generating Commit Messages via Summarization of Source Code Changes | exc 1
06975662 | On the Use of Context in Recommending Exception Handling Code Examples | exc 1
06975663 | A Pattern Search Method for Unpreprocessed C Programs Based on Tokenized Syntax Trees | inc 1
06975664 | Identifying Source Code Reuse across Repositories Using LCS-Based Source Code Similarity | inc 1

Antes de fazer o segundo processo de seleção será feito uma análise dos
artigos selecionados na primeira seleção e das ferramentas publicadas nestes
artigos.

Artigos selecionados na primeira seleção com ferramentas para serem
analisadas (total de 15 artigos selecionados):

06648181 | Code Clustering Workbench:

O artigo disponibiliza um vídeo sobre a instalação e uso da ferramenta no link
abaixo mas o vídeo não está disponível, acesso em 12/nov/2016:

* http://youtu.be/vP552YRyz-s "Este vídeo não está disponível."

Ferramenta chamada CCW, não é uma ferramenta de análise estática e sim de
clusterização de código, utiliza por baixo uma outra ferramenta chamada
DepFinder.

Mas não informa nenhuma referência sobre o DepFinder, nenhum paper, nenhum
link para a ferramenta. Uma busca do Google retornou algumas ferramentas, as
primeiras são:

https://github.com/gapan/depfinder
A tool that finds dependencies of slackware packages

https://github.com/ericdill/depfinder
Find all the unique imports in your library

(não dá para ter certeza sobre quais destas 2 ferramentas o autor se refere
apenas lendo o artigo)

Resultado: este artigo será excluído da lista de artigos selecionados na
primeiro filtro.

06648184 | Aspectual Source Code Analysis with GASR | inclusao 1

GASR: a source code analysis tool in the tradition of logic program querying
that reasons over A SPECT J source code.

GASR is a source code analysis tool that works, as-is, on ASPECTJ source code only.

Não diz a licença, aparentemente nao é livre, não informa onde encontrar a
ferramenta.

06648185 | Driving a Sound Static Software Analyzer with Branch-and-Bound | inclusao 1

O artigo apresenta um plugin para o Frama-C chamado SPALTER

Informa que o código fonte pode ser encontrado em:
http://www.sts.tu-harburg.de/research/spalter.html

Referencia ao frama-c
http://blog.frama-c.com/index.php?post/2011/11/18/Analyzing-single-precision-floating-point-constants

Não explicita a licença do SPALTER no artigo

"não parece ser exatamente de análise estática, mas fica na lista por
enquanto, olhar mais de perto depois"

06648186 | PtrTracker: Pragmatic Pointer Analysis | inclusao 1

In this work we present a new pointer analysis tool for C/C++ code...

To demonstrate the practicality of the solution we integrate the pointer
analyzer into the C/C++ bug checking tool Goanna...

Pointer Analysis. A pointer analysis (or alias analysis) de
termines a set of all possible (symbolic) memory locations a
pointer variable might point to during execution.

A ferramenta proposta no artigo chama PtrTracker e faz... a
tool that annotates all pointer dereferences in a program with a set of
possible pointees, which themselves are normal variables

Goanna é uma ferramenta de análise estática...

O artigo não informa licença nem dá pistas de onde fazer download da
ferramenta!

06648189 | Proteum/FL: a Tool for Localizing Faults using Mutation Analysis | inclusao 1

Paper apresenta a ferramenta PROTEUM /FL, disponível em:

https://sites.google.com/site/mikepapadakis/proteum-fl

A ferramenta faz dentre várias outras coisas análise de código fonte C.
Integra com outras ferramentas: Proteum/IM

O paper não explicita a licença da Proteum/FL, apesar de informar que a
Proteum/IM é livre.

06648192 | JSNose: Detecting JavaScript Code Smells | inclusao 1

We present an automated
technique, called JSN OSE , to detect these code smells. Our
approach uses a metric-based algorithm, and combines static
with dynamic analysis to detect these smells in JavaScript
code.

We implement our approach in a tool called JSNose,
which is freely available;

extract JavaScript code from all .js and HTML
files, (4) parse the source code into an Abstract Syntax Tree
(AST) and analyze it by traversing the tree

We use the WebScarab proxy to intercept the JavaScrip-
t/HTML code. To parse the JavaScript code to an AST and
instrument the code, we use Mozilla Rhino. 2

Diz que está publicamente disponível mas não informa licença no paper:
http://salt.ece.ubc.ca/content/jsnose/

(JSNose não implementa análise estática de fato, e sim o Mozilla Rhino, este
artigo será excluído da seleção)

06975634 | C/C++ Thread Safety Analysis | inc 1

(este artigo usa clang e não publica nenhuma ferramenta nova, será excluído da
seleção)

06975637 | Flowgen: Flowchart-Based Documentation Framework for C++ | inc 1

Apresenta o Flowgen, parseia arquivos C++ e gera diagramas em formato HTML, usa
anotações (comentários com sintaxe especial). Usa Clang como parser C++

Flowgen is complementary to the widely-used Doxy-
gen documentation tool.

A ferramenta foi avaliada com um estudo do software Vincia

O artigo não cita a licença da ferramenta. Escrito em Python.

06975639 | Pangea: A Workbench for Statically Analyzing Multi-Language Software Corpora | inc 1

Pangea,
an infrastructure allowing fast
development of static analyses on multi-language corpora.

Estudos que fazem análise de grande base de código-fonte (ex varios projetos)
seguem um fluxo comum de obter os fontes, encontrar forma de analisar código,
analisar o codigo, converter num modelo os dados extraidos, refinar os dados
da análise, finalmente publicar a análise.

Estes passos são comuns a todos estudos, 

corpora by providing a
repository of language-independent object model snapshots.

Este repositório de meta-models podem ser usados por pesquisadores para
facilmente comparar, medir, etc...

Pangea stores cross-language software corpora in a centralized repository

FAMIX-
compliant models using MSE as interchange format.
FAMIX is a well-known object-oriented meta-model and
MSE is the default interchange format between a series
of software analysis tools[2].

(a ideia parece com o que pensei para o codejuicer, mas faz muita coisa, ele
fornece ponta-a-ponta, tanto o repositorio e a infra quanto as ferramentas que
o pesquisados deve usar como cliente desta infra)

Mas é muito interessante, com um comando eu posso fazer download dos modelos
(dados já analisados de um certo projeto), posso também baixar o proprio
codigo fonte (n acho necessario).

O repositório atual (da data do artigo) conta com vários projetos Java e
SmallTalk

Estudos interessantes para eu ler no futuro sobre ideias de repositorios de
dados:

Daniel Rodriguez et al. [6] have recently published a survey
of all the existing software engineering repositories publicly
available. Some of the repositories they mention — The
Sourcerer project dataset [7], software-artifact infrastructure
repository [8] — could be taken into consideration to extend
Pangea.Data.
PROMISE [9] is a collection of intermediate results that
have been obtained from previous analyses. Its goal is to
provide raw materials for empirical studies. The provided data
is user contributed, often uncorrelated and usually focused on
very specific aspects and properties of software systems.
[6] D. Rodriguez, I. Herraiz, and R. Harrison, “On software engineering
repositories and their open problems,” in Realizing Artificial Intelligence
Synergies in Software Engineering (RAISE), 2012 First International
Workshop on, june 2012, pp. 52 –56.
[7] S. Bajracharya, J. Ossher, and C. Lopes, “Sourcerer: An internet-scale
software repository,” in Search-Driven Development-Users, Infrastruc-
ture, Tools and Evaluation, 2009. SUITE ’09. ICSE Workshop on, may
2009, pp. 1 –4.
[8] G. R. Group et al., “Software-artifact infrastructure repository (SIR),”
2009.
[9] T. Menzies, B. Caglayan, E. Kocaguneli, J. Krall, F. Peters, and
B. Turhan. (2012, June) The promise repository of empirical software
engineering data. [Online]. Available: http://promisedata.googlecode.com

(este é um projeto muito interessante mas não é uma ferramenta de análise
estática e sairá da coleção de papers do mapeamento)

06975640 | Source Meter Sonar Qube Plug-in | inc 1

SourceMeter é um plugin que extende a análise de código Java SonarQube com
FrontEndART’s high-end Java code analysis engine.

Não cita a licença da ferramenta, diz que é free e pode ser baixado em

http://www.sourcemeter.com



06975642 | ACUA: API Change and Usage Auditor | inc 1


ACUA é uma ferramenta para analisar cliente e framework e calcular as mudanças
entre as APIs, o desenvolvedor pode usar pra decidir quando começar a
atualizar o cliente para uma nova versão da API

a tool to collect API change and usage information
through the analysis of the binary code of frameworks and
client programs.

Faz parser de arquivos jar, Model builder uses the ASM Java bytecode analysis
framework 5 to extract the model data from the jar files.

ACUA recebe como entrada os modelos gerados pelo ASM e não faz o parser
propriamente dito.

Fornece o link abaixo para obter a ferramenta e os dados do estudo, mas não
cita a licença no artigo:

http://ptidej.net/downloads/replications/scam2014tools

(como não é uma ferramenta de analise estatica sairá da lista)

06975644 | Instrumentation of Annotated C Programs for Test Generation | inc 1

Implementa a ferramenta S TA D Y , uma ferramenta que faz a ponte entre
análise estática e dinamica. Converte anotações E-ACSL em código C executável.

Implementa isso como parte do Frama-C, não informa licença nem diz onde
encontrar.

(excluido da lista, nao implementa analise estatica)

06975645 | Scalable Security Verification of Software at Compile Time | inc 1

Implementa uma extensão do GCC chamada e-munity disponível em:

http://sourceforge.net/p/emunity/code/ci/master/tree/

Não cita a licença no artigo.

06975663 | A Pattern Search Method for Unpreprocessed C Programs Based on Tokenized Syntax Trees | inc 1

Implementar um parser de código C e também de QUERY, não dá um nome, chama
apenas de "search tool" (mentira o nome é TEBA). É um conjunto de ferramentas, disponível em:

http://tebasaki.jp/src

O estudo realiza aplicacao das ferramentas em projetos open source. Não
informa a licença das ferramentas. Escritas em Perl.

06975664 | Identifying Source Code Reuse across Repositories Using LCS-Based Source Code Similarity | inc 1

(enviei em 16/nov email para os chairs da trilha ferramentas do SCAM 2014
perguntando onde encontro os papers da trilha ferramentas)

17/11 - Foutse Khomh respondeu informando que no IEEEXplore tem tudo,
incluindo os tools papers.

\section{Resultados esperados}

\begin{itemize}
  \item Caracterização dos atributos das ferramentas de software desenvolvidas
    durante pesquisas em engenharia de software, chamadas aqui de \textit{"softwares científicos"};
  \item Síntese dos resultados e lições a respeito de temas recorrentes e
    problemas comuns no desenvolvimento e publicação de \textit{"softwares
      científicos"};
  \item Conjunto preliminar de recomendações para desenvolvimento e adoção de
    \textit{"softwares científicos"} para a comunidade acadêmica de Engenharia de
    Software;
  \item Artigos científicos publicados;
  \item Dissertação de mestrado.
\end{itemize}

\section{Atividades e metas}

\subsection{Meta 1: Realizar revisão sistemática}

Atividades:

\begin{itemize}
  \item Pesquisar estudos secundários sobre o tema;
  \item Identificar fontes de dados: bibliotecas digitais; anais em
    conferências sobre ferramentas;
  \item Levantar e selecionar dados/papers sobre ferramentas de software
  \item Iniciar e documentar análise dos papers selecionados
  \item Agregar e sintetizar informações encontradas
\end{itemize}

\subsection{Meta 2: Divulgar resultados}

Atividades:

\begin{itemize}
  \item Apresentar qualificação de mestrado
  \item Elaborar artigo científico sobre caracterização de ferramentas de pesquisa publicadas no Brasil
  \item Elaborar artigo científico com lições a respeito de desenvolvimento e publicação de ferramentas de pesquisa
  \item Elaborar artigo científico com recomendações para desenvolvimento e adoção de ferramentas de pesquisa
  \item Elaborar dissertação de mestrado
  \item Apresentar dissertação de mestrado
\end{itemize}

\bibliography{bibliografia}

\end{document}
