* Feedback de paulo sobre os dados:
  * CBO claramente tem um comportamento diferente das demais, geralmente
    o crescimento é exponencial ou calda longa, mas CBO não tem mostrado
    este comportamento, as vezes é calda loga inertida
  * Na qualificação posso mostrar todas as métricas e na discussão
    irei selecionar algumas (possivelmente CBO, LCOM4 e SC)
  * Fácil notar só olhando a tabela que no percentil 75% (muito frequente)
    os valores estão bons, bons significa próximo dos valores teóricos ideais
  * Os valores dos percentis 90% e acima são pontos fora da curva, n podemos
    usar estes valores como alerta para indicar que o projeto está ruim
  * O crescimento reflete o mesmo comportamento dos estudos de paulo e
    kanashiro

* Feedback Chris/Paulo:
  * Na fund teorica cito arquitetura da ferramenta de analise estatica,
    irei discutir isto na metodologia/analise?
  * A caracterização da SC irá indicar que a qualidade n é ruim necessariamente
    mas que é uma caractaristica natural deste domínio, e isto irá guiar
    como proceder para evoluir e manter tais ferramentas
  * Tese de Paulo 4.1 e 4.3 (percentis, a média pode nos enganar)
  * A SC é mais alta neste domínio de aplicação (hipótese)
  * Ao menos objetivo geral, especifico, questao e hipoteses, contribuicoes, etc...
  * ... porque? para quem quiser manter/evoluir uma ferramenta de analise estatica
    entender que uma SC X ou Y para este dominio n eh ruim, mas é uma caracteristica natural

Métricas de design ou métricas de código-fonte são aquelas voltadas à medir
artefatos de código-fonte e podem ser classificados entre métricas procedurais
ou orientadas à objetos \cite{Mohamed1994}.

\chapter{Métricas de design de código-fonte}

(ver trabalho de Arthur Del Spot e Tese de Paulo, SC (focar) conforme Terceiro)

\chapter{Metodologia}

%explicar:
%* revisão estruturada
%* análise de distribuição dos valores das métricas
%
%(ver TCC de Ronaldo e Kanashiro)
%( falar que média não serve, distribuição é a solução... etc )

\section{Exemplo de uso}

Por fim, os valores de referência encontradas serão documentados e servirão de
base para criar um guia de sugestões para refatoração de ferramentas de
análise estática. Tomaremos como exemplo de uso a própria ferramenta Analizo,
onde iremos calcular suas métricas e a partir de uma comparação com os
valores de referência indicaremos refatorações que façam a ferramenta de
aproximar dos valores de referência.

Estas indicações serão feitas utilizando o mesmo método de
\citeonline{Almeida2010} onde foi feito um estudo mapeando boas práticas de
programação em valores de métricas de código-fonte, estas boas práticas são
baseadas nos trabalhos de \cite{Martin2012} e \cite{Beck2007} sobre {\it Clean
Code}, onde sugerem práticas de desenvolvimento úteis para que um código
tenham expressividade, simplicidade e flexibilidade. Neste trabalho os autores
identificam melhorias de implementação através do uso de valores de métricas e
oferecem aos desenvolvedores uma maneira de pensarem em melhorias para os seus
códigos.

\chapter{Cronograma}

\begin{table}[h]
  \caption{Cronograma até a defesa}
  \centering
  \begin{tabular}{| l | c | c | c | c | c | c |}
    \hline
    Atividade & Junho & Julho & Agosto & Setembro & Outubro & Novembro (?) \\
    \hline
    Qualificação &    &       &        &          &         &              \\
    ???          &    &       &        &          &         &              \\
    ???          &    &       &        &          &         &              \\
    ???          &    &       &        &          &         &              \\
    \hline
  \end{tabular}
  \label{cronograma-defesa}
\end{table}

\begin{table}[h]
  \caption{Cronograma até a qualificação}
  \centering
  \begin{tabular}{| l | l |}
    \hline
    Data          & Atividade \\
    \hline
    20 Junho      & texto final para os orientadores \\
    22/23 Junho   & feedback final dos orientadores \\
    23 à 27 Junho & correções finais \\
    27 Junho      & envio para banca \\
    27 Junho à 04 Julho & compilação dos últimos resultados, inclusive o que não entraram no texto da quali (mas que podem ser apresentados na defesa da Quali) \\
    6/7/8 Julho   & (a depender do dia da sua viagem para SSA): Prévia/ensaio da apresentação no LAPPIS/UnB. \\
    11 Julho      & Qualificação, na UFBA \\
    \hline
  \end{tabular}
  \label{artigos-do-scam}
\end{table}

\chapter{Análise}

\section{Resultados preliminares}\label{resultados}

\section{Desafios da análise estática}

Principal 2: Less is More. Does this movement that
started in graphic design speak to source-code analysis?
Any programmer who has set out to write an analysis tool
confronts significant obstacles. First, simple parsing is not
as simple as it should be. For example, C++ is not LR(n)
(for any n!). Furthermore, the presence of casting, pointer
arithmetic, dynamic class loading, reflection, and the like,
complicate semantic analysis. This leads to the question
“how good a tool would I need to create for programmers to
use a ‘simple’ language?” Language design seems headed
in the opposite direction (Fortran “9x” is an excellent ex-
ample). Against an increasing need for higher precision
source-code analysis, modern languages increasingly re-
quire tools to handle only partially known behavior (in the
case of Java this is caused by features such as generics, user-
defined types, plug-in components, reflection, and dynamic
class loading). These features increase flexibility at run-
time, but compromise static analysis. In considering each
of the following research areas, consider also the role that
analysis quality should play in the language design debate.

Until alternate formalisms come into common usage,
source code will continue to be definitive in describing pro-
gram behavior. Based on the past 40 years, programming
languages can be expected to continue to incorporate new
features that complicate program semantics. Given its cen-
tral role in software engineering, source code and source-
code analysis will remain “hot topics” and thus the focus
of intense research activity into the foreseeable future. To
ensure future progress including necessary, but unforeseen
breakthroughs, it is important for future source-code anal-
ysis research to continue to investigate a wide diversity of
ideas.

%Many of these tools
%are seeking the same kind of programming errors, but, to
%date, only a few tools have been compared with each other.
%In this paper, we will look at what the static code analyzers
%can do and we will try to present a systematic tree of
%features and assets of static code analysis tools. Finally, we
%will attempt to compare a few tools for static analysis of
%code in our newly developed systematic tree.
%
%este artigo faz uma caracterizacao muito interessante de ferramentas de
%análise estática, cria categorias para caracterizar, muito bom! é algo do que
%eu gostaria de fazer originalmente, posso guardar isso pro futuro e usar as
%mesmas caracteristicas para aplicar em outro grupo de ferramentas.
%
%(/home/joenio/Downloads/Taxonomy of Static Code Analysis Tools.pdf)
